! function e(t, n, i) {
    function r(s, o) {
        if (!n[s]) {
            if (!t[s]) {
                var l = "function" == typeof require && require;
                if (!o && l) return l(s, true);
                if (a) return a(s, true);
                var c = new Error("Cannot find module '" + s + "'");
                throw c.code = "MODULE_NOT_FOUND", c
            }
            var u = n[s] = {
                exports: {}
            };
            t[s][0].call(u.exports, (function (e) {
                return r(t[s][1][e] || e)
            }), u, u.exports, e, t, n, i)
        }
        return n[s].exports
    }
    for (var a = "function" == typeof require && require, s = 0; s < i.length; s++) r(i[s]);
    return r
}({
    1: [function (e, t, n) {
        var i = Object.prototype.toString;
        t.exports = function (e) {
            return e.BYTES_PER_ELEMENT && "[object ArrayBuffer]" === i.call(e.buffer) || Array.isArray(e)
        }
    }, {}],
    2: [function (e, t, n) {
        "use strict";
        var i = {
                update: null,
                begin: null,
                loopBegin: null,
                changeBegin: null,
                change: null,
                changeComplete: null,
                loopComplete: null,
                complete: null,
                loop: 1,
                direction: "normal",
                autoplay: true,
                timelineOffset: 0
            },
            r = {
                duration: 1e3,
                delay: 0,
                endDelay: 0,
                easing: "easeOutElastic(1, .5)",
                round: 0
            },
            a = ["translateX", "translateY", "translateZ", "rotate", "rotateX", "rotateY", "rotateZ", "scale", "scaleX", "scaleY", "scaleZ", "skew", "skewX", "skewY", "perspective", "matrix", "matrix3d"],
            s = {
                CSS: {},
                springs: {}
            };
        function o(e, t, n) {
            return Math.min(Math.max(e, t), n)
        }
        function l(e, t) {
            return e.indexOf(t) > -1
        }
        function c(e, t) {
            return e.apply(null, t)
        }
        var u = {
            arr: function (e) {
                return Array.isArray(e)
            },
            obj: function (e) {
                return l(Object.prototype.toString.call(e), "Object")
            },
            pth: function (e) {
                return u.obj(e) && e.hasOwnProperty("totalLength")
            },
            svg: function (e) {
                return e instanceof SVGElement
            },
            inp: function (e) {
                return e instanceof HTMLInputElement
            },
            dom: function (e) {
                return e.nodeType || u.svg(e)
            },
            str: function (e) {
                return "string" == typeof e
            },
            fnc: function (e) {
                return "function" == typeof e
            },
            und: function (e) {
                return void 0 === e
            },
            nil: function (e) {
                return u.und(e) || null === e
            },
            hex: function (e) {
                return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(e)
            },
            rgb: function (e) {
                return /^rgb/.test(e)
            },
            hsl: function (e) {
                return /^hsl/.test(e)
            },
            col: function (e) {
                return u.hex(e) || u.rgb(e) || u.hsl(e)
            },
            key: function (e) {
                return !i.hasOwnProperty(e) && !r.hasOwnProperty(e) && "targets" !== e && "keyframes" !== e
            }
        };
        function h(e) {
            var t = /\(([^)]+)\)/.exec(e);
            return t ? t[1].split(",").map((function (e) {
                return parseFloat(e)
            })) : []
        }
        function d(e, t) {
            var n = h(e),
                i = o(u.und(n[0]) ? 1 : n[0], .1, 100),
                r = o(u.und(n[1]) ? 100 : n[1], .1, 100),
                a = o(u.und(n[2]) ? 10 : n[2], .1, 100),
                l = o(u.und(n[3]) ? 0 : n[3], .1, 100),
                c = Math.sqrt(r / i),
                d = a / (2 * Math.sqrt(r * i)),
                p = d < 1 ? c * Math.sqrt(1 - d * d) : 0,
                f = d < 1 ? (d * c - l) / p : -l + c;
            function m(e) {
                var n = t ? t * e / 1e3 : e;
                return n = d < 1 ? Math.exp(-n * d * c) * (1 * Math.cos(p * n) + f * Math.sin(p * n)) : (1 + f * n) * Math.exp(-n * c), 0 === e || 1 === e ? e : 1 - n
            }
            return t ? m : function () {
                var t = s.springs[e];
                if (t) return t;
                for (var n = 1 / 6, i = 0, r = 0;;)
                    if (1 === m(i += n)) {
                        if (++r >= 16) break
                    } else r = 0;
                var a = i * n * 1e3;
                return s.springs[e] = a, a
            }
        }
        function p(e) {
            return void 0 === e && (e = 10),
                function (t) {
                    return Math.ceil(o(t, 1e-6, 1) * e) * (1 / e)
                }
        }
        var f, m, g = function () {
                var e = .1;
                function t(e, t) {
                    return 1 - 3 * t + 3 * e
                }
                function n(e, t) {
                    return 3 * t - 6 * e
                }
                function i(e) {
                    return 3 * e
                }
                function r(e, r, a) {
                    return ((t(r, a) * e + n(r, a)) * e + i(r)) * e
                }
                function a(e, r, a) {
                    return 3 * t(r, a) * e * e + 2 * n(r, a) * e + i(r)
                }
                return function (t, n, i, s) {
                    if (0 <= t && t <= 1 && 0 <= i && i <= 1) {
                        var o = new Float32Array(11);
                        if (t !== n || i !== s)
                            for (var l = 0; l < 11; ++l) o[l] = r(l * e, t, i);
                        return function (e) {
                            return t === n && i === s || 0 === e || 1 === e ? e : r(c(e), n, s)
                        }
                    }
                    function c(n) {
                        for (var s = 0, l = 1; 10 !== l && o[l] <= n; ++l) s += e;
                        --l;
                        var c = s + (n - o[l]) / (o[l + 1] - o[l]) * e,
                            u = a(c, t, i);
                        return u >= .001 ? function (e, t, n, i) {
                            for (var s = 0; s < 4; ++s) {
                                var o = a(t, n, i);
                                if (0 === o) return t;
                                t -= (r(t, n, i) - e) / o
                            }
                            return t
                        }(n, c, t, i) : 0 === u ? c : function (e, t, n, i, a) {
                            var s, o, l = 0;
                            do {
                                (s = r(o = t + (n - t) / 2, i, a) - e) > 0 ? n = o : t = o
                            } while (Math.abs(s) > 1e-7 && ++l < 10);
                            return o
                        }(n, s, s + e, t, i)
                    }
                }
            }(),
            v = (f = {
                linear: function () {
                    return function (e) {
                        return e
                    }
                }
            }, m = {
                Sine: function () {
                    return function (e) {
                        return 1 - Math.cos(e * Math.PI / 2)
                    }
                },
                Circ: function () {
                    return function (e) {
                        return 1 - Math.sqrt(1 - e * e)
                    }
                },
                Back: function () {
                    return function (e) {
                        return e * e * (3 * e - 2)
                    }
                },
                Bounce: function () {
                    return function (e) {
                        for (var t, n = 4; e < ((t = Math.pow(2, --n)) - 1) / 11;);
                        return 1 / Math.pow(4, 3 - n) - 7.5625 * Math.pow((3 * t - 2) / 22 - e, 2)
                    }
                },
                Elastic: function (e, t) {
                    void 0 === e && (e = 1), void 0 === t && (t = .5);
                    var n = o(e, 1, 10),
                        i = o(t, .1, 2);
                    return function (e) {
                        return 0 === e || 1 === e ? e : -n * Math.pow(2, 10 * (e - 1)) * Math.sin((e - 1 - i / (2 * Math.PI) * Math.asin(1 / n)) * (2 * Math.PI) / i)
                    }
                }
            }, ["Quad", "Cubic", "Quart", "Quint", "Expo"].forEach((function (e, t) {
                m[e] = function () {
                    return function (e) {
                        return Math.pow(e, t + 2)
                    }
                }
            })), Object.keys(m).forEach((function (e) {
                var t = m[e];
                f["easeIn" + e] = t, f["easeOut" + e] = function (e, n) {
                    return function (i) {
                        return 1 - t(e, n)(1 - i)
                    }
                }, f["easeInOut" + e] = function (e, n) {
                    return function (i) {
                        return i < .5 ? t(e, n)(2 * i) / 2 : 1 - t(e, n)(-2 * i + 2) / 2
                    }
                }, f["easeOutIn" + e] = function (e, n) {
                    return function (i) {
                        return i < .5 ? (1 - t(e, n)(1 - 2 * i)) / 2 : (t(e, n)(2 * i - 1) + 1) / 2
                    }
                }
            })), f);
        function y(e, t) {
            if (u.fnc(e)) return e;
            var n = e.split("(")[0],
                i = v[n],
                r = h(e);
            switch (n) {
            case "spring":
                return d(e, t);
            case "cubicBezier":
                return c(g, r);
            case "steps":
                return c(p, r);
            default:
                return c(i, r)
            }
        }
        function x(e) {
            try {
                return document.querySelectorAll(e)
            } catch (e) {
                return
            }
        }
        function b(e, t) {
            for (var n = e.length, i = arguments.length >= 2 ? arguments[1] : void 0, r = [], a = 0; a < n; a++)
                if (a in e) {
                    var s = e[a];
                    t.call(i, s, a, e) && r.push(s)
                } return r
        }
        function _(e) {
            return e.reduce((function (e, t) {
                return e.concat(u.arr(t) ? _(t) : t)
            }), [])
        }
        function w(e) {
            return u.arr(e) ? e : (u.str(e) && (e = x(e) || e), e instanceof NodeList || e instanceof HTMLCollection ? [].slice.call(e) : [e])
        }
        function E(e, t) {
            return e.some((function (e) {
                return e === t
            }))
        }
        function M(e) {
            var t = {};
            for (var n in e) t[n] = e[n];
            return t
        }
        function T(e, t) {
            var n = M(e);
            for (var i in e) n[i] = t.hasOwnProperty(i) ? t[i] : e[i];
            return n
        }
        function S(e, t) {
            var n = M(e);
            for (var i in t) n[i] = u.und(e[i]) ? t[i] : e[i];
            return n
        }
        function A(e) {
            return u.rgb(e) ? (n = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(t = e)) ? "rgba(" + n[1] + ",1)" : t : u.hex(e) ? function (e) {
                var t = e.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, (function (e, t, n, i) {
                        return t + t + n + n + i + i
                    })),
                    n = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);
                return "rgba(" + parseInt(n[1], 16) + "," + parseInt(n[2], 16) + "," + parseInt(n[3], 16) + ",1)"
            }(e) : u.hsl(e) ? function (e) {
                var t, n, i, r = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(e) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(e),
                    a = parseInt(r[1], 10) / 360,
                    s = parseInt(r[2], 10) / 100,
                    o = parseInt(r[3], 10) / 100,
                    l = r[4] || 1;
                function c(e, t, n) {
                    return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e
                }
                if (0 == s) t = n = i = o;
                else {
                    var u = o < .5 ? o * (1 + s) : o + s - o * s,
                        h = 2 * o - u;
                    t = c(h, u, a + 1 / 3), n = c(h, u, a), i = c(h, u, a - 1 / 3)
                }
                return "rgba(" + 255 * t + "," + 255 * n + "," + 255 * i + "," + l + ")"
            }(e) : void 0;
            var t, n
        }
        function L(e) {
            var t = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(e);
            if (t) return t[1]
        }
        function R(e, t) {
            return u.fnc(e) ? e(t.target, t.id, t.total) : e
        }
        function P(e, t) {
            return e.getAttribute(t)
        }
        function C(e, t, n) {
            if (E([n, "deg", "rad", "turn"], L(t))) return t;
            var i = s.CSS[t + n];
            if (!u.und(i)) return i;
            var r = document.createElement(e.tagName),
                a = e.parentNode && e.parentNode !== document ? e.parentNode : document.body;
            a.appendChild(r), r.style.position = "absolute", r.style.width = 100 + n;
            var o = 100 / r.offsetWidth;
            a.removeChild(r);
            var l = o * parseFloat(t);
            return s.CSS[t + n] = l, l
        }
        function I(e, t, n) {
            if (t in e.style) {
                var i = t.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
                    r = e.style[t] || getComputedStyle(e).getPropertyValue(i) || "0";
                return n ? C(e, r, n) : r
            }
        }
        function F(e, t) {
            return u.dom(e) && !u.inp(e) && (!u.nil(P(e, t)) || u.svg(e) && e[t]) ? "attribute" : u.dom(e) && E(a, t) ? "transform" : u.dom(e) && "transform" !== t && I(e, t) ? "css" : null != e[t] ? "object" : void 0
        }
        function D(e) {
            if (u.dom(e)) {
                for (var t, n = e.style.transform || "", i = /(\w+)\(([^)]*)\)/g, r = new Map; t = i.exec(n);) r.set(t[1], t[2]);
                return r
            }
        }
        function N(e, t, n, i) {
            var r = l(t, "scale") ? 1 : 0 + function (e) {
                    return l(e, "translate") || "perspective" === e ? "px" : l(e, "rotate") || l(e, "skew") ? "deg" : void 0
                }(t),
                a = D(e).get(t) || r;
            return n && (n.transforms.list.set(t, a), n.transforms.last = t), i ? C(e, a, i) : a
        }
        function O(e, t, n, i) {
            switch (F(e, t)) {
            case "transform":
                return N(e, t, i, n);
            case "css":
                return I(e, t, n);
            case "attribute":
                return P(e, t);
            default:
                return e[t] || 0
            }
        }
        function H(e, t) {
            var n = /^(\*=|\+=|-=)/.exec(e);
            if (!n) return e;
            var i = L(e) || 0,
                r = parseFloat(t),
                a = parseFloat(e.replace(n[0], ""));
            switch (n[0][0]) {
            case "+":
                return r + a + i;
            case "-":
                return r - a + i;
            case "*":
                return r * a + i
            }
        }
        function U(e, t) {
            if (u.col(e)) return A(e);
            if (/\s/g.test(e)) return e;
            var n = L(e),
                i = n ? e.substr(0, e.length - n.length) : e;
            return t ? i + t : i
        }
        function B(e, t) {
            return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2))
        }
        function z(e) {
            for (var t, n = e.points, i = 0, r = 0; r < n.numberOfItems; r++) {
                var a = n.getItem(r);
                r > 0 && (i += B(t, a)), t = a
            }
            return i
        }
        function k(e) {
            if (e.getTotalLength) return e.getTotalLength();
            switch (e.tagName.toLowerCase()) {
            case "circle":
                return function (e) {
                    return 2 * Math.PI * P(e, "r")
                }(e);
            case "rect":
                return function (e) {
                    return 2 * P(e, "width") + 2 * P(e, "height")
                }(e);
            case "line":
                return function (e) {
                    return B({
                        x: P(e, "x1"),
                        y: P(e, "y1")
                    }, {
                        x: P(e, "x2"),
                        y: P(e, "y2")
                    })
                }(e);
            case "polyline":
                return z(e);
            case "polygon":
                return function (e) {
                    var t = e.points;
                    return z(e) + B(t.getItem(t.numberOfItems - 1), t.getItem(0))
                }(e)
            }
        }
        function G(e, t) {
            var n = t || {},
                i = n.el || function (e) {
                    for (var t = e.parentNode; u.svg(t) && u.svg(t.parentNode);) t = t.parentNode;
                    return t
                }(e),
                r = i.getBoundingClientRect(),
                a = P(i, "viewBox"),
                s = r.width,
                o = r.height,
                l = n.viewBox || (a ? a.split(" ") : [0, 0, s, o]);
            return {
                el: i,
                viewBox: l,
                x: l[0] / 1,
                y: l[1] / 1,
                w: s,
                h: o,
                vW: l[2],
                vH: l[3]
            }
        }
        function V(e, t, n) {
            function i(n) {
                void 0 === n && (n = 0);
                var i = t + n >= 1 ? t + n : 0;
                return e.el.getPointAtLength(i)
            }
            var r = G(e.el, e.svg),
                a = i(),
                s = i(-1),
                o = i(1),
                l = n ? 1 : r.w / r.vW,
                c = n ? 1 : r.h / r.vH;
            switch (e.property) {
            case "x":
                return (a.x - r.x) * l;
            case "y":
                return (a.y - r.y) * c;
            case "angle":
                return 180 * Math.atan2(o.y - s.y, o.x - s.x) / Math.PI
            }
        }
        function j(e, t) {
            var n = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g,
                i = U(u.pth(e) ? e.totalLength : e, t) + "";
            return {
                original: i,
                numbers: i.match(n) ? i.match(n).map(Number) : [0],
                strings: u.str(e) || t ? i.split(n) : []
            }
        }
        function W(e) {
            return b(e ? _(u.arr(e) ? e.map(w) : w(e)) : [], (function (e, t, n) {
                return n.indexOf(e) === t
            }))
        }
        function X(e) {
            var t = W(e);
            return t.map((function (e, n) {
                return {
                    target: e,
                    id: n,
                    total: t.length,
                    transforms: {
                        list: D(e)
                    }
                }
            }))
        }
        function Y(e, t) {
            var n = M(t);
            if (/^spring/.test(n.easing) && (n.duration = d(n.easing)), u.arr(e)) {
                var i = e.length;
                2 === i && !u.obj(e[0]) ? e = {
                    value: e
                } : u.fnc(t.duration) || (n.duration = t.duration / i)
            }
            var r = u.arr(e) ? e : [e];
            return r.map((function (e, n) {
                var i = u.obj(e) && !u.pth(e) ? e : {
                    value: e
                };
                return u.und(i.delay) && (i.delay = n ? 0 : t.delay), u.und(i.endDelay) && (i.endDelay = n === r.length - 1 ? t.endDelay : 0), i
            })).map((function (e) {
                return S(e, n)
            }))
        }
        function q(e, t) {
            var n = [],
                i = t.keyframes;
            for (var r in i && (t = S(function (e) {
                    for (var t = b(_(e.map((function (e) {
                            return Object.keys(e)
                        }))), (function (e) {
                            return u.key(e)
                        })).reduce((function (e, t) {
                            return e.indexOf(t) < 0 && e.push(t), e
                        }), []), n = {}, i = function (i) {
                            var r = t[i];
                            n[r] = e.map((function (e) {
                                var t = {};
                                for (var n in e) u.key(n) ? n == r && (t.value = e[n]) : t[n] = e[n];
                                return t
                            }))
                        }, r = 0; r < t.length; r++) i(r);
                    return n
                }(i), t)), t) u.key(r) && n.push({
                name: r,
                tweens: Y(t[r], e)
            });
            return n
        }
        function Q(e, t) {
            var n;
            return e.tweens.map((function (i) {
                var r = function (e, t) {
                        var n = {};
                        for (var i in e) {
                            var r = R(e[i], t);
                            u.arr(r) && 1 === (r = r.map((function (e) {
                                return R(e, t)
                            }))).length && (r = r[0]), n[i] = r
                        }
                        return n.duration = parseFloat(n.duration), n.delay = parseFloat(n.delay), n
                    }(i, t),
                    a = r.value,
                    s = u.arr(a) ? a[1] : a,
                    o = L(s),
                    l = O(t.target, e.name, o, t),
                    c = n ? n.to.original : l,
                    h = u.arr(a) ? a[0] : c,
                    d = L(h) || L(l),
                    p = o || d;
                return u.und(s) && (s = c), r.from = j(h, p), r.to = j(H(s, h), p), r.start = n ? n.end : 0, r.end = r.start + r.delay + r.duration + r.endDelay, r.easing = y(r.easing, r.duration), r.isPath = u.pth(a), r.isPathTargetInsideSVG = r.isPath && u.svg(t.target), r.isColor = u.col(r.from.original), r.isColor && (r.round = 1), n = r, r
            }))
        }
        var J = {
            css: function (e, t, n) {
                return e.style[t] = n
            },
            attribute: function (e, t, n) {
                return e.setAttribute(t, n)
            },
            object: function (e, t, n) {
                return e[t] = n
            },
            transform: function (e, t, n, i, r) {
                if (i.list.set(t, n), t === i.last || r) {
                    var a = "";
                    i.list.forEach((function (e, t) {
                        a += t + "(" + e + ") "
                    })), e.style.transform = a
                }
            }
        };
        function Z(e, t) {
            X(e).forEach((function (e) {
                for (var n in t) {
                    var i = R(t[n], e),
                        r = e.target,
                        a = L(i),
                        s = O(r, n, a, e),
                        o = H(U(i, a || L(s)), s),
                        l = F(r, n);
                    J[l](r, n, o, e.transforms, true)
                }
            }))
        }
        function K(e, t) {
            return b(_(e.map((function (e) {
                return t.map((function (t) {
                    return function (e, t) {
                        var n = F(e.target, t.name);
                        if (n) {
                            var i = Q(t, e),
                                r = i[i.length - 1];
                            return {
                                type: n,
                                property: t.name,
                                animatable: e,
                                tweens: i,
                                duration: r.end,
                                delay: i[0].delay,
                                endDelay: r.endDelay
                            }
                        }
                    }(e, t)
                }))
            }))), (function (e) {
                return !u.und(e)
            }))
        }
        function $(e, t) {
            var n = e.length,
                i = function (e) {
                    return e.timelineOffset ? e.timelineOffset : 0
                },
                r = {};
            return r.duration = n ? Math.max.apply(Math, e.map((function (e) {
                return i(e) + e.duration
            }))) : t.duration, r.delay = n ? Math.min.apply(Math, e.map((function (e) {
                return i(e) + e.delay
            }))) : t.delay, r.endDelay = n ? r.duration - Math.max.apply(Math, e.map((function (e) {
                return i(e) + e.duration - e.endDelay
            }))) : t.endDelay, r
        }
        var ee = 0;
        var te = [],
            ne = function () {
                var e;
                function t(n) {
                    for (var i = te.length, r = 0; r < i;) {
                        var a = te[r];
                        a.paused ? (te.splice(r, 1), i--) : (a.tick(n), r++)
                    }
                    e = r > 0 ? requestAnimationFrame(t) : void 0
                }
                return "undefined" != typeof document && document.addEventListener("visibilitychange", (function () {
                        re.suspendWhenDocumentHidden && (ie() ? e = cancelAnimationFrame(e) : (te.forEach((function (e) {
                            return e._onDocumentVisibility()
                        })), ne()))
                    })),
                    function () {
                        e || ie() && re.suspendWhenDocumentHidden || !(te.length > 0) || (e = requestAnimationFrame(t))
                    }
            }();
        function ie() {
            return !!document && document.hidden
        }
        function re(e) {
            void 0 === e && (e = {});
            var t, n = 0,
                a = 0,
                s = 0,
                l = 0,
                c = null;
            function u(e) {
                var t = window.Promise && new Promise((function (e) {
                    return c = e
                }));
                return e.finished = t, t
            }
            var h = function (e) {
                var t = T(i, e),
                    n = T(r, e),
                    a = q(n, e),
                    s = X(e.targets),
                    o = K(s, a),
                    l = $(o, n),
                    c = ee;
                return ee++, S(t, {
                    id: c,
                    children: [],
                    animatables: s,
                    animations: o,
                    duration: l.duration,
                    delay: l.delay,
                    endDelay: l.endDelay
                })
            }(e);
            u(h);
            function d() {
                var e = h.direction;
                "alternate" !== e && (h.direction = "normal" !== e ? "normal" : "reverse"), h.reversed = !h.reversed, t.forEach((function (e) {
                    return e.reversed = h.reversed
                }))
            }
            function p(e) {
                return h.reversed ? h.duration - e : e
            }
            function f() {
                n = 0, a = p(h.currentTime) * (1 / re.speed)
            }
            function m(e, t) {
                t && t.seek(e - t.timelineOffset)
            }
            function g(e) {
                for (var t = 0, n = h.animations, i = n.length; t < i;) {
                    var r = n[t],
                        a = r.animatable,
                        s = r.tweens,
                        l = s.length - 1,
                        c = s[l];
                    l && (c = b(s, (function (t) {
                        return e < t.end
                    }))[0] || c);
                    for (var u = o(e - c.start - c.delay, 0, c.duration) / c.duration, d = isNaN(u) ? 1 : c.easing(u), p = c.to.strings, f = c.round, m = [], g = c.to.numbers.length, v = void 0, y = 0; y < g; y++) {
                        var x = void 0,
                            _ = c.to.numbers[y],
                            w = c.from.numbers[y] || 0;
                        x = c.isPath ? V(c.value, d * _, c.isPathTargetInsideSVG) : w + d * (_ - w), f && (c.isColor && y > 2 || (x = Math.round(x * f) / f)), m.push(x)
                    }
                    var E = p.length;
                    if (E) {
                        v = p[0];
                        for (var M = 0; M < E; M++) {
                            p[M];
                            var T = p[M + 1],
                                S = m[M];
                            isNaN(S) || (v += T ? S + T : S + " ")
                        }
                    } else v = m[0];
                    J[r.type](a.target, r.property, v, a.transforms), r.currentValue = v, t++
                }
            }
            function v(e) {
                h[e] && !h.passThrough && h[e](h)
            }
            function y(e) {
                var i = h.duration,
                    r = h.delay,
                    f = i - h.endDelay,
                    y = p(e);
                h.progress = o(y / i * 100, 0, 100), h.reversePlayback = y < h.currentTime, t && function (e) {
                    if (h.reversePlayback)
                        for (var n = l; n--;) m(e, t[n]);
                    else
                        for (var i = 0; i < l; i++) m(e, t[i])
                }(y), !h.began && h.currentTime > 0 && (h.began = true, v("begin")), !h.loopBegan && h.currentTime > 0 && (h.loopBegan = true, v("loopBegin")), y <= r && 0 !== h.currentTime && g(0), (y >= f && h.currentTime !== i || !i) && g(i), y > r && y < f ? (h.changeBegan || (h.changeBegan = true, h.changeCompleted = false, v("changeBegin")), v("change"), g(y)) : h.changeBegan && (h.changeCompleted = true, h.changeBegan = false, v("changeComplete")), h.currentTime = o(y, 0, i), h.began && v("update"), e >= i && (a = 0, h.remaining && !0 !== h.remaining && h.remaining--, h.remaining ? (n = s, v("loopComplete"), h.loopBegan = false, "alternate" === h.direction && d()) : (h.paused = true, h.completed || (h.completed = true, v("loopComplete"), v("complete"), !h.passThrough && "Promise" in window && (c(), u(h)))))
            }
            return h.reset = function () {
                var e = h.direction;
                h.passThrough = false, h.currentTime = 0, h.progress = 0, h.paused = true, h.began = false, h.loopBegan = false, h.changeBegan = false, h.completed = false, h.changeCompleted = false, h.reversePlayback = false, h.reversed = "reverse" === e, h.remaining = h.loop, t = h.children;
                for (var n = l = t.length; n--;) h.children[n].reset();
                (h.reversed && !0 !== h.loop || "alternate" === e && 1 === h.loop) && h.remaining++, g(h.reversed ? h.duration : 0)
            }, h._onDocumentVisibility = f, h.set = function (e, t) {
                return Z(e, t), h
            }, h.tick = function (e) {
                s = e, n || (n = s), y((s + (a - n)) * re.speed)
            }, h.seek = function (e) {
                y(p(e))
            }, h.pause = function () {
                h.paused = true, f()
            }, h.play = function () {
                h.paused && (h.completed && h.reset(), h.paused = false, te.push(h), f(), ne())
            }, h.reverse = function () {
                d(), h.completed = !h.reversed, f()
            }, h.restart = function () {
                h.reset(), h.play()
            }, h.remove = function (e) {
                se(W(e), h)
            }, h.reset(), h.autoplay && h.play(), h
        }
        function ae(e, t) {
            for (var n = t.length; n--;) E(e, t[n].animatable.target) && t.splice(n, 1)
        }
        function se(e, t) {
            var n = t.animations,
                i = t.children;
            ae(e, n);
            for (var r = i.length; r--;) {
                var a = i[r],
                    s = a.animations;
                ae(e, s), s.length || a.children.length || i.splice(r, 1)
            }
            n.length || i.length || t.pause()
        }
        re.version = "3.2.1", re.speed = 1, re.suspendWhenDocumentHidden = true, re.running = te, re.remove = function (e) {
            for (var t = W(e), n = te.length; n--;) {
                se(t, te[n])
            }
        }, re.get = O, re.set = Z, re.convertPx = C, re.path = function (e, t) {
            var n = u.str(e) ? x(e)[0] : e,
                i = t || 100;
            return function (e) {
                return {
                    property: e,
                    el: n,
                    svg: G(n),
                    totalLength: k(n) * (i / 100)
                }
            }
        }, re.setDashoffset = function (e) {
            var t = k(e);
            return e.setAttribute("stroke-dasharray", t), t
        }, re.stagger = function (e, t) {
            void 0 === t && (t = {});
            var n = t.direction || "normal",
                i = t.easing ? y(t.easing) : null,
                r = t.grid,
                a = t.axis,
                s = t.from || 0,
                o = "first" === s,
                l = "center" === s,
                c = "last" === s,
                h = u.arr(e),
                d = h ? parseFloat(e[0]) : parseFloat(e),
                p = h ? parseFloat(e[1]) : 0,
                f = L(h ? e[1] : e) || 0,
                m = t.start || 0 + (h ? d : 0),
                g = [],
                v = 0;
            return function (e, t, u) {
                if (o && (s = 0), l && (s = (u - 1) / 2), c && (s = u - 1), !g.length) {
                    for (var y = 0; y < u; y++) {
                        if (r) {
                            var x = l ? (r[0] - 1) / 2 : s % r[0],
                                b = l ? (r[1] - 1) / 2 : Math.floor(s / r[0]),
                                _ = x - y % r[0],
                                w = b - Math.floor(y / r[0]),
                                E = Math.sqrt(_ * _ + w * w);
                            "x" === a && (E = -_), "y" === a && (E = -w), g.push(E)
                        } else g.push(Math.abs(s - y));
                        v = Math.max.apply(Math, g)
                    }
                    i && (g = g.map((function (e) {
                        return i(e / v) * v
                    }))), "reverse" === n && (g = g.map((function (e) {
                        return a ? e < 0 ? -1 * e : -e : Math.abs(v - e)
                    })))
                }
                return m + (h ? (p - d) / v : d) * (Math.round(100 * g[t]) / 100) + f
            }
        }, re.timeline = function (e) {
            void 0 === e && (e = {});
            var t = re(e);
            return t.duration = 0, t.add = function (n, i) {
                var a = te.indexOf(t),
                    s = t.children;
                function o(e) {
                    e.passThrough = true
                }
                a > -1 && te.splice(a, 1);
                for (var l = 0; l < s.length; l++) o(s[l]);
                var c = S(n, T(r, e));
                c.targets = c.targets || e.targets;
                var h = t.duration;
                c.autoplay = false, c.direction = t.direction, c.timelineOffset = u.und(i) ? h : H(i, h), o(t), t.seek(c.timelineOffset);
                var d = re(c);
                o(d), s.push(d);
                var p = $(s, e);
                return t.delay = p.delay, t.endDelay = p.endDelay, t.duration = p.duration, t.seek(0), t.reset(), t.autoplay && t.play(), t
            }, t
        }, re.easing = y, re.penner = v, re.random = function (e, t) {
            return Math.floor(Math.random() * (t - e + 1)) + e
        }, t.exports = re
    }, {}],
    3: [function (e, t, n) {
        t.exports = function (e, t) {
            return "number" == typeof e ? e : "number" == typeof t ? t : 0
        }
    }, {}],
    4: [function (e, t, n) {
        "use strict";
        n.byteLength = function (e) {
            var t = c(e),
                n = t[0],
                i = t[1];
            return 3 * (n + i) / 4 - i
        }, n.toByteArray = function (e) {
            var t, n, i = c(e),
                s = i[0],
                o = i[1],
                l = new a(function (e, t, n) {
                    return 3 * (t + n) / 4 - n
                }(0, s, o)),
                u = 0,
                h = o > 0 ? s - 4 : s;
            for (n = 0; n < h; n += 4) t = r[e.charCodeAt(n)] << 18 | r[e.charCodeAt(n + 1)] << 12 | r[e.charCodeAt(n + 2)] << 6 | r[e.charCodeAt(n + 3)], l[u++] = t >> 16 & 255, l[u++] = t >> 8 & 255, l[u++] = 255 & t;
            2 === o && (t = r[e.charCodeAt(n)] << 2 | r[e.charCodeAt(n + 1)] >> 4, l[u++] = 255 & t);
            1 === o && (t = r[e.charCodeAt(n)] << 10 | r[e.charCodeAt(n + 1)] << 4 | r[e.charCodeAt(n + 2)] >> 2, l[u++] = t >> 8 & 255, l[u++] = 255 & t);
            return l
        }, n.fromByteArray = function (e) {
            for (var t, n = e.length, r = n % 3, a = [], s = 16383, o = 0, l = n - r; o < l; o += s) a.push(u(e, o, o + s > l ? l : o + s));
            1 === r ? (t = e[n - 1], a.push(i[t >> 2] + i[t << 4 & 63] + "==")) : 2 === r && (t = (e[n - 2] << 8) + e[n - 1], a.push(i[t >> 10] + i[t >> 4 & 63] + i[t << 2 & 63] + "="));
            return a.join("")
        };
        for (var i = [], r = [], a = "undefined" != typeof Uint8Array ? Uint8Array : Array, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", o = 0, l = s.length; o < l; ++o) i[o] = s[o], r[s.charCodeAt(o)] = o;
        function c(e) {
            var t = e.length;
            if (t % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
            var n = e.indexOf("=");
            return -1 === n && (n = t), [n, n === t ? 0 : 4 - n % 4]
        }
        function u(e, t, n) {
            for (var r, a, s = [], o = t; o < n; o += 3) r = (e[o] << 16 & 16711680) + (e[o + 1] << 8 & 65280) + (255 & e[o + 2]), s.push(i[(a = r) >> 18 & 63] + i[a >> 12 & 63] + i[a >> 6 & 63] + i[63 & a]);
            return s.join("")
        }
        r["-".charCodeAt(0)] = 62, r["_".charCodeAt(0)] = 63
    }, {}],
    5: [function (e, t, n) {
        "use strict";
        var i = [],
            r = function (e, t) {
                var n = document.head || document.getElementsByTagName("head")[0],
                    r = i[i.length - 1];
                if ((t = t || {}).insertAt = t.insertAt || "bottom", "top" === t.insertAt) r ? r.nextSibling ? n.insertBefore(e, r.nextSibling) : n.appendChild(e) : n.insertBefore(e, n.firstChild), i.push(e);
                else {
                    if ("bottom" !== t.insertAt) throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
                    n.appendChild(e)
                }
            };
        t.exports = {
            createLink: function (e, t) {
                var n = document.head || document.getElementsByTagName("head")[0],
                    i = document.createElement("link");
                for (var r in i.href = e, i.rel = "stylesheet", t)
                    if (t.hasOwnProperty(r)) {
                        var a = t[r];
                        i.setAttribute("data-" + r, a)
                    } n.appendChild(i)
            },
            createStyle: function (e, t, n) {
                n = n || {};
                var i = document.createElement("style");
                for (var a in i.type = "text/css", t)
                    if (t.hasOwnProperty(a)) {
                        var s = t[a];
                        i.setAttribute("data-" + a, s)
                    } i.sheet ? (i.innerHTML = e, i.sheet.cssText = e, r(i, {
                    insertAt: n.insertAt
                })) : i.styleSheet ? (r(i, {
                    insertAt: n.insertAt
                }), i.styleSheet.cssText = e) : (i.appendChild(document.createTextNode(e)), r(i, {
                    insertAt: n.insertAt
                }))
            }
        }
    }, {}],
    6: [function (e, t, n) {
        var i = e("buffer").Buffer;
        t.exports = function (e, t) {
            if (i.isBuffer(e) && i.isBuffer(t)) {
                if ("function" == typeof e.equals) return e.equals(t);
                if (e.length !== t.length) return false;
                for (var n = 0; n < e.length; n++)
                    if (e[n] !== t[n]) return false;
                return true
            }
        }
    }, {
        buffer: 7
    }],
    7: [function (e, t, n) {
        (function (t) {
            (function () {
                "use strict";
                var t = e("base64-js"),
                    i = e("ieee754");
                n.Buffer = s, n.SlowBuffer = function (e) {
                    +e != e && (e = 0);
                    return s.alloc(+e)
                }, n.INSPECT_MAX_BYTES = 50;
                var r = 2147483647;
                function a(e) {
                    if (e > r) throw new RangeError('The value "' + e + '" is invalid for option "size"');
                    var t = new Uint8Array(e);
                    return t.__proto__ = s.prototype, t
                }
                function s(e, t, n) {
                    if ("number" == typeof e) {
                        if ("string" == typeof t) throw new TypeError('The "string" argument must be of type string. Received type number');
                        return c(e)
                    }
                    return o(e, t, n)
                }
                function o(e, t, n) {
                    if ("string" == typeof e) return function (e, t) {
                        "string" == typeof t && "" !== t || (t = "utf8");
                        if (!s.isEncoding(t)) throw new TypeError("Unknown encoding: " + t);
                        var n = 0 | d(e, t),
                            i = a(n),
                            r = i.write(e, t);
                        r !== n && (i = i.slice(0, r));
                        return i
                    }(e, t);
                    if (ArrayBuffer.isView(e)) return u(e);
                    if (null == e) throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
                    if (z(e, ArrayBuffer) || e && z(e.buffer, ArrayBuffer)) return function (e, t, n) {
                        if (t < 0 || e.byteLength < t) throw new RangeError('"offset" is outside of buffer bounds');
                        if (e.byteLength < t + (n || 0)) throw new RangeError('"length" is outside of buffer bounds');
                        var i;
                        i = void 0 === t && void 0 === n ? new Uint8Array(e) : void 0 === n ? new Uint8Array(e, t) : new Uint8Array(e, t, n);
                        return i.__proto__ = s.prototype, i
                    }(e, t, n);
                    if ("number" == typeof e) throw new TypeError('The "value" argument must not be of type number. Received type number');
                    var i = e.valueOf && e.valueOf();
                    if (null != i && i !== e) return s.from(i, t, n);
                    var r = function (e) {
                        if (s.isBuffer(e)) {
                            var t = 0 | h(e.length),
                                n = a(t);
                            return 0 === n.length || e.copy(n, 0, 0, t), n
                        }
                        if (void 0 !== e.length) return "number" != typeof e.length || k(e.length) ? a(0) : u(e);
                        if ("Buffer" === e.type && Array.isArray(e.data)) return u(e.data)
                    }(e);
                    if (r) return r;
                    if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e[Symbol.toPrimitive]) return s.from(e[Symbol.toPrimitive]("string"), t, n);
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e)
                }
                function l(e) {
                    if ("number" != typeof e) throw new TypeError('"size" argument must be of type number');
                    if (e < 0) throw new RangeError('The value "' + e + '" is invalid for option "size"')
                }
                function c(e) {
                    return l(e), a(e < 0 ? 0 : 0 | h(e))
                }
                function u(e) {
                    for (var t = e.length < 0 ? 0 : 0 | h(e.length), n = a(t), i = 0; i < t; i += 1) n[i] = 255 & e[i];
                    return n
                }
                function h(e) {
                    if (e >= r) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + r.toString(16) + " bytes");
                    return 0 | e
                }
                function d(e, t) {
                    if (s.isBuffer(e)) return e.length;
                    if (ArrayBuffer.isView(e) || z(e, ArrayBuffer)) return e.byteLength;
                    if ("string" != typeof e) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);
                    var n = e.length,
                        i = arguments.length > 2 && !0 === arguments[2];
                    if (!i && 0 === n) return 0;
                    for (var r = false;;) switch (t) {
                    case "ascii":
                    case "latin1":
                    case "binary":
                        return n;
                    case "utf8":
                    case "utf-8":
                        return H(e).length;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return 2 * n;
                    case "hex":
                        return n >>> 1;
                    case "base64":
                        return U(e).length;
                    default:
                        if (r) return i ? -1 : H(e).length;
                        t = ("" + t).toLowerCase(), r = true
                    }
                }
                function p(e, t, n) {
                    var i = false;
                    if ((void 0 === t || t < 0) && (t = 0), t > this.length) return "";
                    if ((void 0 === n || n > this.length) && (n = this.length), n <= 0) return "";
                    if ((n >>>= 0) <= (t >>>= 0)) return "";
                    for (e || (e = "utf8");;) switch (e) {
                    case "hex":
                        return L(this, t, n);
                    case "utf8":
                    case "utf-8":
                        return M(this, t, n);
                    case "ascii":
                        return S(this, t, n);
                    case "latin1":
                    case "binary":
                        return A(this, t, n);
                    case "base64":
                        return E(this, t, n);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return R(this, t, n);
                    default:
                        if (i) throw new TypeError("Unknown encoding: " + e);
                        e = (e + "").toLowerCase(), i = true
                    }
                }
                function f(e, t, n) {
                    var i = e[t];
                    e[t] = e[n], e[n] = i
                }
                function m(e, t, n, i, r) {
                    if (0 === e.length) return -1;
                    if ("string" == typeof n ? (i = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), k(n = +n) && (n = r ? 0 : e.length - 1), n < 0 && (n = e.length + n), n >= e.length) {
                        if (r) return -1;
                        n = e.length - 1
                    } else if (n < 0) {
                        if (!r) return -1;
                        n = 0
                    }
                    if ("string" == typeof t && (t = s.from(t, i)), s.isBuffer(t)) return 0 === t.length ? -1 : g(e, t, n, i, r);
                    if ("number" == typeof t) return t &= 255, "function" == typeof Uint8Array.prototype.indexOf ? r ? Uint8Array.prototype.indexOf.call(e, t, n) : Uint8Array.prototype.lastIndexOf.call(e, t, n) : g(e, [t], n, i, r);
                    throw new TypeError("val must be string, number or Buffer")
                }
                function g(e, t, n, i, r) {
                    var a, s = 1,
                        o = e.length,
                        l = t.length;
                    if (void 0 !== i && ("ucs2" === (i = String(i).toLowerCase()) || "ucs-2" === i || "utf16le" === i || "utf-16le" === i)) {
                        if (e.length < 2 || t.length < 2) return -1;
                        s = 2, o /= 2, l /= 2, n /= 2
                    }
                    function c(e, t) {
                        return 1 === s ? e[t] : e.readUInt16BE(t * s)
                    }
                    if (r) {
                        var u = -1;
                        for (a = n; a < o; a++)
                            if (c(e, a) === c(t, -1 === u ? 0 : a - u)) {
                                if (-1 === u && (u = a), a - u + 1 === l) return u * s
                            } else -1 !== u && (a -= a - u), u = -1
                    } else
                        for (n + l > o && (n = o - l), a = n; a >= 0; a--) {
                            for (var h = true, d = 0; d < l; d++)
                                if (c(e, a + d) !== c(t, d)) {
                                    h = false;
                                    break
                                } if (h) return a
                        }
                    return -1
                }
                function v(e, t, n, i) {
                    n = Number(n) || 0;
                    var r = e.length - n;
                    i ? (i = Number(i)) > r && (i = r) : i = r;
                    var a = t.length;
                    i > a / 2 && (i = a / 2);
                    for (var s = 0; s < i; ++s) {
                        var o = parseInt(t.substr(2 * s, 2), 16);
                        if (k(o)) return s;
                        e[n + s] = o
                    }
                    return s
                }
                function y(e, t, n, i) {
                    return B(H(t, e.length - n), e, n, i)
                }
                function x(e, t, n, i) {
                    return B(function (e) {
                        for (var t = [], n = 0; n < e.length; ++n) t.push(255 & e.charCodeAt(n));
                        return t
                    }(t), e, n, i)
                }
                function b(e, t, n, i) {
                    return x(e, t, n, i)
                }
                function _(e, t, n, i) {
                    return B(U(t), e, n, i)
                }
                function w(e, t, n, i) {
                    return B(function (e, t) {
                        for (var n, i, r, a = [], s = 0; s < e.length && !((t -= 2) < 0); ++s) i = (n = e.charCodeAt(s)) >> 8, r = n % 256, a.push(r), a.push(i);
                        return a
                    }(t, e.length - n), e, n, i)
                }
                function E(e, n, i) {
                    return 0 === n && i === e.length ? t.fromByteArray(e) : t.fromByteArray(e.slice(n, i))
                }
                function M(e, t, n) {
                    n = Math.min(e.length, n);
                    for (var i = [], r = t; r < n;) {
                        var a, s, o, l, c = e[r],
                            u = null,
                            h = c > 239 ? 4 : c > 223 ? 3 : c > 191 ? 2 : 1;
                        if (r + h <= n) switch (h) {
                        case 1:
                            c < 128 && (u = c);
                            break;
                        case 2:
                            128 == (192 & (a = e[r + 1])) && (l = (31 & c) << 6 | 63 & a) > 127 && (u = l);
                            break;
                        case 3:
                            a = e[r + 1], s = e[r + 2], 128 == (192 & a) && 128 == (192 & s) && (l = (15 & c) << 12 | (63 & a) << 6 | 63 & s) > 2047 && (l < 55296 || l > 57343) && (u = l);
                            break;
                        case 4:
                            a = e[r + 1], s = e[r + 2], o = e[r + 3], 128 == (192 & a) && 128 == (192 & s) && 128 == (192 & o) && (l = (15 & c) << 18 | (63 & a) << 12 | (63 & s) << 6 | 63 & o) > 65535 && l < 1114112 && (u = l)
                        }
                        null === u ? (u = 65533, h = 1) : u > 65535 && (u -= 65536, i.push(u >>> 10 & 1023 | 55296), u = 56320 | 1023 & u), i.push(u), r += h
                    }
                    return function (e) {
                        var t = e.length;
                        if (t <= T) return String.fromCharCode.apply(String, e);
                        var n = "",
                            i = 0;
                        for (; i < t;) n += String.fromCharCode.apply(String, e.slice(i, i += T));
                        return n
                    }(i)
                }
                n.kMaxLength = r, s.TYPED_ARRAY_SUPPORT = function () {
                    try {
                        var e = new Uint8Array(1);
                        return e.__proto__ = {
                            __proto__: Uint8Array.prototype,
                            foo: function () {
                                return 42
                            }
                        }, 42 === e.foo()
                    } catch (e) {
                        return false
                    }
                }(), s.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(s.prototype, "parent", {
                    enumerable: true,
                    get: function () {
                        if (s.isBuffer(this)) return this.buffer
                    }
                }), Object.defineProperty(s.prototype, "offset", {
                    enumerable: true,
                    get: function () {
                        if (s.isBuffer(this)) return this.byteOffset
                    }
                }), "undefined" != typeof Symbol && null != Symbol.species && s[Symbol.species] === s && Object.defineProperty(s, Symbol.species, {
                    value: null,
                    configurable: true,
                    enumerable: false,
                    writable: false
                }), s.poolSize = 8192, s.from = function (e, t, n) {
                    return o(e, t, n)
                }, s.prototype.__proto__ = Uint8Array.prototype, s.__proto__ = Uint8Array, s.alloc = function (e, t, n) {
                    return function (e, t, n) {
                        return l(e), e <= 0 ? a(e) : void 0 !== t ? "string" == typeof n ? a(e).fill(t, n) : a(e).fill(t) : a(e)
                    }(e, t, n)
                }, s.allocUnsafe = function (e) {
                    return c(e)
                }, s.allocUnsafeSlow = function (e) {
                    return c(e)
                }, s.isBuffer = function (e) {
                    return null != e && !0 === e._isBuffer && e !== s.prototype
                }, s.compare = function (e, t) {
                    if (z(e, Uint8Array) && (e = s.from(e, e.offset, e.byteLength)), z(t, Uint8Array) && (t = s.from(t, t.offset, t.byteLength)), !s.isBuffer(e) || !s.isBuffer(t)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                    if (e === t) return 0;
                    for (var n = e.length, i = t.length, r = 0, a = Math.min(n, i); r < a; ++r)
                        if (e[r] !== t[r]) {
                            n = e[r], i = t[r];
                            break
                        } return n < i ? -1 : i < n ? 1 : 0
                }, s.isEncoding = function (e) {
                    switch (String(e).toLowerCase()) {
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return true;
                    default:
                        return false
                    }
                }, s.concat = function (e, t) {
                    if (!Array.isArray(e)) throw new TypeError('"list" argument must be an Array of Buffers');
                    if (0 === e.length) return s.alloc(0);
                    var n;
                    if (void 0 === t)
                        for (t = 0, n = 0; n < e.length; ++n) t += e[n].length;
                    var i = s.allocUnsafe(t),
                        r = 0;
                    for (n = 0; n < e.length; ++n) {
                        var a = e[n];
                        if (z(a, Uint8Array) && (a = s.from(a)), !s.isBuffer(a)) throw new TypeError('"list" argument must be an Array of Buffers');
                        a.copy(i, r), r += a.length
                    }
                    return i
                }, s.byteLength = d, s.prototype._isBuffer = true, s.prototype.swap16 = function () {
                    var e = this.length;
                    if (e % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
                    for (var t = 0; t < e; t += 2) f(this, t, t + 1);
                    return this
                }, s.prototype.swap32 = function () {
                    var e = this.length;
                    if (e % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
                    for (var t = 0; t < e; t += 4) f(this, t, t + 3), f(this, t + 1, t + 2);
                    return this
                }, s.prototype.swap64 = function () {
                    var e = this.length;
                    if (e % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
                    for (var t = 0; t < e; t += 8) f(this, t, t + 7), f(this, t + 1, t + 6), f(this, t + 2, t + 5), f(this, t + 3, t + 4);
                    return this
                }, s.prototype.toString = function () {
                    var e = this.length;
                    return 0 === e ? "" : 0 === arguments.length ? M(this, 0, e) : p.apply(this, arguments)
                }, s.prototype.toLocaleString = s.prototype.toString, s.prototype.equals = function (e) {
                    if (!s.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
                    return this === e || 0 === s.compare(this, e)
                }, s.prototype.inspect = function () {
                    var e = "",
                        t = n.INSPECT_MAX_BYTES;
                    return e = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (e += " ... "), "<Buffer " + e + ">"
                }, s.prototype.compare = function (e, t, n, i, r) {
                    if (z(e, Uint8Array) && (e = s.from(e, e.offset, e.byteLength)), !s.isBuffer(e)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
                    if (void 0 === t && (t = 0), void 0 === n && (n = e ? e.length : 0), void 0 === i && (i = 0), void 0 === r && (r = this.length), t < 0 || n > e.length || i < 0 || r > this.length) throw new RangeError("out of range index");
                    if (i >= r && t >= n) return 0;
                    if (i >= r) return -1;
                    if (t >= n) return 1;
                    if (this === e) return 0;
                    for (var a = (r >>>= 0) - (i >>>= 0), o = (n >>>= 0) - (t >>>= 0), l = Math.min(a, o), c = this.slice(i, r), u = e.slice(t, n), h = 0; h < l; ++h)
                        if (c[h] !== u[h]) {
                            a = c[h], o = u[h];
                            break
                        } return a < o ? -1 : o < a ? 1 : 0
                }, s.prototype.includes = function (e, t, n) {
                    return -1 !== this.indexOf(e, t, n)
                }, s.prototype.indexOf = function (e, t, n) {
                    return m(this, e, t, n, true)
                }, s.prototype.lastIndexOf = function (e, t, n) {
                    return m(this, e, t, n, false)
                }, s.prototype.write = function (e, t, n, i) {
                    if (void 0 === t) i = "utf8", n = this.length, t = 0;
                    else if (void 0 === n && "string" == typeof t) i = t, n = this.length, t = 0;
                    else {
                        if (!isFinite(t)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                        t >>>= 0, isFinite(n) ? (n >>>= 0, void 0 === i && (i = "utf8")) : (i = n, n = void 0)
                    }
                    var r = this.length - t;
                    if ((void 0 === n || n > r) && (n = r), e.length > 0 && (n < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
                    i || (i = "utf8");
                    for (var a = false;;) switch (i) {
                    case "hex":
                        return v(this, e, t, n);
                    case "utf8":
                    case "utf-8":
                        return y(this, e, t, n);
                    case "ascii":
                        return x(this, e, t, n);
                    case "latin1":
                    case "binary":
                        return b(this, e, t, n);
                    case "base64":
                        return _(this, e, t, n);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return w(this, e, t, n);
                    default:
                        if (a) throw new TypeError("Unknown encoding: " + i);
                        i = ("" + i).toLowerCase(), a = true
                    }
                }, s.prototype.toJSON = function () {
                    return {
                        type: "Buffer",
                        data: Array.prototype.slice.call(this._arr || this, 0)
                    }
                };
                var T = 4096;
                function S(e, t, n) {
                    var i = "";
                    n = Math.min(e.length, n);
                    for (var r = t; r < n; ++r) i += String.fromCharCode(127 & e[r]);
                    return i
                }
                function A(e, t, n) {
                    var i = "";
                    n = Math.min(e.length, n);
                    for (var r = t; r < n; ++r) i += String.fromCharCode(e[r]);
                    return i
                }
                function L(e, t, n) {
                    var i = e.length;
                    (!t || t < 0) && (t = 0), (!n || n < 0 || n > i) && (n = i);
                    for (var r = "", a = t; a < n; ++a) r += O(e[a]);
                    return r
                }
                function R(e, t, n) {
                    for (var i = e.slice(t, n), r = "", a = 0; a < i.length; a += 2) r += String.fromCharCode(i[a] + 256 * i[a + 1]);
                    return r
                }
                function P(e, t, n) {
                    if (e % 1 != 0 || e < 0) throw new RangeError("offset is not uint");
                    if (e + t > n) throw new RangeError("Trying to access beyond buffer length")
                }
                function C(e, t, n, i, r, a) {
                    if (!s.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
                    if (t > r || t < a) throw new RangeError('"value" argument is out of bounds');
                    if (n + i > e.length) throw new RangeError("Index out of range")
                }
                function I(e, t, n, i, r, a) {
                    if (n + i > e.length) throw new RangeError("Index out of range");
                    if (n < 0) throw new RangeError("Index out of range")
                }
                function F(e, t, n, r, a) {
                    return t = +t, n >>>= 0, a || I(e, 0, n, 4), i.write(e, t, n, r, 23, 4), n + 4
                }
                function D(e, t, n, r, a) {
                    return t = +t, n >>>= 0, a || I(e, 0, n, 8), i.write(e, t, n, r, 52, 8), n + 8
                }
                s.prototype.slice = function (e, t) {
                    var n = this.length;
                    (e = ~~e) < 0 ? (e += n) < 0 && (e = 0) : e > n && (e = n), (t = void 0 === t ? n : ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n), t < e && (t = e);
                    var i = this.subarray(e, t);
                    return i.__proto__ = s.prototype, i
                }, s.prototype.readUIntLE = function (e, t, n) {
                    e >>>= 0, t >>>= 0, n || P(e, t, this.length);
                    for (var i = this[e], r = 1, a = 0; ++a < t && (r *= 256);) i += this[e + a] * r;
                    return i
                }, s.prototype.readUIntBE = function (e, t, n) {
                    e >>>= 0, t >>>= 0, n || P(e, t, this.length);
                    for (var i = this[e + --t], r = 1; t > 0 && (r *= 256);) i += this[e + --t] * r;
                    return i
                }, s.prototype.readUInt8 = function (e, t) {
                    return e >>>= 0, t || P(e, 1, this.length), this[e]
                }, s.prototype.readUInt16LE = function (e, t) {
                    return e >>>= 0, t || P(e, 2, this.length), this[e] | this[e + 1] << 8
                }, s.prototype.readUInt16BE = function (e, t) {
                    return e >>>= 0, t || P(e, 2, this.length), this[e] << 8 | this[e + 1]
                }, s.prototype.readUInt32LE = function (e, t) {
                    return e >>>= 0, t || P(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3]
                }, s.prototype.readUInt32BE = function (e, t) {
                    return e >>>= 0, t || P(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3])
                }, s.prototype.readIntLE = function (e, t, n) {
                    e >>>= 0, t >>>= 0, n || P(e, t, this.length);
                    for (var i = this[e], r = 1, a = 0; ++a < t && (r *= 256);) i += this[e + a] * r;
                    return i >= (r *= 128) && (i -= Math.pow(2, 8 * t)), i
                }, s.prototype.readIntBE = function (e, t, n) {
                    e >>>= 0, t >>>= 0, n || P(e, t, this.length);
                    for (var i = t, r = 1, a = this[e + --i]; i > 0 && (r *= 256);) a += this[e + --i] * r;
                    return a >= (r *= 128) && (a -= Math.pow(2, 8 * t)), a
                }, s.prototype.readInt8 = function (e, t) {
                    return e >>>= 0, t || P(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e]
                }, s.prototype.readInt16LE = function (e, t) {
                    e >>>= 0, t || P(e, 2, this.length);
                    var n = this[e] | this[e + 1] << 8;
                    return 32768 & n ? 4294901760 | n : n
                }, s.prototype.readInt16BE = function (e, t) {
                    e >>>= 0, t || P(e, 2, this.length);
                    var n = this[e + 1] | this[e] << 8;
                    return 32768 & n ? 4294901760 | n : n
                }, s.prototype.readInt32LE = function (e, t) {
                    return e >>>= 0, t || P(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24
                }, s.prototype.readInt32BE = function (e, t) {
                    return e >>>= 0, t || P(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]
                }, s.prototype.readFloatLE = function (e, t) {
                    return e >>>= 0, t || P(e, 4, this.length), i.read(this, e, true, 23, 4)
                }, s.prototype.readFloatBE = function (e, t) {
                    return e >>>= 0, t || P(e, 4, this.length), i.read(this, e, false, 23, 4)
                }, s.prototype.readDoubleLE = function (e, t) {
                    return e >>>= 0, t || P(e, 8, this.length), i.read(this, e, true, 52, 8)
                }, s.prototype.readDoubleBE = function (e, t) {
                    return e >>>= 0, t || P(e, 8, this.length), i.read(this, e, false, 52, 8)
                }, s.prototype.writeUIntLE = function (e, t, n, i) {
                    (e = +e, t >>>= 0, n >>>= 0, i) || C(this, e, t, n, Math.pow(2, 8 * n) - 1, 0);
                    var r = 1,
                        a = 0;
                    for (this[t] = 255 & e; ++a < n && (r *= 256);) this[t + a] = e / r & 255;
                    return t + n
                }, s.prototype.writeUIntBE = function (e, t, n, i) {
                    (e = +e, t >>>= 0, n >>>= 0, i) || C(this, e, t, n, Math.pow(2, 8 * n) - 1, 0);
                    var r = n - 1,
                        a = 1;
                    for (this[t + r] = 255 & e; --r >= 0 && (a *= 256);) this[t + r] = e / a & 255;
                    return t + n
                }, s.prototype.writeUInt8 = function (e, t, n) {
                    return e = +e, t >>>= 0, n || C(this, e, t, 1, 255, 0), this[t] = 255 & e, t + 1
                }, s.prototype.writeUInt16LE = function (e, t, n) {
                    return e = +e, t >>>= 0, n || C(this, e, t, 2, 65535, 0), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2
                }, s.prototype.writeUInt16BE = function (e, t, n) {
                    return e = +e, t >>>= 0, n || C(this, e, t, 2, 65535, 0), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2
                }, s.prototype.writeUInt32LE = function (e, t, n) {
                    return e = +e, t >>>= 0, n || C(this, e, t, 4, 4294967295, 0), this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e, t + 4
                }, s.prototype.writeUInt32BE = function (e, t, n) {
                    return e = +e, t >>>= 0, n || C(this, e, t, 4, 4294967295, 0), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4
                }, s.prototype.writeIntLE = function (e, t, n, i) {
                    if (e = +e, t >>>= 0, !i) {
                        var r = Math.pow(2, 8 * n - 1);
                        C(this, e, t, n, r - 1, -r)
                    }
                    var a = 0,
                        s = 1,
                        o = 0;
                    for (this[t] = 255 & e; ++a < n && (s *= 256);) e < 0 && 0 === o && 0 !== this[t + a - 1] && (o = 1), this[t + a] = (e / s >> 0) - o & 255;
                    return t + n
                }, s.prototype.writeIntBE = function (e, t, n, i) {
                    if (e = +e, t >>>= 0, !i) {
                        var r = Math.pow(2, 8 * n - 1);
                        C(this, e, t, n, r - 1, -r)
                    }
                    var a = n - 1,
                        s = 1,
                        o = 0;
                    for (this[t + a] = 255 & e; --a >= 0 && (s *= 256);) e < 0 && 0 === o && 0 !== this[t + a + 1] && (o = 1), this[t + a] = (e / s >> 0) - o & 255;
                    return t + n
                }, s.prototype.writeInt8 = function (e, t, n) {
                    return e = +e, t >>>= 0, n || C(this, e, t, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[t] = 255 & e, t + 1
                }, s.prototype.writeInt16LE = function (e, t, n) {
                    return e = +e, t >>>= 0, n || C(this, e, t, 2, 32767, -32768), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2
                }, s.prototype.writeInt16BE = function (e, t, n) {
                    return e = +e, t >>>= 0, n || C(this, e, t, 2, 32767, -32768), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2
                }, s.prototype.writeInt32LE = function (e, t, n) {
                    return e = +e, t >>>= 0, n || C(this, e, t, 4, 2147483647, -2147483648), this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24, t + 4
                }, s.prototype.writeInt32BE = function (e, t, n) {
                    return e = +e, t >>>= 0, n || C(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4
                }, s.prototype.writeFloatLE = function (e, t, n) {
                    return F(this, e, t, true, n)
                }, s.prototype.writeFloatBE = function (e, t, n) {
                    return F(this, e, t, false, n)
                }, s.prototype.writeDoubleLE = function (e, t, n) {
                    return D(this, e, t, true, n)
                }, s.prototype.writeDoubleBE = function (e, t, n) {
                    return D(this, e, t, false, n)
                }, s.prototype.copy = function (e, t, n, i) {
                    if (!s.isBuffer(e)) throw new TypeError("argument should be a Buffer");
                    if (n || (n = 0), i || 0 === i || (i = this.length), t >= e.length && (t = e.length), t || (t = 0), i > 0 && i < n && (i = n), i === n) return 0;
                    if (0 === e.length || 0 === this.length) return 0;
                    if (t < 0) throw new RangeError("targetStart out of bounds");
                    if (n < 0 || n >= this.length) throw new RangeError("Index out of range");
                    if (i < 0) throw new RangeError("sourceEnd out of bounds");
                    i > this.length && (i = this.length), e.length - t < i - n && (i = e.length - t + n);
                    var r = i - n;
                    if (this === e && "function" == typeof Uint8Array.prototype.copyWithin) this.copyWithin(t, n, i);
                    else if (this === e && n < t && t < i)
                        for (var a = r - 1; a >= 0; --a) e[a + t] = this[a + n];
                    else Uint8Array.prototype.set.call(e, this.subarray(n, i), t);
                    return r
                }, s.prototype.fill = function (e, t, n, i) {
                    if ("string" == typeof e) {
                        if ("string" == typeof t ? (i = t, t = 0, n = this.length) : "string" == typeof n && (i = n, n = this.length), void 0 !== i && "string" != typeof i) throw new TypeError("encoding must be a string");
                        if ("string" == typeof i && !s.isEncoding(i)) throw new TypeError("Unknown encoding: " + i);
                        if (1 === e.length) {
                            var r = e.charCodeAt(0);
                            ("utf8" === i && r < 128 || "latin1" === i) && (e = r)
                        }
                    } else "number" == typeof e && (e &= 255);
                    if (t < 0 || this.length < t || this.length < n) throw new RangeError("Out of range index");
                    if (n <= t) return this;
                    var a;
                    if (t >>>= 0, n = void 0 === n ? this.length : n >>> 0, e || (e = 0), "number" == typeof e)
                        for (a = t; a < n; ++a) this[a] = e;
                    else {
                        var o = s.isBuffer(e) ? e : s.from(e, i),
                            l = o.length;
                        if (0 === l) throw new TypeError('The value "' + e + '" is invalid for argument "value"');
                        for (a = 0; a < n - t; ++a) this[a + t] = o[a % l]
                    }
                    return this
                };
                var N = /[^+/0-9A-Za-z-_]/g;
                function O(e) {
                    return e < 16 ? "0" + e.toString(16) : e.toString(16)
                }
                function H(e, t) {
                    var n;
                    t = t || 1 / 0;
                    for (var i = e.length, r = null, a = [], s = 0; s < i; ++s) {
                        if ((n = e.charCodeAt(s)) > 55295 && n < 57344) {
                            if (!r) {
                                if (n > 56319) {
                                    (t -= 3) > -1 && a.push(239, 191, 189);
                                    continue
                                }
                                if (s + 1 === i) {
                                    (t -= 3) > -1 && a.push(239, 191, 189);
                                    continue
                                }
                                r = n;
                                continue
                            }
                            if (n < 56320) {
                                (t -= 3) > -1 && a.push(239, 191, 189), r = n;
                                continue
                            }
                            n = 65536 + (r - 55296 << 10 | n - 56320)
                        } else r && (t -= 3) > -1 && a.push(239, 191, 189);
                        if (r = null, n < 128) {
                            if ((t -= 1) < 0) break;
                            a.push(n)
                        } else if (n < 2048) {
                            if ((t -= 2) < 0) break;
                            a.push(n >> 6 | 192, 63 & n | 128)
                        } else if (n < 65536) {
                            if ((t -= 3) < 0) break;
                            a.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128)
                        } else {
                            if (!(n < 1114112)) throw new Error("Invalid code point");
                            if ((t -= 4) < 0) break;
                            a.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128)
                        }
                    }
                    return a
                }
                function U(e) {
                    return t.toByteArray(function (e) {
                        if ((e = (e = e.split("=")[0]).trim().replace(N, "")).length < 2) return "";
                        for (; e.length % 4 != 0;) e += "=";
                        return e
                    }(e))
                }
                function B(e, t, n, i) {
                    for (var r = 0; r < i && !(r + n >= t.length || r >= e.length); ++r) t[r + n] = e[r];
                    return r
                }
                function z(e, t) {
                    return e instanceof t || null != e && null != e.constructor && null != e.constructor.name && e.constructor.name === t.name
                }
                function k(e) {
                    return e != e
                }
            }).call(this)
        }).call(this, e("buffer").Buffer)
    }, {
        "base64-js": 4,
        buffer: 7,
        ieee754: 11
    }],
    8: [function (e, t, n) {
        "use strict";
        var i = e("is-obj"),
            r = Object.prototype.hasOwnProperty,
            a = Object.prototype.propertyIsEnumerable;
        function s(e) {
            if (null == e) throw new TypeError("Sources cannot be null or undefined");
            return Object(e)
        }
        function o(e, t, n) {
            var a = t[n];
            if (null != a) {
                if (r.call(e, n) && (void 0 === e[n] || null === e[n])) throw new TypeError("Cannot convert undefined or null to object (" + n + ")");
                r.call(e, n) && i(a) ? e[n] = l(Object(e[n]), t[n]) : e[n] = a
            }
        }
        function l(e, t) {
            if (e === t) return e;
            for (var n in t = Object(t)) r.call(t, n) && o(e, t, n);
            if (Object.getOwnPropertySymbols)
                for (var i = Object.getOwnPropertySymbols(t), s = 0; s < i.length; s++) a.call(t, i[s]) && o(e, t, i[s]);
            return e
        }
        t.exports = function (e) {
            e = s(e);
            for (var t = 1; t < arguments.length; t++) l(e, arguments[t]);
            return e
        }
    }, {
        "is-obj": 15
    }],
    9: [function (e, t, n) {
        t.exports = function (e) {
            switch (e) {
            case "int8":
                return Int8Array;
            case "int16":
                return Int16Array;
            case "int32":
                return Int32Array;
            case "uint8":
                return Uint8Array;
            case "uint16":
                return Uint16Array;
            case "uint32":
                return Uint32Array;
            case "float32":
                return Float32Array;
            case "float64":
                return Float64Array;
            case "array":
                return Array;
            case "uint8_clamped":
                return Uint8ClampedArray
            }
        }
    }, {}],
    10: [function (e, t, n) {
        (function (e) {
            (function () {
                var n;
                n = "undefined" != typeof window ? window : void 0 !== e ? e : "undefined" != typeof self ? self : {}, t.exports = n
            }).call(this)
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {}],
    11: [function (e, t, n) {
        n.read = function (e, t, n, i, r) {
            var a, s, o = 8 * r - i - 1,
                l = (1 << o) - 1,
                c = l >> 1,
                u = -7,
                h = n ? r - 1 : 0,
                d = n ? -1 : 1,
                p = e[t + h];
            for (h += d, a = p & (1 << -u) - 1, p >>= -u, u += o; u > 0; a = 256 * a + e[t + h], h += d, u -= 8);
            for (s = a & (1 << -u) - 1, a >>= -u, u += i; u > 0; s = 256 * s + e[t + h], h += d, u -= 8);
            if (0 === a) a = 1 - c;
            else {
                if (a === l) return s ? NaN : 1 / 0 * (p ? -1 : 1);
                s += Math.pow(2, i), a -= c
            }
            return (p ? -1 : 1) * s * Math.pow(2, a - i)
        }, n.write = function (e, t, n, i, r, a) {
            var s, o, l, c = 8 * a - r - 1,
                u = (1 << c) - 1,
                h = u >> 1,
                d = 23 === r ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                p = i ? 0 : a - 1,
                f = i ? 1 : -1,
                m = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
            for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (o = isNaN(t) ? 1 : 0, s = u) : (s = Math.floor(Math.log(t) / Math.LN2), t * (l = Math.pow(2, -s)) < 1 && (s--, l *= 2), (t += s + h >= 1 ? d / l : d * Math.pow(2, 1 - h)) * l >= 2 && (s++, l /= 2), s + h >= u ? (o = 0, s = u) : s + h >= 1 ? (o = (t * l - 1) * Math.pow(2, r), s += h) : (o = t * Math.pow(2, h - 1) * Math.pow(2, r), s = 0)); r >= 8; e[n + p] = 255 & o, p += f, o /= 256, r -= 8);
            for (s = s << r | o, c += r; c > 0; e[n + p] = 255 & s, p += f, s /= 256, c -= 8);
            e[n + p - f] |= 128 * m
        }
    }, {}],
    12: [function (e, t, n) {
        "function" == typeof Object.create ? t.exports = function (e, t) {
            t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
                constructor: {
                    value: e,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            }))
        } : t.exports = function (e, t) {
            if (t) {
                e.super_ = t;
                var n = function () {};
                n.prototype = t.prototype, e.prototype = new n, e.prototype.constructor = e
            }
        }
    }, {}],
    13: [function (e, t, n) {
        function i(e) {
            return !!e.constructor && "function" == typeof e.constructor.isBuffer && e.constructor.isBuffer(e)
        }
        t.exports = function (e) {
            return null != e && (i(e) || function (e) {
                return "function" == typeof e.readFloatLE && "function" == typeof e.slice && i(e.slice(0, 0))
            }(e) || !!e._isBuffer)
        }
    }, {}],
    14: [function (e, t, n) {
        t.exports = function (e) {
            if (!e) return false;
            var t = i.call(e);
            return "[object Function]" === t || "function" == typeof e && "[object RegExp]" !== t || "undefined" != typeof window && (e === window.setTimeout || e === window.alert || e === window.confirm || e === window.prompt)
        };
        var i = Object.prototype.toString
    }, {}],
    15: [function (e, t, n) {
        "use strict";
        t.exports = function (e) {
            var t = typeof e;
            return null !== e && ("object" === t || "function" === t)
        }
    }, {}],
    16: [function (e, t, n) {
        var i = e("word-wrapper"),
            r = e("xtend"),
            a = e("as-number"),
            s = ["x", "e", "a", "o", "n", "s", "r", "c", "u", "m", "v", "w", "z"],
            o = ["m", "w"],
            l = ["H", "I", "N", "E", "F", "K", "L", "T", "U", "V", "W", "X", "Y", "Z"],
            c = "\t".charCodeAt(0),
            u = " ".charCodeAt(0);
        function h(e) {
            this.glyphs = [], this._measure = this.computeMetrics.bind(this), this.update(e)
        }
        function d(e) {
            return new Function(["return function " + e + "() {", "  return this._" + e, "}"].join("\n"))()
        }
        function p(e, t) {
            if (!e.chars || 0 === e.chars.length) return null;
            var n = m(e.chars, t);
            return n >= 0 ? e.chars[n] : null
        }
        function f(e, t, n) {
            if (!e.kernings || 0 === e.kernings.length) return 0;
            for (var i = e.kernings, r = 0; r < i.length; r++) {
                var a = i[r];
                if (a.first === t && a.second === n) return a.amount
            }
            return 0
        }
        function m(e, t, n) {
            for (var i = n = n || 0; i < e.length; i++)
                if (e[i].id === t) return i;
            return -1
        }
        t.exports = function (e) {
            return new h(e)
        }, h.prototype.update = function (e) {
            if (e = r({
                    measure: this._measure
                }, e), this._opt = e, this._opt.tabSize = a(this._opt.tabSize, 4), !e.font) throw new Error("must provide a valid bitmap font");
            var t = this.glyphs,
                n = e.text || "",
                o = e.font;
            this._setupSpaceGlyphs(o);
            var c = i.lines(n, e),
                u = e.width || 0;
            t.length = 0;
            var h = c.reduce((function (e, t) {
                    return Math.max(e, t.width, u)
                }), 0),
                d = 0,
                p = 0,
                g = a(e.lineHeight, o.common.lineHeight),
                v = o.common.base,
                y = g - v,
                x = e.letterSpacing || 0,
                b = g * c.length - y,
                _ = function (e) {
                    if ("center" === e) return 1;
                    if ("right" === e) return 2;
                    return 0
                }(this._opt.align);
            p -= b, this._width = h, this._height = b, this._descender = g - v, this._baseline = v, this._xHeight = function (e) {
                for (var t = 0; t < s.length; t++) {
                    var n = s[t].charCodeAt(0),
                        i = m(e.chars, n);
                    if (i >= 0) return e.chars[i].height
                }
                return 0
            }(o), this._capHeight = function (e) {
                for (var t = 0; t < l.length; t++) {
                    var n = l[t].charCodeAt(0),
                        i = m(e.chars, n);
                    if (i >= 0) return e.chars[i].height
                }
                return 0
            }(o), this._lineHeight = g, this._ascender = g - y - this._xHeight;
            var w = this;
            c.forEach((function (e, i) {
                for (var r, a = e.start, s = e.end, l = e.width, c = a; c < s; c++) {
                    var u = n.charCodeAt(c),
                        m = w.getGlyph(o, u);
                    if (m) {
                        r && (d += f(o, r.id, m.id));
                        var v = d;
                        1 === _ ? v += (h - l) / 2 : 2 === _ && (v += h - l), t.push({
                            position: [v, p],
                            data: m,
                            index: c,
                            line: i
                        }), d += m.xadvance + x, r = m
                    }
                }
                p += g, d = 0
            })), this._linesTotal = c.length
        }, h.prototype._setupSpaceGlyphs = function (e) {
            if (this._fallbackSpaceGlyph = null, this._fallbackTabGlyph = null, e.chars && 0 !== e.chars.length) {
                var t = p(e, u) || function (e) {
                        for (var t = 0; t < o.length; t++) {
                            var n = o[t].charCodeAt(0),
                                i = m(e.chars, n);
                            if (i >= 0) return e.chars[i]
                        }
                        return 0
                    }(e) || e.chars[0],
                    n = this._opt.tabSize * t.xadvance;
                this._fallbackSpaceGlyph = t, this._fallbackTabGlyph = r(t, {
                    x: 0,
                    y: 0,
                    xadvance: n,
                    id: c,
                    xoffset: 0,
                    yoffset: 0,
                    width: 0,
                    height: 0
                })
            }
        }, h.prototype.getGlyph = function (e, t) {
            var n = p(e, t);
            return n || (t === c ? this._fallbackTabGlyph : t === u ? this._fallbackSpaceGlyph : null)
        }, h.prototype.computeMetrics = function (e, t, n, i) {
            var r, a = this._opt.letterSpacing || 0,
                s = this._opt.font,
                o = 0,
                l = 0,
                c = 0;
            if (!s.chars || 0 === s.chars.length) return {
                start: t,
                end: t,
                width: 0
            };
            n = Math.min(e.length, n);
            for (var u = t; u < n; u++) {
                var h, d = e.charCodeAt(u);
                if (h = this.getGlyph(s, d)) {
                    h.xoffset;
                    var p = (o += r ? f(s, r.id, h.id) : 0) + h.xadvance + a,
                        m = o + h.width;
                    if (m >= i || p >= i) break;
                    o = p, l = m, r = h
                }
                c++
            }
            return r && (l += r.xoffset), {
                start: t,
                end: t + c,
                width: l
            }
        }, ["width", "height", "descender", "ascender", "xHeight", "baseline", "capHeight", "lineHeight"].forEach((function (e) {
            Object.defineProperty(h.prototype, e, {
                get: d(e),
                configurable: true
            })
        }))
    }, {
        "as-number": 3,
        "word-wrapper": 28,
        xtend: 31
    }],
    17: [function (e, t, n) {
        (function (n) {
            (function () {
                var i = e("xhr"),
                    r = function () {},
                    a = e("parse-bmfont-ascii"),
                    s = e("parse-bmfont-xml"),
                    o = e("parse-bmfont-binary"),
                    l = e("./lib/is-binary"),
                    c = e("xtend"),
                    u = self.XMLHttpRequest && "withCredentials" in new XMLHttpRequest;
                t.exports = function (e, t) {
                    t = "function" == typeof t ? t : r, "string" == typeof e ? e = {
                        uri: e
                    } : e || (e = {}), e.binary && (e = function (e) {
                        if (u) return c(e, {
                            responseType: "arraybuffer"
                        });
                        if (void 0 === self.XMLHttpRequest) throw new Error("your browser does not support XHR loading");
                        var t = new self.XMLHttpRequest;
                        return t.overrideMimeType("text/plain; charset=x-user-defined"), c({
                            xhr: t
                        }, e)
                    }(e)), i(e, (function (i, c, u) {
                        if (i) return t(i);
                        if (!/^2/.test(c.statusCode)) return t(new Error("http status code: " + c.statusCode));
                        if (!u) return t(new Error("no body result"));
                        var h, d, p = false;
                        if (h = u, "[object ArrayBuffer]" === Object.prototype.toString.call(h)) {
                            var f = new Uint8Array(u);
                            u = n.from(f, "binary")
                        }
                        l(u) && (p = true, "string" == typeof u && (u = n.from(u, "binary"))), p || (n.isBuffer(u) && (u = u.toString(e.encoding)), u = u.trim());
                        try {
                            var m = c.headers["content-type"];
                            d = p ? o(u) : /json/.test(m) || "{" === u.charAt(0) ? JSON.parse(u) : /xml/.test(m) || "<" === u.charAt(0) ? s(u) : a(u)
                        } catch (e) {
                            t(new Error("error parsing font " + e.message)), t = r
                        }
                        t(null, d)
                    }))
                }
            }).call(this)
        }).call(this, e("buffer").Buffer)
    }, {
        "./lib/is-binary": 18,
        buffer: 7,
        "parse-bmfont-ascii": 19,
        "parse-bmfont-binary": 20,
        "parse-bmfont-xml": 21,
        xhr: 29,
        xtend: 31
    }],
    18: [function (e, t, n) {
        (function (n) {
            (function () {
                var i = e("buffer-equal"),
                    r = n.from([66, 77, 70, 3]);
                t.exports = function (e) {
                    return "string" == typeof e ? "BMF" === e.substring(0, 3) : e.length > 4 && i(e.slice(0, 4), r)
                }
            }).call(this)
        }).call(this, e("buffer").Buffer)
    }, {
        buffer: 7,
        "buffer-equal": 6
    }],
    19: [function (e, t, n) {
        function i(e, t) {
            if (!(e = e.replace(/\t+/g, " ").trim())) return null;
            var n = e.indexOf(" ");
            if (-1 === n) throw new Error("no named row at line " + t);
            var i = e.substring(0, n);
            e = (e = (e = (e = e.substring(n + 1)).replace(/letter=[\'\"]\S+[\'\"]/gi, "")).split("=")).map((function (e) {
                return e.trim().match(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g)
            }));
            for (var a = [], s = 0; s < e.length; s++) {
                var o = e[s];
                0 === s ? a.push({
                    key: o[0],
                    data: ""
                }) : s === e.length - 1 ? a[a.length - 1].data = r(o[0]) : (a[a.length - 1].data = r(o[0]), a.push({
                    key: o[1],
                    data: ""
                }))
            }
            var l = {
                key: i,
                data: {}
            };
            return a.forEach((function (e) {
                l.data[e.key] = e.data
            })), l
        }
        function r(e) {
            return e && 0 !== e.length ? 0 === e.indexOf('"') || 0 === e.indexOf("'") ? e.substring(1, e.length - 1) : -1 !== e.indexOf(",") ? function (e) {
                return e.split(",").map((function (e) {
                    return parseInt(e, 10)
                }))
            }(e) : parseInt(e, 10) : ""
        }
        t.exports = function (e) {
            if (!e) throw new Error("no data provided");
            var t = {
                    pages: [],
                    chars: [],
                    kernings: []
                },
                n = (e = e.toString().trim()).split(/\r\n?|\n/g);
            if (0 === n.length) throw new Error("no data in BMFont file");
            for (var r = 0; r < n.length; r++) {
                var a = i(n[r], r);
                if (a)
                    if ("page" === a.key) {
                        if ("number" != typeof a.data.id) throw new Error("malformed file at line " + r + " -- needs page id=N");
                        if ("string" != typeof a.data.file) throw new Error("malformed file at line " + r + ' -- needs page file="path"');
                        t.pages[a.data.id] = a.data.file
                    } else "chars" === a.key || "kernings" === a.key || ("char" === a.key ? t.chars.push(a.data) : "kerning" === a.key ? t.kernings.push(a.data) : t[a.key] = a.data)
            }
            return t
        }
    }, {}],
    20: [function (e, t, n) {
        var i = [66, 77, 70];
        function r(e, t, n) {
            if (n > t.length - 1) return 0;
            var i = t.readUInt8(n++),
                r = t.readInt32LE(n);
            switch (n += 4, i) {
            case 1:
                e.info = function (e, t) {
                    var n = {};
                    n.size = e.readInt16LE(t);
                    var i = e.readUInt8(t + 2);
                    n.smooth = i >> 7 & 1, n.unicode = i >> 6 & 1, n.italic = i >> 5 & 1, n.bold = i >> 4 & 1, i >> 3 & 1 && (n.fixedHeight = 1);
                    return n.charset = e.readUInt8(t + 3) || "", n.stretchH = e.readUInt16LE(t + 4), n.aa = e.readUInt8(t + 6), n.padding = [e.readInt8(t + 7), e.readInt8(t + 8), e.readInt8(t + 9), e.readInt8(t + 10)], n.spacing = [e.readInt8(t + 11), e.readInt8(t + 12)], n.outline = e.readUInt8(t + 13), n.face = function (e, t) {
                        return a(e, t).toString("utf8")
                    }(e, t + 14), n
                }(t, n);
                break;
            case 2:
                e.common = function (e, t) {
                    var n = {};
                    n.lineHeight = e.readUInt16LE(t), n.base = e.readUInt16LE(t + 2), n.scaleW = e.readUInt16LE(t + 4), n.scaleH = e.readUInt16LE(t + 6), n.pages = e.readUInt16LE(t + 8);
                    e.readUInt8(t + 10);
                    return n.packed = 0, n.alphaChnl = e.readUInt8(t + 11), n.redChnl = e.readUInt8(t + 12), n.greenChnl = e.readUInt8(t + 13), n.blueChnl = e.readUInt8(t + 14), n
                }(t, n);
                break;
            case 3:
                e.pages = function (e, t, n) {
                    for (var i = [], r = a(e, t), s = r.length + 1, o = n / s, l = 0; l < o; l++) i[l] = e.slice(t, t + r.length).toString("utf8"), t += s;
                    return i
                }(t, n, r);
                break;
            case 4:
                e.chars = function (e, t, n) {
                    for (var i = [], r = n / 20, a = 0; a < r; a++) {
                        var s = {},
                            o = 20 * a;
                        s.id = e.readUInt32LE(t + 0 + o), s.x = e.readUInt16LE(t + 4 + o), s.y = e.readUInt16LE(t + 6 + o), s.width = e.readUInt16LE(t + 8 + o), s.height = e.readUInt16LE(t + 10 + o), s.xoffset = e.readInt16LE(t + 12 + o), s.yoffset = e.readInt16LE(t + 14 + o), s.xadvance = e.readInt16LE(t + 16 + o), s.page = e.readUInt8(t + 18 + o), s.chnl = e.readUInt8(t + 19 + o), i[a] = s
                    }
                    return i
                }(t, n, r);
                break;
            case 5:
                e.kernings = function (e, t, n) {
                    for (var i = [], r = n / 10, a = 0; a < r; a++) {
                        var s = {},
                            o = 10 * a;
                        s.first = e.readUInt32LE(t + 0 + o), s.second = e.readUInt32LE(t + 4 + o), s.amount = e.readInt16LE(t + 8 + o), i[a] = s
                    }
                    return i
                }(t, n, r)
            }
            return 5 + r
        }
        function a(e, t) {
            for (var n = t; n < e.length && 0 !== e[n]; n++);
            return e.slice(t, n)
        }
        t.exports = function (e) {
            if (e.length < 6) throw new Error("invalid buffer length for BMFont");
            var t = i.every((function (t, n) {
                return e.readUInt8(n) === t
            }));
            if (!t) throw new Error("BMFont missing BMF byte header");
            var n = 3;
            if (e.readUInt8(n++) > 3) throw new Error("Only supports BMFont Binary v3 (BMFont App v1.10)");
            for (var a = {
                    kernings: [],
                    chars: []
                }, s = 0; s < 5; s++) n += r(a, e, n);
            return a
        }
    }, {}],
    21: [function (e, t, n) {
        var i = e("./parse-attribs"),
            r = e("xml-parse-from-string"),
            a = {
                scaleh: "scaleH",
                scalew: "scaleW",
                stretchh: "stretchH",
                lineheight: "lineHeight",
                alphachnl: "alphaChnl",
                redchnl: "redChnl",
                greenchnl: "greenChnl",
                bluechnl: "blueChnl"
            };
        function s(e) {
            var t = function (e) {
                for (var t = [], n = 0; n < e.attributes.length; n++) t.push(e.attributes[n]);
                return t
            }(e);
            return t.reduce((function (e, t) {
                var n;
                return e[(n = t.nodeName, a[n.toLowerCase()] || n)] = t.nodeValue, e
            }), {})
        }
        t.exports = function (e) {
            e = e.toString();
            var t = r(e),
                n = {
                    pages: [],
                    chars: [],
                    kernings: []
                };
            ["info", "common"].forEach((function (e) {
                var r = t.getElementsByTagName(e)[0];
                r && (n[e] = i(s(r)))
            }));
            var a = t.getElementsByTagName("pages")[0];
            if (!a) throw new Error("malformed file -- no <pages> element");
            for (var o = a.getElementsByTagName("page"), l = 0; l < o.length; l++) {
                var c = o[l],
                    u = parseInt(c.getAttribute("id"), 10),
                    h = c.getAttribute("file");
                if (isNaN(u)) throw new Error('malformed file -- page "id" attribute is NaN');
                if (!h) throw new Error('malformed file -- needs page "file" attribute');
                n.pages[parseInt(u, 10)] = h
            }
            return ["chars", "kernings"].forEach((function (e) {
                var r = t.getElementsByTagName(e)[0];
                if (r)
                    for (var a = e.substring(0, e.length - 1), o = r.getElementsByTagName(a), l = 0; l < o.length; l++) {
                        var c = o[l];
                        n[e].push(i(s(c)))
                    }
            })), n
        }
    }, {
        "./parse-attribs": 22,
        "xml-parse-from-string": 30
    }],
    22: [function (e, t, n) {
        var i = "chasrset";
        t.exports = function (e) {
            for (var t in i in e && (e.charset = e.chasrset, delete e.chasrset), e) "face" !== t && "charset" !== t && (e[t] = "padding" === t || "spacing" === t ? e[t].split(",").map((function (e) {
                return parseInt(e, 10)
            })) : parseInt(e[t], 10));
            return e
        }
    }, {}],
    23: [function (e, t, n) {
        var i = function (e) {
            return e.replace(/^\s+|\s+$/g, "")
        };
        t.exports = function (e) {
            if (!e) return {};
            for (var t, n = {}, r = i(e).split("\n"), a = 0; a < r.length; a++) {
                var s = r[a],
                    o = s.indexOf(":"),
                    l = i(s.slice(0, o)).toLowerCase(),
                    c = i(s.slice(o + 1));
                void 0 === n[l] ? n[l] = c : (t = n[l], "[object Array]" === Object.prototype.toString.call(t) ? n[l].push(c) : n[l] = [n[l], c])
            }
            return n
        }
    }, {}],
    24: [function (e, t, n) {
        var i = e("dtype"),
            r = e("an-array"),
            a = e("is-buffer"),
            s = [0, 2, 3],
            o = [2, 1, 3];
        t.exports = function (e, t) {
            e && (r(e) || a(e)) || (t = e || {}, e = null);
            for (var n = "string" == typeof (t = "number" == typeof t ? {
                    count: t
                } : t || {}).type ? t.type : "uint16", l = "number" == typeof t.count ? t.count : 1, c = t.start || 0, u = !1 !== t.clockwise ? s : o, h = u[0], d = u[1], p = u[2], f = 6 * l, m = e || new(i(n))(f), g = 0, v = 0; g < f; g += 6, v += 4) {
                var y = g + c;
                m[y + 0] = v + 0, m[y + 1] = v + 1, m[y + 2] = v + 2, m[y + 3] = v + h, m[y + 4] = v + d, m[y + 5] = v + p
            }
            return m
        }
    }, {
        "an-array": 1,
        dtype: 9,
        "is-buffer": 13
    }],
    25: [function (e, t, n) {
        var i = e("layout-bmfont-text"),
            r = e("inherits"),
            a = e("quad-indices"),
            s = e("./lib/vertices"),
            o = e("./lib/utils"),
            l = THREE.BufferGeometry;
        t.exports = function (e) {
            return new c(e)
        };
        class c extends THREE.BufferGeometry {
            constructor(e) {
                super(e), "string" == typeof e && (e = {
                    text: e
                }), this._opt = Object.assign({}, e), e && this.update(e)
            }
        }
        r(c, l), c.prototype.update = function (e) {
            if ("string" == typeof e && (e = {
                    text: e
                }), !(e = Object.assign({}, this._opt, e)).font) throw new TypeError("must specify a { font } in options");
            this.layout = i(e);
            var t = !1 !== e.flipY,
                n = e.font,
                r = n.common.scaleW,
                o = n.common.scaleH,
                l = this.layout.glyphs.filter((function (e) {
                    var t = e.data;
                    return t.width * t.height > 0
                }));
            this.visibleGlyphs = l;
            var c = s.positions(l),
                u = s.uvs(l, r, o, t),
                h = a([], {
                    clockwise: true,
                    type: "uint16",
                    count: l.length
                });
            if (this.setIndex(h), this.setAttribute("position", new THREE.BufferAttribute(c, 2)), this.setAttribute("uv", new THREE.BufferAttribute(u, 2)), !e.multipage && "page" in this.attributes) this.removeAttribute("page");
            else if (e.multipage) {
                var d = s.pages(l);
                this.setAttribute("page", new THREE.BufferAttribute(d, 1))
            }
        }, c.prototype.computeBoundingSphere = function () {
            null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere);
            var e = this.attributes.position.array,
                t = this.attributes.position.itemSize;
            if (!e || !t || e.length < 2) return this.boundingSphere.radius = 0, void this.boundingSphere.center.set(0, 0, 0);
            o.computeSphere(e, this.boundingSphere), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.')
        }, c.prototype.computeBoundingBox = function () {
            null === this.boundingBox && (this.boundingBox = new THREE.Box3);
            var e = this.boundingBox,
                t = this.attributes.position.array,
                n = this.attributes.position.itemSize;
            !t || !n || t.length < 2 ? e.makeEmpty() : o.computeBox(t, e)
        }
    }, {
        "./lib/utils": 26,
        "./lib/vertices": 27,
        inherits: 12,
        "layout-bmfont-text": 16,
        "quad-indices": 24
    }],
    26: [function (e, t, n) {
        var i = {
            min: [0, 0],
            max: [0, 0]
        };
        function r(e) {
            var t = e.length / 2;
            i.min[0] = e[0], i.min[1] = e[1], i.max[0] = e[0], i.max[1] = e[1];
            for (var n = 0; n < t; n++) {
                var r = e[2 * n + 0],
                    a = e[2 * n + 1];
                i.min[0] = Math.min(r, i.min[0]), i.min[1] = Math.min(a, i.min[1]), i.max[0] = Math.max(r, i.max[0]), i.max[1] = Math.max(a, i.max[1])
            }
        }
        t.exports.computeBox = function (e, t) {
            r(e), t.min.set(i.min[0], i.min[1], 0), t.max.set(i.max[0], i.max[1], 0)
        }, t.exports.computeSphere = function (e, t) {
            r(e);
            var n = i.min[0],
                a = i.min[1],
                s = i.max[0] - n,
                o = i.max[1] - a,
                l = Math.sqrt(s * s + o * o);
            t.center.set(n + s / 2, a + o / 2, 0), t.radius = l / 2
        }
    }, {}],
    27: [function (e, t, n) {
        t.exports.pages = function (e) {
            var t = new Float32Array(4 * e.length * 1),
                n = 0;
            return e.forEach((function (e) {
                var i = e.data.page || 0;
                t[n++] = i, t[n++] = i, t[n++] = i, t[n++] = i
            })), t
        }, t.exports.uvs = function (e, t, n, i) {
            var r = new Float32Array(4 * e.length * 2),
                a = 0;
            return e.forEach((function (e) {
                var s = e.data,
                    o = s.x + s.width,
                    l = s.y + s.height,
                    c = s.x / t,
                    u = s.y / n,
                    h = o / t,
                    d = l / n;
                i && (u = (n - s.y) / n, d = (n - l) / n), r[a++] = c, r[a++] = u, r[a++] = c, r[a++] = d, r[a++] = h, r[a++] = d, r[a++] = h, r[a++] = u
            })), r
        }, t.exports.positions = function (e) {
            var t = new Float32Array(4 * e.length * 2),
                n = 0;
            return e.forEach((function (e) {
                var i = e.data,
                    r = e.position[0] + i.xoffset,
                    a = e.position[1] + i.yoffset,
                    s = i.width,
                    o = i.height;
                t[n++] = r, t[n++] = a, t[n++] = r, t[n++] = a + o, t[n++] = r + s, t[n++] = a + o, t[n++] = r + s, t[n++] = a
            })), t
        }
    }, {}],
    28: [function (e, t, n) {
        var i = /\n/,
            r = "\n",
            a = /\s/;
        function s(e, t, n, i) {
            var r = e.indexOf(t, n);
            return -1 === r || r > i ? i : r
        }
        function o(e) {
            return a.test(e)
        }
        function l(e, t, n, i) {
            return {
                start: t,
                end: t + Math.min(i, n - t)
            }
        }
        t.exports = function (e, n) {
            return t.exports.lines(e, n).map((function (t) {
                return e.substring(t.start, t.end)
            })).join("\n")
        }, t.exports.lines = function (e, t) {
            if (0 === (t = t || {}).width && "nowrap" !== t.mode) return [];
            e = e || "";
            var n = "number" == typeof t.width ? t.width : Number.MAX_VALUE,
                a = Math.max(0, t.start || 0),
                c = "number" == typeof t.end ? t.end : e.length,
                u = t.mode,
                h = t.measure || l;
            return "pre" === u ? function (e, t, n, r, a) {
                for (var s = [], o = n, l = n; l < r && l < t.length; l++) {
                    var c = t.charAt(l),
                        u = i.test(c);
                    if (u || l === r - 1) {
                        var h = e(t, o, u ? l : l + 1, a);
                        s.push(h), o = l + 1
                    }
                }
                return s
            }(h, e, a, c, n) : function (e, t, n, i, a, l) {
                var c = [],
                    u = a;
                "nowrap" === l && (u = Number.MAX_VALUE);
                for (; n < i && n < t.length;) {
                    for (var h = s(t, r, n, i); n < h && o(t.charAt(n));) n++;
                    var d = e(t, n, h, u),
                        p = n + (d.end - d.start),
                        f = p + r.length;
                    if (p < h) {
                        for (; p > n && !o(t.charAt(p));) p--;
                        if (p === n) f > n + r.length && f--, p = f;
                        else
                            for (f = p; p > n && o(t.charAt(p - r.length));) p--
                    }
                    if (p >= n) {
                        var m = e(t, n, p, u);
                        c.push(m)
                    }
                    n = f
                }
                return c
            }(h, e, a, c, n, u)
        }
    }, {}],
    29: [function (e, t, n) {
        "use strict";
        var i = e("global/window"),
            r = e("is-function"),
            a = e("parse-headers"),
            s = e("xtend");
        function o(e, t, n) {
            var i = e;
            return r(t) ? (n = t, "string" == typeof e && (i = {
                uri: e
            })) : i = s(t, {
                uri: e
            }), i.callback = n, i
        }
        function l(e, t, n) {
            return c(t = o(e, t, n))
        }
        function c(e) {
            if (void 0 === e.callback) throw new Error("callback argument missing");
            var t = false,
                n = function (n, i, r) {
                    t || (t = true, e.callback(n, i, r))
                };
            function i() {
                var e = void 0;
                if (e = u.response ? u.response : u.responseText || function (e) {
                        try {
                            if ("document" === e.responseType) return e.responseXML;
                            var t = e.responseXML && "parsererror" === e.responseXML.documentElement.nodeName;
                            if ("" === e.responseType && !t) return e.responseXML
                        } catch (e) {}
                        return null
                    }(u), v) try {
                    e = JSON.parse(e)
                } catch (e) {}
                return e
            }
            function r(e) {
                return clearTimeout(h), e instanceof Error || (e = new Error("" + (e || "Unknown XMLHttpRequest Error"))), e.statusCode = 0, n(e, y)
            }
            function s() {
                if (!c) {
                    var t;
                    clearTimeout(h), t = e.useXDR && void 0 === u.status ? 200 : 1223 === u.status ? 204 : u.status;
                    var r = y,
                        s = null;
                    return 0 !== t ? (r = {
                        body: i(),
                        statusCode: t,
                        method: p,
                        headers: {},
                        url: d,
                        rawRequest: u
                    }, u.getAllResponseHeaders && (r.headers = a(u.getAllResponseHeaders()))) : s = new Error("Internal XMLHttpRequest Error"), n(s, r, r.body)
                }
            }
            var o, c, u = e.xhr || null;
            u || (u = e.cors || e.useXDR ? new l.XDomainRequest : new l.XMLHttpRequest);
            var h, d = u.url = e.uri || e.url,
                p = u.method = e.method || "GET",
                f = e.body || e.data,
                m = u.headers = e.headers || {},
                g = !!e.sync,
                v = false,
                y = {
                    body: void 0,
                    headers: {},
                    statusCode: 0,
                    method: p,
                    url: d,
                    rawRequest: u
                };
            if ("json" in e && !1 !== e.json && (v = true, m.accept || m.Accept || (m.Accept = "application/json"), "GET" !== p && "HEAD" !== p && (m["content-type"] || m["Content-Type"] || (m["Content-Type"] = "application/json"), f = JSON.stringify(!0 === e.json ? f : e.json))), u.onreadystatechange = function () {
                    4 === u.readyState && setTimeout(s, 0)
                }, u.onload = s, u.onerror = r, u.onprogress = function () {}, u.onabort = function () {
                    c = true
                }, u.ontimeout = r, u.open(p, d, !g, e.username, e.password), g || (u.withCredentials = !!e.withCredentials), !g && e.timeout > 0 && (h = setTimeout((function () {
                    if (!c) {
                        c = true, u.abort("timeout");
                        var e = new Error("XMLHttpRequest timeout");
                        e.code = "ETIMEDOUT", r(e)
                    }
                }), e.timeout)), u.setRequestHeader)
                for (o in m) m.hasOwnProperty(o) && u.setRequestHeader(o, m[o]);
            else if (e.headers && ! function (e) {
                    for (var t in e)
                        if (e.hasOwnProperty(t)) return false;
                    return true
                }(e.headers)) throw new Error("Headers cannot be set on an XDomainRequest object");
            return "responseType" in e && (u.responseType = e.responseType), "beforeSend" in e && "function" == typeof e.beforeSend && e.beforeSend(u), u.send(f || null), u
        }
        t.exports = l, t.exports.default = l, l.XMLHttpRequest = i.XMLHttpRequest || function () {}, l.XDomainRequest = "withCredentials" in new l.XMLHttpRequest ? l.XMLHttpRequest : i.XDomainRequest,
            function (e, t) {
                for (var n = 0; n < e.length; n++) t(e[n])
            }(["get", "put", "post", "patch", "head", "delete"], (function (e) {
                l["delete" === e ? "del" : e] = function (t, n, i) {
                    return (n = o(t, n, i)).method = e.toUpperCase(), c(n)
                }
            }))
    }, {
        "global/window": 10,
        "is-function": 14,
        "parse-headers": 23,
        xtend: 31
    }],
    30: [function (e, t, n) {
        t.exports = void 0 !== self.DOMParser ? function (e) {
            return (new self.DOMParser).parseFromString(e, "application/xml")
        } : void 0 !== self.ActiveXObject && new self.ActiveXObject("Microsoft.XMLDOM") ? function (e) {
            var t = new self.ActiveXObject("Microsoft.XMLDOM");
            return t.async = "false", t.loadXML(e), t
        } : function (e) {
            var t = document.createElement("div");
            return t.innerHTML = e, t
        }
    }, {}],
    31: [function (e, t, n) {
        t.exports = function () {
            for (var e = {}, t = 0; t < arguments.length; t++) {
                var n = arguments[t];
                for (var r in n) i.call(n, r) && (e[r] = n[r])
            }
            return e
        };
        var i = Object.prototype.hasOwnProperty
    }, {}],
    32: [function (e, t, n) {
        const i = e("animejs"),
            r = e("../utils"),
            a = r.entity;
        let s = new THREE.Color,
            o = new THREE.Color;
        function l(e) {
            e.x = THREE.MathUtils.degToRad(e.x), e.y = THREE.MathUtils.degToRad(e.y), e.z = THREE.MathUtils.degToRad(e.z)
        }
        function c(e, t, n) {
            t.forEach((t => {
                e.addEventListener(t, n)
            }))
        }
        function u(e, t, n) {
            t.forEach((t => {
                e.removeEventListener(t, n)
            }))
        }
        function h(e, t) {
            const n = t.split(".");
            let i = e;
            for (let e = 0; e < n.length; e++) i = i[n[e]];
            if (void 0 === i) throw console.log(e), new Error("[animation] property (" + t + ") could not be found");
            return i
        }
        function d(e, t, n, i) {
            t.startsWith("object3D.rotation") && (n = THREE.MathUtils.degToRad(n));
            const r = t.split(".");
            let a = e;
            for (let e = 0; e < r.length - 1; e++) a = a[r[e]];
            const s = r[r.length - 1];
            "color" !== i ? a[s] = n : "r" in a[s] ? (a[s].r = n.r, a[s].g = n.g, a[s].b = n.b) : (a[s].x = n.r, a[s].y = n.g, a[s].z = n.b)
        }
        function p(e) {
            return e.isRawProperty || e.property.startsWith("directives") || e.property.startsWith("object3D")
        }
        t.exports.Directive = e("./directive").registerDirective("animation", {
            schema: {
                autoplay: {
                    default: true
                },
                delay: {
                    default: 0
                },
                dir: {
                    default: ""
                },
                dur: {
                    default: 1e3
                },
                easing: {
                    default: "linear"
                },
                elasticity: {
                    default: 400
                },
                enabled: {
                    default: true
                },
                from: {
                    default: ""
                },
                loop: {
                    default: 0,
                    parse: function (e) {
                        return !0 === e || "true" === e || !1 !== e && "false" !== e && parseInt(e, 10)
                    }
                },
                property: {
                    default: ""
                },
                startEvents: {
                    type: "array"
                },
                pauseEvents: {
                    type: "array"
                },
                resumeEvents: {
                    type: "array"
                },
                round: {
                    default: false
                },
                to: {
                    default: ""
                },
                type: {
                    default: ""
                },
                isRawProperty: {
                    default: false
                }
            },
            multiple: true,
            init() {
                const e = this;
                e.eventDetail = {
                    name: e.attrName
                }, e.time = 0, e.shadowMap = e.el.sceneEl.renderer.shadowMap, e.animation = null, e.animationIsPlaying = false, e.onStartEvent = e.onStartEvent.bind(e), e.beginAnimation = e.beginAnimation.bind(e), e.pauseAnimation = e.pauseAnimation.bind(e), e.resumeAnimation = e.resumeAnimation.bind(e), e.fromColor = {}, e.toColor = {}, e.targets = {}, e.targetsArray = [], e.updateConfigForDefault = e.updateConfigForDefault.bind(e), e.updateConfigForRawColor = e.updateConfigForRawColor.bind(e), e.config = {
                    complete() {
                        e.animationIsPlaying = false, e.el.emit("animationcomplete", e.eventDetail, false), e.id && e.el.emit("animationcomplete__" + e.id, e.eventDetail, false)
                    }
                }
            },
            update() {
                const e = this.data;
                this.animationIsPlaying = false, e.enabled && e.property && (Object.assign(this.config, {
                    autoplay: false,
                    direction: e.dir,
                    duration: e.dur,
                    easing: e.easing,
                    elasticity: e.elasticity,
                    loop: e.loop,
                    round: e.round
                }), this.createAndStartAnimation())
            },
            tick(e, t) {
                if (!this.animationIsPlaying) return true;
                this.time += 1e3 * t, this.animation.tick(this.time), this.shadowMap.needsUpdate = true
            },
            remove() {
                this.pauseAnimation(), this.removeEventListeners()
            },
            pause() {
                this.paused = true, this.pausedWasPlaying = this.animationIsPlaying, this.remove()
            },
            play() {
                this.paused && (this.paused = false, this.addEventListeners(), this.pausedWasPlaying && (this.resumeAnimation(), this.pausedWasPlaying = false))
            },
            createAndStartAnimation() {
                const e = this.data;
                this.updateConfig(), this.animationIsPlaying = false, this.animation = i(this.config), this.animation.began = true, this.removeEventListeners(), this.addEventListeners(), !e.autoplay || e.startEvents && e.startEvents.length || setTimeout(this.beginAnimation, e.delay || 0)
            },
            beginAnimation() {
                this.updateConfig(), this.animation.began = true, this.time = 0, this.animationIsPlaying = true, this.stopRelatedAnimations(), this.el.emit("animationbegin", this.eventDetail, false)
            },
            pauseAnimation() {
                this.animationIsPlaying = false
            },
            resumeAnimation() {
                this.animationIsPlaying = true
            },
            onStartEvent() {
                this.data.enabled && (this.updateConfig(), this.animation && this.animation.pause(), this.animation = i(this.config), setTimeout(this.beginAnimation, this.data.delay || 0))
            },
            updateConfigForRawColor() {
                const e = this.data,
                    t = this.el;
                if (this.waitDirectiveInitRawProperty(this.updateConfigForRawColor)) return;
                let n = e.from || h(t, e.property),
                    i = e.to;
                this.setColorConfig(n, i), n = this.fromColor, i = this.toColor, this.targetsArray.length = 0, this.targetsArray.push(n);
                let r = this.config;
                for (var a in r.targets = this.targetsArray, i) r[a] = i[a];
                var s;
                r.update = (s = {}, function (n) {
                    var i;
                    (i = n.animatables[0].target).r === s.r && i.g === s.g && i.b === s.b || d(t, e.property, i, e.type)
                })
            },
            updateConfigForDefault() {
                let e = this.config;
                const t = this.data,
                    n = this.el;
                let i, r;
                if (this.waitDirectiveInitRawProperty(this.updateConfigForDefault)) return;
                r = "" === t.from ? p(t) ? h(n, t.property) : a.getDirectiveProperty(n, t.property) : t.from, i = t.to, isNaN(r || i) ? (r = r ? r.toString() : r, i = i ? i.toString() : i) : (r = parseFloat(r), i = parseFloat(i));
                const s = "true" === t.to || "false" === t.to || !0 === t.to || !1 === t.to;
                s && (r = "true" === t.from || !0 === t.from ? 1 : 0, i = "true" === t.to || !0 === t.to ? 1 : 0), this.targets.aframeProperty = r, e.targets = this.targets, e.aframeProperty = i, e.update = function () {
                    let e;
                    return function (i) {
                        let r = i.animatables[0].target.aframeProperty;
                        r !== e && (e = r, s && (r = r >= 1), p(t) ? d(n, t.property, r, t.type) : a.setDirectiveProperty(n, t.property, r))
                    }
                }()
            },
            updateConfigForVector() {
                let e = this.config;
                const t = this.data,
                    n = this.el;
                let i = "" !== t.from ? r.coordinates.parse(t.from) : a.getDirectiveProperty(n, t.property),
                    s = r.coordinates.parse(t.to);
                "rotation" === t.property && (l(i), l(s)), this.targetsArray.length = 0, this.targetsArray.push(i), e.targets = this.targetsArray;
                for (let t in s) e[t] = s[t];
                "position" !== t.property && "rotation" !== t.property && "scale" !== t.property ? e.update = function () {
                    const e = {};
                    return function (i) {
                        const r = i.animatables[0].target;
                        r.x === e.x && r.y === e.y && r.z === e.z || (e.x = r.x, e.y = r.y, e.z = r.z, a.setDirectiveProperty(n, t.property, r))
                    }
                }() : e.update = function () {
                    let e = {};
                    return function (i) {
                        let r = i.animatables[0].target;
                        "scale" === t.property && (r.x = Math.max(1e-4, r.x), r.y = Math.max(1e-4, r.y), r.z = Math.max(1e-4, r.z)), r.x === e.x && r.y === e.y && r.z === e.z || (e.x = r.x, e.y = r.y, e.z = r.z, n.object3D[t.property].set(r.x, r.y, r.z))
                    }
                }()
            },
            updateConfig() {
                const t = function (t, n) {
                    const i = n.split("."),
                        r = i[0],
                        a = i[1],
                        s = t.directives[r] || e("./directive").directives[r];
                    if (!s) return null;
                    if (a && !s.schema[a]) return null;
                    if (a) return s.schema[a].type;
                    return s.schema.type
                }(this.el, this.data.property);
                p(this.data) && "color" === this.data.type ? this.updateConfigForRawColor() : "vec2" === t || "vec3" === t || "vec4" === t ? this.updateConfigForVector() : this.updateConfigForDefault()
            },
            waitDirectiveInitRawProperty(e) {
                const t = this.data,
                    n = this.el,
                    r = this;
                if ("" !== t.from || !t.property.startsWith("directives")) return false;
                const a = t.property.split(".")[1];
                return !n.directives[a] && (n.addEventListener("directiveinitialized", (function t(s) {
                    s.detail.name === a && (e(), r.animation = i(r.config), n.removeEventListener("directiveinitialized", t))
                })), true)
            },
            stopRelatedAnimations() {
                for (let e in this.el.directives) {
                    let t = this.el.directives[e];
                    "animation" === t.name && t.animationIsPlaying && e !== this.attrName && t.data.property === this.data.property && (t.animationIsPlaying = false)
                }
            },
            addEventListeners() {
                const e = this.data,
                    t = this.el;
                c(t, e.startEvents, this.onStartEvent), c(t, e.pauseEvents, this.pauseAnimation), c(t, e.resumeEvents, this.resumeAnimation)
            },
            removeEventListeners() {
                const e = this.data,
                    t = this.el;
                u(t, e.startEvents, this.onStartEvent), u(t, e.pauseEvents, this.pauseAnimation), u(t, e.resumeEvents, this.resumeAnimation)
            },
            setColorConfig(e, t) {
                s.set(e), o.set(t), e = this.fromColor, t = this.toColor, e.r = s.r, e.g = s.g, e.b = s.b, t.r = o.r, t.g = o.g, t.b = o.b
            }
        })
    }, {
        "../utils": 96,
        "./directive": 34,
        animejs: 2
    }],
    33: [function (e, t, n) {
        t.exports.Directive = e("./directive").registerDirective("camera", {
            schema: {
                far: {
                    default: 1500
                },
                fov: {
                    default: 50,
                    min: 0
                },
                near: {
                    default: 1,
                    min: 0
                },
                zoom: {
                    default: 1,
                    min: 0
                }
            },
            init() {
                this.el.setObject3D("camera", this.el.sceneEl.camera = new THREE.PerspectiveCamera), this.el.sceneEl.emit("cameraready", {
                    cameraEl: this
                })
            },
            update() {
                const e = this.data,
                    t = this.el.sceneEl.camera;
                Object.assign(t, {
                    aspect: e.aspect || window.innerWidth / window.innerHeight,
                    far: e.far,
                    fov: e.fov,
                    near: e.near,
                    zoom: e.zoom
                }), t.updateProjectionMatrix()
            },
            remove() {
                this.el.removeObject3D("camera")
            }
        })
    }, {
        "./directive": 34
    }],
    34: [function (e, t, n) {
        const i = e("../utils/schema"),
            r = e("../utils");
        let a = t.exports.directives = {};
        const s = i.parseProperties,
            o = i.parseProperty,
            l = r.styleParser;
        let c = {};
        var u = t.exports.Directive = function (e, t, n) {
            const a = this;
            a.el = e, a.id = n, a.attrName = a.name + (n ? "__" + n : ""), a.initialized = false, a.isSingleProperty = i.isSingleProperty(a.schema), a.isSinglePropertyObject = a.isSingleProperty && p(o(void 0, a.schema)) && !(a.schema.default instanceof window.HTMLElement), a.isObjectBased = !a.isSingleProperty || a.isSinglePropertyObject, a.el.directives[a.attrName] = a, a.objectPool = c[a.name];
            const s = a.events;
            a.events = {},
                function (e, t) {
                    for (let n in t) e.events[n] = t[n].bind(e)
                }(a, s), a.isObjectBased && (a.nextData = a.objectPool.use(), r.objectPool.removeUnusedKeys(a.nextData, a.schema), a.oldData = a.objectPool.use(), r.objectPool.removeUnusedKeys(a.oldData, a.schema), a.previousOldData = a.objectPool.use(), r.objectPool.removeUnusedKeys(a.previousOldData, a.schema), a.parsingAttrValue = a.objectPool.use(), r.objectPool.removeUnusedKeys(a.parsingAttrValue, a.schema)), a.updateProperties(t)
        };
        function h(e, t) {
            for (let n in t)
                if (t[n]) {
                    let i = t[n];
                    e[n] = f(i) ? r.clone(i) : i
                } return e
        }
        function d(e, t, n) {
            if (n && t && t.constructor && t.constructor === Object) {
                for (let n in t) t[n] && (t[n].constructor === Object ? e[n] = r.clone(t[n]) : e[n] = t[n]);
                return e
            }
            return t
        }
        function p(e) {
            return e && e.constructor === Object && !(e instanceof window.HTMLElement)
        }
        function f(e) {
            return e && (e.constructor === Object || e.constructor === Array) && !(e instanceof window.HTMLElement)
        }
        u.prototype = {
            schema: {},
            init() {},
            events: {},
            update(e) {},
            updateSchema() {},
            play() {},
            pause() {},
            remove() {},
            parse(e, t) {
                const n = this.schema;
                return this.isSingleProperty ? o(e, n) : s(l.parse(e), n, true, this.name, t)
            },
            stringify(e) {
                const t = this.schema;
                return "string" == typeof e ? e : this.isSingleProperty ? i.stringifyProperty(e, t) : (e = i.stringifyProperties(e, t), l.stringify(e))
            },
            updateCachedAttrValue(e, t) {
                if (void 0 === e) return;
                if (null === e) return this.isObjectBased && this.attrValue && this.objectPool.recycle(this.attrValue), void(this.attrValue = void 0);
                let n, i;
                if (e instanceof Object && !(e instanceof window.HTMLElement) ? (i = this.objectPool.use(), n = Object.assign(i, e)) : n = this.parseAttrValueForCache(e), this.isObjectBased && !t && this.attrValue)
                    for (let e in this.attrValue) void 0 === n[e] && (n[e] = this.attrValue[e]);
                this.isObjectBased && !this.attrValue && (this.attrValue = this.objectPool.use()), r.objectPool.clearObject(this.attrValue), this.attrValue = d(this.attrValue, n, this.isObjectBased), r.objectPool.clearObject(i)
            },
            parseAttrValueForCache(e) {
                let t;
                return "string" != typeof e ? e : (this.isSingleProperty ? (t = this.schema.parse(e), "string" == typeof t && (t = e)) : (r.objectPool.clearObject(this.parsingAttrValue), t = l.parse(e, this.parsingAttrValue)), t)
            },
            updateProperties(e, t) {
                this.el.hasLoaded ? (null !== e && (e = this.parseAttrValueForCache(e)), this.updateCachedAttrValue(e, t), this.initialized ? (this.updateDirective(e, t), this.callUpdateHandler()) : this.initDirective()) : this.updateCachedAttrValue(e)
            },
            initDirective() {
                let e = this.el.initializingDirectives;
                if (this.updateSchema(this.buildData(this.attrValue, false, true)), this.data = this.buildData(this.attrValue), e[this.name]) return;
                e[this.name] = true, this.init(), this.initialized = true, delete e[this.name], this.oldData = d(this.oldData, this.data, this.isObjectBased);
                let t = this.isObjectBased ? this.objectPool.use() : void 0;
                this.update(t), this.isObjectBased && this.objectPool.recycle(t), this.el.isPlaying && this.play(), this.el.emit("directiveinitialized", {
                    name: this.name
                }, false)
            },
            updateDirective(e, t) {
                let n = false;
                if (t) return this.updateSchema(this.buildData(this.attrValue, true, true)), void(this.data = this.buildData(this.attrValue, true, false));
                if (this.isSingleProperty) return this.isObjectBased && o(e, this.schema), void(this.data = e);
                if (s(e, this.schema, true, this.name), this.schemaChangeKeys.length)
                    for (let t in e)
                        if (this.schema[t].schemaChange) {
                            n = true;
                            break
                        } if (n) return this.updateSchema(this.buildData(this.attrValue, true, true)), void(this.data = this.buildData(this.attrValue, true, false));
                for (let t in e) e[t] && (this.data[t] = e[t])
            },
            callUpdateHandler() {
                this.previousOldData instanceof Object && r.objectPool.clearObject(this.previousOldData), this.isObjectBased ? h(this.previousOldData, this.oldData) : this.previousOldData = this.oldData;
                const e = !r.deepEqual(this.oldData, this.data);
                (this.isPositionRotationScale || e) && (this.oldData instanceof Object && r.objectPool.clearObject(this.oldData), this.oldData = d(this.oldData, this.data, this.isObjectBased), this.update(this.previousOldData))
            },
            resetProperty(e) {
                if (this.isObjectBased) {
                    if (!(e in this.attrValue)) return;
                    delete this.attrValue[e], this.data[e] = this.schema[e].default
                } else this.attrValue = this.schema.default, this.data = this.schema.default;
                this.updateProperties(this.attrValue)
            },
            extendSchema(e) {
                let t = Object.assign({}, a[this.name].schema);
                Object.assign(t, e), this.schema = i.process(t)
            },
            buildData(e, t, n) {
                let i, a = this.nextData;
                const l = this.schema;
                let c;
                if (this.isObjectBased && r.objectPool.clearObject(a), this.isSingleProperty) i = this.isObjectBased ? h(a, l.default) : f(l.default) ? r.clone(l.default) : l.default;
                else {
                    c = !t && this.attrValue, i = c instanceof Object ? h(a, c) : a;
                    for (let e in l) {
                        let t = l[e].default;
                        i[e] && (i[e] = f(t) ? r.clone(t) : t)
                    }
                }
                if (e && e.constructor === Array ? e.length : null != e) {
                    if (this.isSingleProperty) return p(e) ? (h(this.parsingAttrValue, e), o(this.parsingAttrValue, l)) : o(e, l);
                    i = d(i, e, this.isObjectBased)
                } else if (this.isSingleProperty) return o(i, l);
                return s(i, l, void 0, this.name, n)
            },
            eventsAttach() {
                this.eventsDetach();
                for (let e in this.events) this.el.addEventListener(e, this.events[e])
            },
            eventsDetach() {
                for (let e in this.events) this.el.removeEventListener(e, this.events[e])
            },
            destroy() {
                this.objectPool.recycle(this.attrValue), this.objectPool.recycle(this.oldData), this.objectPool.recycle(this.parsingAttrValue), this.attrValue = this.oldData = this.parsingAttrValue = void 0
            }
        }, t.exports.registerDirective = function (e, t) {
            if (!0 === new RegExp("[A-Z]+").test(e) && console.warn("The directive name `" + e + "` contains uppercase characters, but HTML will ignore the capitalization of attribute names. Change the name to be lowercase: `" + e.toLowerCase() + "`"), -1 !== e.indexOf("__")) throw new Error("The directive name `" + e + "` is not allowed. The sequence __ (double underscore) is reserved to specify an id for multiple directives of the same type");
            if (a[e]) throw new Error("The directive `" + e + "` has been already registered. Check that you are not loading two versions of the same directive or two different directives of the same name.");
            let n = function (e, t, n) {
                    u.call(this, e, t, n)
                },
                s = {};
            var o, l;
            Object.keys(t).forEach((function (e) {
                s[e] = {
                    value: t[e],
                    writable: true
                }
            })), (n.prototype = Object.create(u.prototype, s)).name = e, n.prototype.isPositionRotationScale = "position" === e || "rotation" === e || "scale" === e, n.prototype.constructor = n, n.prototype.play = (o = n.prototype.play, function () {
                this.initialized && this.el.isPlaying && !this.isPlaying && (o.call(this), this.isPlaying = true, this.eventsAttach(), this.tick && this.el.sceneEl.addToTickList(this))
            }), n.prototype.pause = (l = n.prototype.pause, function () {
                this.isPlaying && (l.call(this), this.isPlaying = false, this.eventsDetach(), this.el.sceneEl.removeFromTickList(this))
            });
            let h = Object.assign(i.process(n.prototype.schema, n.prototype.name)),
                d = i.isSingleProperty(n.prototype.schema);
            if (!d) {
                n.prototype.schemaChangeKeys = [];
                for (let e in h) h[e].schemaChange && n.prototype.schemaChangeKeys.push(e)
            }
            return c[e] = r.objectPool.createPool(), a[e] = {
                Directive: n,
                dependencies: n.prototype.dependencies,
                isSingleProp: d,
                multiple: n.prototype.multiple,
                name: e,
                parse: n.prototype.parse,
                parseAttrValueForCache: n.prototype.parseAttrValueForCache,
                schema: h,
                stringify: n.prototype.stringify,
                type: n.prototype.type
            }, n
        }
    }, {
        "../utils": 96,
        "../utils/schema": 100
    }],
    35: [function (e, t, n) {
        const i = e("../utils/geometries/geometry"),
            r = i.geometries,
            a = new THREE.BufferGeometry;
        let s = {};
        function o(e) {
            const t = JSON.stringify(e);
            let n = s[t];
            n && !--n.count && (n.geometry.dispose(), delete s[t])
        }
        t.exports.Directive = e("./directive").registerDirective("geometry", {
            schema: {
                primitive: {
                    default: "box",
                    oneOf: i.geometryNames,
                    schemaChange: true
                }
            },
            init() {
                this.geometry = null
            },
            update(e) {
                this.geometry && (o(e), this.geometry = null);
                let t = this.el.object3DMap.mesh;
                t || (t = new THREE.Mesh, this.el.setObject3D("mesh", t)), t.geometry = this.geometry = function (e) {
                    const t = JSON.stringify(e);
                    let n = s[t];
                    if (n) return n.count++, n.geometry; {
                        const n = (new r[e.primitive].Geometry).create(e);
                        return n.metadata = {
                            type: n.type,
                            parameters: n.parameters || {}
                        }, s[t] = {
                            geometry: n,
                            count: 1
                        }, s[t].geometry
                    }
                }(this.data)
            },
            remove() {
                this.el.object3DMap.mesh.geometry = a, o(this.data), this.geometry = null
            },
            updateSchema(e) {
                this.oldData && this.oldData.primitive && this.oldData.primitive === e.primitive || this.extendSchema(r[e.primitive].schema)
            }
        })
    }, {
        "../utils/geometries/geometry": 90,
        "./directive": 34
    }],
    36: [function (e, t, n) {
        let i = {};
        e("./directive").registerDirective("gltf-model", {
            schema: {
                src: {
                    type: "model"
                },
                backShadowOnly: {
                    type: "boolean",
                    default: true
                }
            },
            init() {
                this.isLoading = false, this.animations = [], this.loader = new THREE.GLTFLoader
            },
            tick(e, t) {
                return this.mixer && this.mixer.update(t), !this.isLoading
            },
            update() {
                const e = this;
                if (e.el.hasAttribute("if-shadows-enabled") && !window.axis.settings.shadows) return;
                if (e.el.hasAttribute("if-shadows-disabled") && window.axis.settings.shadows) return;
                const t = e.data.src;
                t && (e.isLoading = true, i[t] || (i[t] = new Promise(((n, i) => {
                    e.loader.load(t, (t => {
                        const i = e.model = t.scene || t.scenes[0];
                        e.animations = t.animations, n(i)
                    }), void 0, (e => {
                        const t = e && e.message ? e.message : "Failed to load glTF model";
                        i(t)
                    }))
                }))), i[t].then((t => {
                    e.remove();
                    const n = t.clone();
                    if (e.animations[0]) {
                        const t = e.mixer = new THREE.AnimationMixer(n);
                        e.animations.forEach((e => {
                            t.clipAction(e).play()
                        }))
                    }
                    e.data.backShadowOnly && n.traverse((e => {
                        e.material && (e.material.shadowSide = THREE.BackSide, e.material.needsUpdate = true)
                    })), e.el.setObject3D("mesh", n), setTimeout((() => {
                        e.isLoading = false
                    }), 100)
                }), console.warn))
            },
            remove() {
                this.model && this.el.removeObject3D("mesh")
            }
        })
    }, {
        "./directive": 34
    }],
    37: [function (e, t, n) {
        let i = {};
        function r(e, t, n) {
            return r => {
                e && (i[e] = r);
                var a = new THREE.PMREMGenerator(t.renderer);
                a.compileEquirectangularShader();
                const s = a.fromEquirectangular(r).texture;
                "selective" === n.envMap ? (t.environment = s, t.emit("hdrset")) : "scene" === n.envMap && (t.object3D.environment = s), n.background && (t.object3D.background = s), a.dispose()
            }
        }
        e("./directive").registerDirective("hdr-environment", {
            schema: {
                url: {
                    default: ""
                },
                background: {
                    default: true
                },
                envMap: {
                    default: "selective"
                }
            },
            update() {
                const e = this.data.url,
                    t = this.el;
                t.renderer ? e && (i[e] ? r(null, t, this.data)(i[e]) : (new THREE.RGBELoader).setDataType(THREE.UnsignedByteType).load(e, r(e, t, this.data))) : console.error("hdr-environment may only applied to the scene")
            }
        })
    }, {
        "./directive": 34
    }],
    38: [function (e, t, n) {
        const i = e("./directive").registerDirective;
        t.exports.Directive = i("if-shadows-enabled", {
            update() {
                this.el.hider.shadow = !window.axis.settings.shadows, this.el.calculateVisibility()
            }
        }), t.exports.Directive = i("if-shadows-disabled", {
            update() {
                this.el.hider.shadow = window.axis.settings.shadows, this.el.calculateVisibility()
            }
        })
    }, {
        "./directive": 34
    }],
    39: [function (e, t, n) {
        e("./camera"), e("./if-shadows"), e("./light"), e("./shadow"), e("./sound"), e("./look-at"), e("./position"), e("./rotation"), e("./scale"), e("./visible"), e("./interactor"), e("./look-controls"), e("./movement-controls"), e("./no-go"), e("./reticle"), e("./gltf-model"), e("./hdr-environment"), e("./inherit-hdr"), e("./obj-model"), e("./animation"), e("./geometry"), e("./line"), e("./material"), e("./text")
    }, {
        "./animation": 32,
        "./camera": 33,
        "./geometry": 35,
        "./gltf-model": 36,
        "./hdr-environment": 37,
        "./if-shadows": 38,
        "./inherit-hdr": 40,
        "./interactor": 41,
        "./light": 42,
        "./line": 43,
        "./look-at": 44,
        "./look-controls": 45,
        "./material": 46,
        "./movement-controls": 47,
        "./no-go": 48,
        "./obj-model": 49,
        "./position": 50,
        "./reticle": 51,
        "./rotation": 52,
        "./scale": 53,
        "./shadow": 54,
        "./sound": 55,
        "./text": 56,
        "./visible": 57
    }],
    40: [function (e, t, n) {
        e("./directive").registerDirective("inherit-hdr", {
            schema: {
                default: true
            },
            init() {
                const e = this,
                    t = e.el.sceneEl;
                e.materialSetter = () => {
                    t.environment && e.el.object3D && e.el.object3D.traverse((e => {
                        e.material && (e.material.envMap = t.environment, e.material.needsUpdate = true)
                    }))
                }, e.el.addEventListener("object3dset", e.materialSetter), t.addEventListener("hdrset", e.materialSetter)
            },
            remove() {
                this.el.addEventListener("object3dset", self.materialSetter), this.el.sceneEl.addEventListener("hdrset", self.materialSetter)
            }
        })
    }, {
        "./directive": 34
    }],
    41: [function (e, t, n) {
        t.exports.Directive = e("./directive").registerDirective("interactor", {
            schema: {
                fastTravel: {
                    type: "int",
                    default: 0
                },
                range: {
                    type: "int",
                    default: 0
                },
                hideReticle: {
                    type: "boolean",
                    default: false
                },
                keyBindings: {
                    type: "string",
                    default: ""
                }
            },
            update() {
                const e = this.el;
                ! function t(n) {
                    n.interactorEl && console.warn("Nested interactors are not supported and may lead to unexpected behavior"), n.interactorEl = e, [...n.children].forEach(t)
                }(e);
                (this.data.keyBindings ? this.data.keyBindings.split(",") : []).filter((e => ["W", "A", "S", "D"].includes(e.toUpperCase()))).length && console.warn("WASD keybindings are reserved.")
            },
            remove() {
                ! function e(t) {
                    t.interactorEl = null, [...t.children].forEach(e)
                }(this.el)
            }
        })
    }, {
        "./directive": 34
    }],
    42: [function (e, t, n) {
        var i = e("../utils"),
            r = e("./directive").registerDirective,
            a = THREE.MathUtils.degToRad;
        t.exports.Directive = r("light", {
            schema: {
                type: {
                    default: "directional",
                    oneOf: ["ambient", "directional", "hemisphere", "point", "spot"],
                    schemaChange: true
                },
                color: {
                    type: "color"
                },
                intensity: {
                    default: 1,
                    min: 0
                },
                groundColor: {
                    type: "color",
                    if: {
                        type: ["hemisphere"]
                    }
                },
                decay: {
                    default: 1,
                    if: {
                        type: ["point", "spot"]
                    }
                },
                distance: {
                    default: 0,
                    min: 0,
                    if: {
                        type: ["point", "spot"]
                    }
                },
                angle: {
                    default: 60,
                    if: {
                        type: ["spot"]
                    }
                },
                penumbra: {
                    default: 0,
                    min: 0,
                    max: 1,
                    if: {
                        type: ["spot"]
                    }
                },
                target: {
                    type: "selector",
                    if: {
                        type: ["spot", "directional"]
                    }
                },
                castShadow: {
                    default: false,
                    if: {
                        type: ["point", "spot", "directional"]
                    }
                },
                shadowBias: {
                    default: 0,
                    if: {
                        castShadow: true
                    }
                },
                shadowCameraFar: {
                    default: 500,
                    if: {
                        castShadow: true
                    }
                },
                shadowCameraFov: {
                    default: 90,
                    if: {
                        castShadow: true
                    }
                },
                shadowCameraNear: {
                    default: .5,
                    if: {
                        castShadow: true
                    }
                },
                shadowCameraBox: {
                    default: 0,
                    if: {
                        castShadow: true
                    }
                },
                shadowCameraTop: {
                    default: 5,
                    if: {
                        castShadow: true
                    }
                },
                shadowCameraRight: {
                    default: 5,
                    if: {
                        castShadow: true
                    }
                },
                shadowCameraBottom: {
                    default: -5,
                    if: {
                        castShadow: true
                    }
                },
                shadowCameraLeft: {
                    default: -5,
                    if: {
                        castShadow: true
                    }
                },
                shadowMapAccuracy: {
                    default: 512,
                    if: {
                        castShadow: true
                    }
                },
                shadowRadius: {
                    default: 1,
                    if: {
                        castShadow: true
                    }
                }
            },
            init() {
                this.light = null, this.defaultTarget = null
            },
            update(e) {
                const t = this,
                    n = t.data,
                    r = i.diff(n, e),
                    s = t.light;
                if (s && !("type" in r)) {
                    let e = false;
                    Object.keys(r).forEach((r => {
                        const o = n[r];
                        switch (r) {
                        case "color":
                            s.color.set(o), i.material.applyColorCorrection(s.color);
                            break;
                        case "groundColor":
                            s.groundColor.set(o), i.material.applyColorCorrection(s.groundColor);
                            break;
                        case "angle":
                            s.angle = a(o);
                            break;
                        case "target":
                            null === o ? "spot" !== n.type && "directional" !== n.type || (s.target = t.defaultTarget) : o.hasLoaded ? t.onSetTarget(o, s) : o.addEventListener("loaded", i.bind(t.onSetTarget, t, o, s));
                            break;
                        case "castShadow":
                        case "shadowBias":
                        case "shadowCameraFar":
                        case "shadowCameraFov":
                        case "shadowCameraNear":
                        case "shadowCameraTop":
                        case "shadowCameraRight":
                        case "shadowCameraBottom":
                        case "shadowCameraLeft":
                        case "shadowMapAccuracy":
                        case "shadowRadius":
                            e || (t.updateShadow(), e = true);
                            break;
                        default:
                            s[r] = o
                        }
                    }))
                } else t.setLight(n), t.updateShadow()
            },
            setLight(e) {
                const t = this.el,
                    n = this.getLight(e);
                n && (this.light && t.removeObject3D("light"), this.light = n, this.light.el = t, t.setObject3D("light", n), ["spot", "directional", "hemisphere"].includes(e.type) && t.object3DMap.light.translateY(-1), "spot" === e.type && (t.setObject3D("light-target", this.defaultTarget), t.object3DMap["light-target"].position.set(0, 0, -1)))
            },
            updateShadow() {
                const e = this.data,
                    t = this.light;
                if (t.castShadow = e.castShadow, !e.castShadow) return t;
                const n = t.shadow,
                    i = n.camera;
                n.bias = e.shadowBias, n.radius = e.shadowRadius, n.mapSize.height = e.shadowMapAccuracy, n.mapSize.width = e.shadowMapAccuracy, i.near = e.shadowCameraNear, i.far = e.shadowCameraFar, i instanceof THREE.OrthographicCamera ? (i.top = e.shadowCameraBox || e.shadowCameraTop, i.right = e.shadowCameraBox || e.shadowCameraRight, i.bottom = -e.shadowCameraBox || e.shadowCameraBottom, i.left = -e.shadowCameraBox || e.shadowCameraLeft) : i.fov = e.shadowCameraFov, i.updateProjectionMatrix()
            },
            getLight(e) {
                const t = new THREE.Color(e.color),
                    n = t.getHex(),
                    r = new THREE.Color(e.groundColor),
                    s = e.intensity,
                    o = e.type,
                    l = e.target;
                switch (i.material.applyColorCorrection(t), i.material.applyColorCorrection(r), o.toLowerCase()) {
                case "ambient":
                    return new THREE.AmbientLight(n, s);
                case "directional": {
                    const e = new THREE.DirectionalLight(n, s);
                    return this.defaultTarget = e.target, l && (l.hasLoaded ? this.onSetTarget(l, e) : l.addEventListener("loaded", i.bind(this.onSetTarget, this, l, e))), e
                }
                case "hemisphere":
                    return new THREE.HemisphereLight(n, r.getHex(), s);
                case "point":
                    return new THREE.PointLight(n, s, e.distance, e.decay);
                case "spot": {
                    const t = new THREE.SpotLight(n, s, e.distance, a(e.angle), e.penumbra, e.decay);
                    return this.defaultTarget = t.target, l && (l.hasLoaded ? this.onSetTarget(l, t) : l.addEventListener("loaded", i.bind(this.onSetTarget, this, l, t))), t
                }
                default:
                    console.warn("%s is not a valid light type. Choose from ambient, directional, hemisphere, point, spot.", o)
                }
            },
            onSetTarget(e, t) {
                t.target = e.object3D
            },
            remove() {
                const e = this.el;
                e.removeObject3D("light"), e.removeObject3D("cameraHelper")
            }
        })
    }, {
        "../utils": 96,
        "./directive": 34
    }],
    43: [function (e, t, n) {
        var i = e("./directive").registerDirective,
            r = e("../utils").material.applyColorCorrection;
        function a(e, t) {
            return !(!e || !t) && (e.x === t.x && e.y === t.y && e.z === t.z)
        }
        t.exports.Directive = i("line", {
            schema: {
                start: {
                    type: "vec3",
                    default: {
                        x: 0,
                        y: 0,
                        z: 0
                    }
                },
                end: {
                    type: "vec3",
                    default: {
                        x: 0,
                        y: 0,
                        z: 0
                    }
                },
                color: {
                    type: "color",
                    default: "#74BEC1"
                },
                opacity: {
                    type: "number",
                    default: 1
                },
                visible: {
                    default: true
                }
            },
            multiple: true,
            init() {
                const e = this.data,
                    t = this.material = new THREE.LineBasicMaterial({
                        color: e.color,
                        opacity: e.opacity,
                        transparent: e.opacity < 1,
                        visible: e.visible
                    }),
                    n = this.geometry = new THREE.BufferGeometry;
                n.setAttribute("position", new THREE.BufferAttribute(new Float32Array(6), 3)), r(t.color), this.line = new THREE.Line(n, t), this.el.setObject3D(this.attrName, this.line)
            },
            update(e) {
                const t = this.data,
                    n = this.geometry,
                    i = this.material;
                let s = false,
                    o = n.attributes.position.array;
                a(t.start, e.start) || (o[0] = t.start.x, o[1] = t.start.y, o[2] = t.start.z, s = true), a(t.end, e.end) || (o[3] = t.end.x, o[4] = t.end.y, o[5] = t.end.z, s = true), s && (n.attributes.position.needsUpdate = true, n.computeBoundingSphere()), i.color.setStyle(t.color), r(i.color), i.opacity = t.opacity, i.transparent = t.opacity < 1, i.visible = t.visible
            },
            remove() {
                this.el.removeObject3D("line", this.line)
            }
        })
    }, {
        "../utils": 96,
        "./directive": 34
    }],
    44: [function (e, t, n) {
        t.exports.Directive = e("./directive").registerDirective("look-at", {
            schema: {
                type: "vec3"
            },
            update() {
                const e = this.data,
                    t = this.el.object3D;
                "A-LIGHT" === this.el.tagName ? t.lookAt(2 * t.position.x - e.x, 2 * t.position.y - e.y, 2 * t.position.z - e.z) : t.lookAt(e.x, e.y, e.z)
            }
        })
    }, {
        "./directive": 34
    }],
    45: [function (e, t, n) {
        const i = window.axis.settings;
        let r, a = {},
            s = {},
            o = 0,
            l = 0,
            c = false,
            u = false,
            h = false;
        function d() {
            r.style.cursor = "wait", u = true, setTimeout((() => {
                r.style.cursor = "", u && r.requestPointerLock()
            }), 200)
        }
        function p(e) {
            "Escape" === e.key && (u = false)
        }
        function f(e) {
            console.log('window.axis', window.axis);
            console.log('values', e);
            console.log(r, a, s, o, l, c, u, h);
            e.button || !r || c || (r.requestPointerLock ? r.requestPointerLock() : r.mozRequestPointerLock && r.mozRequestPointerLock())
        }
        function m(e) {
            if (c && !h) {
                let t = e.movementX || e.mozMovementX || 0;
                Math.abs(t) > window.innerWidth / 3 && (t = 0);
                let n = e.movementY || e.mozMovementY || 0;
                Math.abs(n) > window.innerHeight / 3 && (n = 0), l += -.001 * t * i.sensitivityX, o += n * (i.invertY ? .001 : -.001) * i.sensitivityY, o = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, o))
            }
        }
        function g() {
            c = !(!document.pointerLockElement && !document.mozPointerLockElement), c && a.activityThrottle()
        }
        function v(e) {
            console.log('window.axis 2', window.axis);
            console.log('values', e);
            const t = e + "EventListener";
            r[t]("mousedown", f, false), window[t]("mousemove", m, false), document[t]("pointerlockchange", g, false), document[t]("mozpointerlockchange", g, false), document[t]("pointerlockerror", d), window[t]("keydown", p)
        }
        function y() {
            v("remove"), document.exitPointerLock()
        }
        t.exports.Directive = e("./directive").registerDirective("look-controls", {
            dependencies: ["position", "rotation"],
            schema: {},
            init() {
                if (a = this.el.sceneEl, r = a.canvas, o = 0, l = 0, a.id) {
                    let t = `${a.id}-rotation`,
                        n = localStorage.getItem(t);
                    if (n && i.rememberPosition) {
                        let e = JSON.parse(n);
                        o = e.pitch, l = e.yaw
                    }
                    this.changeThrottle = e("../utils").throttle((() => {
                        localStorage.setItem(t, JSON.stringify({
                            pitch: o,
                            yaw: l
                        }))
                    }), 250)
                }
                console.log('window.axis 3', window.axis);
                console.log('this', this);
            },
            promiseAnalytics: e => { return true},
            tick() {
                let e = this.el.object3D.rotation;
                if (e.x = o, e.y = l, e.x === s.x && e.y === s.y) return true;
                this.changeThrottle && this.changeThrottle(), s = (({
                    x: e,
                    y: t
                }) => ({
                    x: e,
                    y: t
                }))(e)
            },
            play() {
                const e = () => {
                    v("add")
                };
                r ? e() : a.addEventListener("render-target-loaded", e)
            },
            pause: y,
            remove: y
        })
    }, {
        "../utils": 96,
        "./directive": 34
    }],
    46: [function (e, t, n) {
        const i = e("../utils/shaders/shader"),
            r = i.shaders;
        function a(e, t) {
            e.dispose(), t.unregisterMaterial(e)
        }
        t.exports.Directive = e("./directive").registerDirective("material", {
            schema: {
                alphaTest: {
                    default: 0,
                    min: 0,
                    max: 1
                },
                depthTest: {
                    default: true
                },
                depthWrite: {
                    default: true
                },
                flatShading: {
                    default: false
                },
                npot: {
                    default: false
                },
                offset: {
                    type: "vec2",
                    default: {
                        x: 0,
                        y: 0
                    }
                },
                opacity: {
                    default: 1,
                    min: 0,
                    max: 1
                },
                repeat: {
                    type: "vec2",
                    default: {
                        x: 1,
                        y: 1
                    }
                },
                shader: {
                    default: "standard",
                    oneOf: i.shaderNames,
                    schemaChange: true
                },
                side: {
                    default: "front",
                    oneOf: ["front", "back", "double"]
                },
                transparent: {
                    default: false
                },
                vertexColors: {
                    type: "string",
                    default: "none",
                    oneOf: ["face", "vertex"]
                },
                visible: {
                    default: true
                },
                blending: {
                    default: "normal",
                    oneOf: ["none", "normal", "additive", "subtractive", "multiply"]
                },
                dithering: {
                    default: true
                }
            },
            init() {
                this.material = null
            },
            update(e) {
                const t = this.data;
                this.shader && t.shader === e.shader || this.updateShader(t.shader), this.shader.update(this.data), this.updateMaterial(e)
            },
            updateSchema(e) {
                const t = e && e.shader,
                    n = this.oldData && this.oldData.shader;
                if (n && t === n) return;
                const i = t || n,
                    a = r[i] && r[i].schema;
                a || console.warn("Unknown shader schema " + i), this.extendSchema(a), this.updateBehavior()
            },
            updateBehavior() {
                let e = this.el.sceneEl;
                if (!e) return;
                const t = this;
                function n(e) {
                    for (let t in r) r[t] = e;
                    t.shader.update(r)
                }
                t.tick = void 0;
                const i = t.schema;
                let r = {};
                for (let e in i) "time" === i[e].type && (t.tick = n, r[e] = true);
                t.tick ? e.addToTickList(t) : e.removeFromTickList(t)
            },
            updateShader(e) {
                const t = r[e] && r[e].Shader;
                if (!t) throw new Error("Unknown shader " + e);
                let n = this.shader = new t;
                n.el = this.el, n.init(this.data), this.setMaterial(n.material), this.updateSchema(this.data)
            },
            updateMaterial(e) {
                const t = this.data;
                let n = this.material;
                n.alphaTest = t.alphaTest, n.depthTest = !1 !== t.depthTest, n.depthWrite = !1 !== t.depthWrite, n.opacity = t.opacity, n.flatShading = t.flatShading, n.side = function (e) {
                    switch (e) {
                    case "back":
                        return THREE.BackSide;
                    case "double":
                        return THREE.DoubleSide;
                    default:
                        return THREE.FrontSide
                    }
                }(t.side), n.transparent = !1 !== t.transparent || t.opacity < 1, n.vertexColors = function (e) {
                    switch (e) {
                    case "face":
                        return THREE.FaceColors;
                    case "vertex":
                        return THREE.VertexColors;
                    default:
                        return THREE.NoColors
                    }
                }(t.vertexColors), n.visible = t.visible, n.blending = function (e) {
                    switch (e) {
                    case "none":
                        return THREE.NoBlending;
                    case "additive":
                        return THREE.AdditiveBlending;
                    case "subtractive":
                        return THREE.SubtractiveBlending;
                    case "multiply":
                        return THREE.MultiplyBlending;
                    default:
                        return THREE.NormalBlending
                    }
                }(t.blending), n.dithering = t.dithering, !Object.keys(e).length || e.alphaTest === t.alphaTest && e.side === t.side && e.vertexColors === t.vertexColors || (n.needsUpdate = true)
            },
            remove() {
                const e = this.el.object3DMap.mesh;
                e && (e.material = new THREE.MeshBasicMaterial), a(this.material, this.system)
            },
            setMaterial(e) {
                let t = this.el,
                    n = this.system;
                this.material && a(this.material, n), this.material = e;
                let i = t.object3DMap.mesh;
                i ? i.material = e : t.addEventListener("object3dset", (function n(i) {
                    "mesh" === i.detail.type && i.target === t && (t.object3DMap.mesh.material = e, t.removeEventListener("object3dset", n))
                }))
            }
        })
    }, {
        "../utils/shaders/shader": 106,
        "./directive": 34
    }],
    47: [function (e, t, n) {
        const i = window.axis.settings;
        let r, a, s, o, l, c = {},
            u = {},
            h = new THREE.Vector3,
            d = {},
            p = false,
            f = new THREE.Vector3;
        const m = window.axis.noGoZones;
        function g() {
            a = true, s && clearTimeout(s), s = setTimeout((function () {
                a = false
            }), 5e3)
        }
        function v(e) {
            delete d[e.code]
        }
        function y(e) {
            ["KeyW", "KeyA", "KeyS", "KeyD", "KeyX", "Space"].includes(e.code) && (d[e.code] = true)
        }
        function x() {
            _(!(!document.pointerLockElement && !document.mozPointerLockElement) ? "add" : "remove")()
        }
        function b(e) {
            return function () {
                "add" === e && g(), document[e + "EventListener"]("pointerlockchange", x, false), document[e + "EventListener"]("mozpointerlockchange", x, false), "remove" === e && _(e)()
            }
        }
        function _(e) {
            return function () {
                "remove" === e && (d = {}), window[e + "EventListener"]("keydown", y), window[e + "EventListener"]("keyup", v)
            }
        }
        function w() {
            p && (p = false, f.x = f.y = f.z = 0, E())
        }
        function E() {
            h.x = h.y = h.z = 0, clearTimeout(o), clearTimeout(l)
        }
        g(), window.axis.moveTo = (e, t, n = 0) => {
            const a = c.floor,
                s = r.distanceTo(new THREE.Vector3(e, a, t));
            if (s <= n) return;
            p = true, E();
            const u = (s - n) / s;
            f.x = 16 * (e - r.x) * u, f.y = 16 * (a - r.y) * (i.gravity ? 1 : u), f.z = 16 * (t - r.z) * u, o = setTimeout((function () {
                f = f.multiplyScalar(-1)
            }), 250), l = setTimeout((function () {
                f.x = f.y = f.z = 0, p = false
            }), 500)
        }, t.exports.Directive = e("./directive").registerDirective("movement-controls", {
            schema: {
                acceleration: {
                    default: 65
                },
                xBoundary: {
                    default: 300
                },
                floor: {
                    default: 0
                },
                ceiling: {
                    default: 100
                },
                zBoundary: {
                    default: 300
                }
            },
            init() {
                if (c = this.data, u = this.el, r = u.object3D.position, window.addEventListener("load", g), window.addEventListener("resize", g), u.sceneEl.id) {
                    const t = `${u.sceneEl.id}-position`,
                        n = localStorage.getItem(t);
                    if (n && i.rememberPosition) {
                        const e = JSON.parse(n);
                        r.x = e.x, r.y = e.y, r.z = e.z
                    }
                    this.changeThrottle = e("../utils").throttle((function () {
                        localStorage.setItem(t, JSON.stringify(r))
                    }), 250)
                }
                console.log('loading 1')
                g(window);
            },
            tick(e, t) {
                let n = i.gravity && u.object3D.position.y !== c.floor;
                if (h.x || h.y || h.z || Object.keys(d).length || n || p) {
                    if (function (e) {
                            if (p)["x", "y", "z"].forEach((t => {
                                h[t] += f[t] * e
                            }));
                            else {
                                ["x", "y", "z"].forEach((t => {
                                    const n = "y" === t && i.gravity && h[t] < 0;
                                    h[t] && !n && (h[t] = h[t] * Math.pow(1 / 1.1, 60 * e)), Math.abs(h[t]) < .5 && (h[t] = 0)
                                }));
                                const t = c.acceleration * e * i.speedMultiplier;
                                d.KeyA && (h.x -= t), d.KeyD && (h.x += t), d.KeyW && (h.z -= t), d.KeyS && (h.z += t), d.KeyX && (h.y -= t), d.Space ? h.y += t : i.gravity && (h.y -= 100 * i.gravity * e)
                            }
                        }(t), h.x || h.y || h.z) {
                        let e = function (e) {
                            const t = u.object3D.rotation;
                            let n = (new THREE.Vector3).copy(h).multiplyScalar(e);
                            if (t && !p) {
                                const e = n.y;
                                n.y = 0, n.applyEuler(new THREE.Euler(!i.gravity && t.x || 0, t.y, 0, "YXZ")), n.y += e
                            }
                            return n
                        }(t);
                        if (["x", "z"].forEach((t => {
                                const n = r[t],
                                    i = c[t + "Boundary"];
                                Math.abs(n + e[t]) > i && (r[t] > 0 ? e[t] = -n + i : e[t] = -n - i, w())
                            })), r.y + e.y < c.floor && (e.y = -r.y + c.floor, d.Space || (h.y = 0), w()), r.y + e.y > c.ceiling && (e.y = -r.y + c.ceiling, h.y = 0, w()), m)
                            for (let t in m) {
                                const n = t.split(","),
                                    i = parseInt(n[0]),
                                    a = parseInt(n[1]),
                                    s = r.x + e.x - i,
                                    o = r.z + e.z - a,
                                    l = s * s + o * o,
                                    c = m[t];
                                if (l < c * c) {
                                    let t = i,
                                        n = a + c;
                                    if (s || o) {
                                        const e = c / Math.sqrt(l);
                                        t = i + e * s, n = a + e * o
                                    }
                                    e.x = t - r.x, e.z = n - r.z, w()
                                }
                            }
                        r.add(e), this.changeThrottle && this.changeThrottle()
                    }
                    a = false
                } else if (!a) return true
            },
            play: b("add"),
            pause: b("remove"),
            remove: b("remove")
        })
    }, {
        "../utils": 96,
        "./directive": 34
    }],
    48: [function (e, t, n) {
        t.exports.Directive = e("./directive").registerDirective("no-go", {
            schema: {
                type: "int",
                min: 1,
                default: 30
            },
            init() {
                const e = this.el.object3D.position,
                    t = e.x.toFixed(0),
                    n = e.z.toFixed(0);
                window.axis.noGoZones[`${t},${n}`] = this.data
            },
            remove() {}
        })
    }, {
        "./directive": 34
    }],
    49: [function (e, t, n) {
        var i = e("../utils/material").applyColorCorrection;
        e("./directive").registerDirective("obj-model", {
            schema: {
                mtl: {
                    type: "model"
                },
                obj: {
                    type: "model"
                }
            },
            init() {
                const e = this;
                e.model = null, e.objLoader = new THREE.OBJLoader, e.mtlLoader = new THREE.MTLLoader(e.objLoader.manager), e.mtlLoader.crossOrigin = "", e.el.addEventListener("directiveinitialized", (t => {
                    e.model && "material" === t.detail.name && e.applyMaterial()
                }))
            },
            update() {
                const e = this.data;
                e.obj && (this.remove(), e.mtl ? this.loadObjWithMtl(e.obj, e.mtl) : this.loadObjOnly(e.obj))
            },
            remove() {
                this.model && this.el.removeObject3D("mesh")
            },
            loadObjOnly(e) {
                const t = this;
                t.objLoader.load(e, (e => {
                    t.model = e, t.applyMaterial(), t.el.setObject3D("mesh", e)
                }))
            },
            loadObjWithMtl(e, t) {
                const n = this,
                    r = n.el;
                r.hasAttribute("material") && console.warn("Material directive properties are ignored when a .MTL is provided"), n.mtlLoader.setResourcePath(t.substr(0, t.lastIndexOf("/") + 1)).load(t, (t => {
                    t.preload(), n.objLoader.setMaterials(t).load(e, (e => {
                        n.model = e, n.model.traverse((e => {
                            if (e.isMesh) {
                                const t = e.material;
                                t.color && i(t.color), t.map && i(t.map), t.emissive && i(t.emissive), t.emissiveMap && i(t.emissiveMap)
                            }
                        })), r.setObject3D("mesh", e)
                    }))
                }))
            },
            applyMaterial() {
                const e = this.el.directives.material;
                e && this.model.traverse((t => {
                    t instanceof THREE.Mesh && (t.material = e.material)
                }))
            }
        })
    }, {
        "../utils/material": 97,
        "./directive": 34
    }],
    50: [function (e, t, n) {
        t.exports.Directive = e("./directive").registerDirective("position", {
            schema: {
                type: "vec3"
            },
            update() {
                const e = this.data;
                e && this.el.object3D.position.set(e.x, e.y, e.z)
            }
        })
    }, {
        "./directive": 34
    }],
    51: [function (e, t, n) {
        const i = new THREE.Raycaster,
            r = new MutationObserver((() => {
                g = true
            }));
        let a, s, o, l, c, u, h, d, p, f = new THREE.Vector3,
            m = [],
            g = true;
        function v(e = null, t = 0, n = 0, i = true, r = false, a = []) {
            l = e, c = t, u = n, h = i, d = r, p = a
        }
        function y(e) {
            l.object.el.interactorEl.emit(e, {
                intersection: l
            })
        }
        function x() {
            const e = a.object3D;
            e.updateMatrixWorld(), f.setFromMatrixPosition(e.matrixWorld), i.set(f, new THREE.Vector3(0, 0, -1).transformDirection(e.matrixWorld).normalize())
        }
        function b(e) {
            g && (m = [], s.querySelectorAll("[interactor]").forEach((e => {
                e.object3D && m.push(e.object3D)
            })), g = false), x();
            let t = i.intersectObjects(m, true)[0];
            (l || t) && (l && !t ? S() : !l && t ? M(t) : l.object.el?.interactorEl !== t.object.el?.interactorEl ? (S(), M(t)) : (e || u) && (l.distance = t.distance, l.point = t.point, u && T()))
        }
        function _() {
            (document.pointerLockElement || document.mozPointerLockElement) && (b(true), o = l)
        }
        function w(e) {
            if (o) {
                if (l && o === l && (h && (0 === e.button ? y("click") : 2 === e.button ? y("rightclick") : y("middleclick")), 2 === e.button && c)) {
                    const e = l.point;
                    window.axis.moveTo(e.x, e.z, c)
                }
                o = null
            }
        }
        function E(e) {
            e.metaKey || document.activeElement !== document.body || ["KeyW", "KeyA", "KeyS", "KeyD"].includes(e.code) || h && p.includes(e.code) && y("press" + e.code.replace("Digit", "").replace("Key", ""))
        }
        function M(e) {
            const t = e.object.el.interactorEl.directives.interactor.data,
                n = (t.keyBindings ? t.keyBindings.split(",") : []).map((e => (isNaN(parseInt(e)) ? "Key" : "Digit") + e.toUpperCase()));
            v(e, t.fastTravel, t.range, !t.range, t.hideReticle, n), u ? T() : A()
        }
        function T() {
            const e = l.distance <= u;
            h && !e && (L(), h = false), !h && e && (A(), h = true)
        }
        function S() {
            l && (u ? h && L() : L(), v())
        }
        function A() {
            y("reticleenter"), d && (a.object3D.visible = false)
        }
        function L() {
            y("reticleleave"), a.object3D.visible = true
        }
        v(), t.exports.Directive = e("./directive").registerDirective("reticle", {
            schema: {
                far: {
                    default: 3e3
                },
                near: {
                    default: 0
                }
            },
            init() {
                a = this.el, s = a.sceneEl, x(), this.intersectionThrottle = e("../utils").throttle(b, 100, this)
            },
            update() {
                i.far = this.data.far, i.near = this.data.near
            },
            tick() {
                this.intersectionThrottle()
            },
            play: function () {
                r.observe(s, {
                        childList: true,
                        attributes: true,
                        subtree: true
                    }), window.addEventListener("keydown", E),
                    function e() {
                        const t = s.canvas;
                        t ? (t.addEventListener("mousedown", _), t.addEventListener("mouseup", w)) : s.addEventListener("render-target-loaded", e)
                    }()
            },
            pause: function () {
                const e = s.canvas.removeEventListener;
                e("mousedown", _), e("mouseup", w), window.removeEventListener("keydown", E), r.disconnect()
            },
            remove() {
                S(), a = s = o = null
            }
        })
    }, {
        "../utils": 96,
        "./directive": 34
    }],
    52: [function (e, t, n) {
        const i = THREE.MathUtils.degToRad;
        t.exports.Directive = e("./directive").registerDirective("rotation", {
            schema: {
                type: "vec3"
            },
            update() {
                const e = this.data;
                if (e) {
                    const t = this.el.object3D.rotation;
                    t.set(i(e.x), i(e.y), i(e.z)), t.order = "YXZ"
                }
            }
        })
    }, {
        "./directive": 34
    }],
    53: [function (e, t, n) {
        const i = 1e-5;
        t.exports.Directive = e("./directive").registerDirective("scale", {
            schema: {
                type: "vec3",
                default: {
                    x: 1,
                    y: 1,
                    z: 1
                }
            },
            update() {
                const e = this.data,
                    t = 0 === e.x ? i : e.x,
                    n = 0 === e.y ? i : e.y,
                    r = 0 === e.z ? i : e.z;
                this.el.object3D.scale.set(t, n, r)
            }
        })
    }, {
        "./directive": 34
    }],
    54: [function (e, t, n) {
        t.exports.Directive = e("./directive").registerDirective("shadow", {
            schema: {
                cast: {
                    default: true
                },
                receive: {
                    default: true
                }
            },
            init() {
                this.onMeshChanged = e("../utils").bind(this.update, this), this.el.addEventListener("object3dset", this.onMeshChanged)
            },
            update() {
                this.updateDescendants(this.data.cast, this.data.receive)
            },
            remove() {
                this.el.removeEventListener("object3dset", this.onMeshChanged), this.updateDescendants(false, false)
            },
            updateDescendants(e, t) {
                const n = this.el.sceneEl;
                this.el.object3D.traverse((i => {
                    if (i instanceof THREE.Mesh && (i.castShadow = e, i.receiveShadow = t, n.hasLoaded && i.material)) {
                        (Array.isArray(i.material) ? i.material : [i.material]).forEach((e => {
                            e.needsUpdate = true
                        }))
                    }
                }))
            }
        })
    }, {
        "../utils": 96,
        "./directive": 34
    }],
    55: [function (e, t, n) {
        t.exports.Directive = e("./directive").registerDirective("sound", {
            schema: {
                autoplay: {
                    default: false
                },
                distanceModel: {
                    default: "inverse",
                    oneOf: ["linear", "inverse", "exponential"]
                },
                loop: {
                    default: false
                },
                maxDistance: {
                    default: 1e4
                },
                on: {
                    default: ""
                },
                poolSize: {
                    default: 1
                },
                positional: {
                    default: true
                },
                refDistance: {
                    default: 1
                },
                rolloffFactor: {
                    default: 1
                },
                src: {
                    type: "audio"
                },
                volume: {
                    default: 1
                }
            },
            multiple: true,
            init() {
                const e = this;
                e.audioLoader = new THREE.AudioLoader, e.pool = new THREE.Group, e.loaded = false, e.mustPlay = false, e.playSoundBound = function () {
                    e.playSound()
                }
            },
            update(e) {
                const t = this,
                    n = t.data,
                    i = n.src !== e.src;
                if (i) {
                    if (!n.src) return;
                    t.setupSound()
                }
                t.pool.children.forEach((e => {
                    n.positional && (e.setDistanceModel(n.distanceModel), e.setMaxDistance(n.maxDistance), e.setRefDistance(n.refDistance), e.setRolloffFactor(n.rolloffFactor)), e.setLoop(n.loop), e.setVolume(n.volume), e.isPaused = false
                })), n.on !== e.on && t.updateEventListener(e.on), i && (t.loaded = false, t.audioLoader.load(n.src, (e => {
                    t.pool.children.forEach((t => {
                        t.setBuffer(e)
                    })), t.loaded = true, THREE.Cache.remove(n.src), (t.data.autoplay || t.mustPlay) && t.playSound()
                })))
            },
            pause() {
                this.stopSound(), this.removeEventListener()
            },
            play() {
                this.data.autoplay && this.playSound(), this.updateEventListener()
            },
            remove() {
                this.removeEventListener(), this.el.object3DMap[this.attrName] && this.el.removeObject3D(this.attrName);
                try {
                    this.pool.children.forEach((e => {
                        e.disconnect()
                    }))
                } catch (e) {
                    console.log("Audio source not properly disconnected")
                }
            },
            updateEventListener(e) {
                e && this.el.removeEventListener(e, this.playSoundBound), this.el.addEventListener(this.data.on, this.playSoundBound)
            },
            removeEventListener() {
                this.el.removeEventListener(this.data.on, this.playSoundBound)
            },
            setupSound() {
                const e = this;
                let t = e.el,
                    n = t.sceneEl;
                e.pool.children.length && (e.stopSound(), t.removeObject3D("sound"));
                const i = n.audioListener || new THREE.AudioListener;
                n.audioListener = i, n.camera && n.camera.add(i), n.addEventListener("camera-set-active", (function (e) {
                    e.detail.cameraEl.object3DMap.camera.add(i)
                })), e.pool = new THREE.Group;
                for (let t = 0; t < e.data.poolSize; t++) {
                    const t = e.data.positional ? new THREE.PositionalAudio(i) : new THREE.Audio(i);
                    e.pool.add(t)
                }
                t.setObject3D(e.attrName, e.pool), e.pool.children.forEach((t => {
                    t.onEnded = function () {
                        e.isPlaying = false
                    }
                }), e)
            },
            playSound(e) {
                if (!this.loaded) return console.log("Sound not loaded yet. It will be played once it finished loading"), void(this.mustPlay = true);
                this.isPlaying = true;
                let t = false;
                this.pool.children.forEach((n => {
                    n.isPlaying || !n.buffer || t || (e && e(n), n.play(), n.isPaused = false, t = true)
                })), t && (this.mustPlay = false)
            },
            stopSound() {
                this.isPlaying = false, this.pool.children.forEach((e => {
                    e.source && e.source.buffer && e.stop()
                }))
            }
        })
    }, {
        "./directive": 34
    }],
    56: [function (e, t, n) {
        const i = e("../utils/shaders/shader").shaders,
            r = "https://cdn.aframe.io/fonts/",
            a = {
                aileronsemibold: r + "Aileron-Semibold.fnt",
                dejavu: r + "DejaVu-sdf.fnt",
                exo2bold: r + "Exo2Bold.fnt",
                exo2semibold: r + "Exo2SemiBold.fnt",
                kelsonsans: r + "KelsonSans.fnt",
                monoid: r + "Monoid.fnt",
                mozillavr: r + "mozillavr.fnt",
                roboto: r + "Roboto-msdf.json",
                sourcecodepro: r + "SourceCodePro.fnt"
            };
        var s = "roboto";
        t.exports.FONTS = a;
        const o = new function () {
                const e = this.cache = {};
                this.get = (t, n) => (t in e || (e[t] = n()), e[t])
            },
            l = {},
            c = {};
        var u = /^\w+:/;
        e("./directive").registerDirective("text", {
            multiple: true,
            schema: {
                align: {
                    type: "string",
                    default: "left",
                    oneOf: ["left", "right", "center"]
                },
                alphaTest: {
                    default: .5
                },
                anchor: {
                    default: "center",
                    oneOf: ["left", "right", "center", "align"]
                },
                baseline: {
                    default: "center",
                    oneOf: ["top", "center", "bottom"]
                },
                color: {
                    type: "color",
                    default: "#FFF"
                },
                font: {
                    type: "string",
                    default: s
                },
                fontImage: {
                    type: "string"
                },
                height: {
                    type: "number"
                },
                letterSpacing: {
                    type: "number",
                    default: 0
                },
                lineHeight: {
                    type: "number"
                },
                negate: {
                    type: "boolean",
                    default: true
                },
                opacity: {
                    type: "number",
                    default: 1
                },
                shader: {
                    default: "sdf",
                    oneOf: i
                },
                side: {
                    default: "front",
                    oneOf: ["front", "back", "double"]
                },
                tabSize: {
                    default: 4
                },
                transparent: {
                    default: true
                },
                value: {
                    type: "string"
                },
                whiteSpace: {
                    default: "normal",
                    oneOf: ["normal", "pre", "nowrap"]
                },
                width: {
                    type: "number"
                },
                wrapCount: {
                    type: "number",
                    default: 40
                },
                wrapPixels: {
                    type: "number"
                },
                xOffset: {
                    type: "number",
                    default: 0
                },
                yOffset: {
                    type: "number",
                    default: 0
                },
                zOffset: {
                    type: "number",
                    default: .001
                }
            },
            init() {
                this.shaderData = {}, this.geometry = e("three-bmfont-text")(), this.createOrUpdateMaterial(), this.mesh = new THREE.Mesh(this.geometry, this.material), this.el.setObject3D(this.attrName, this.mesh)
            },
            update(e) {
                const t = this.data;
                c[t.font] ? this.texture = c[t.font] : (this.texture = c[t.font] = new THREE.Texture, this.texture.anisotropy = 16), this.createOrUpdateMaterial(), e.font === t.font ? this.currentFont && (this.updateGeometry(this.geometry, this.currentFont), this.updateLayout()) : this.updateFont()
            },
            remove() {
                this.geometry.dispose(), this.geometry = null, this.el.removeObject3D(this.attrName), this.material.dispose(), this.material = null, this.texture.dispose(), this.texture = null, this.shaderObject && delete this.shaderObject
            },
            createOrUpdateMaterial() {
                const e = this.data,
                    t = this.shaderData;
                let n;
                if (n = "roboto" === e.font || e.font.indexOf("-msdf.") >= 0 ? "msdf" : e.font in a && "roboto" !== e.font ? "sdf" : e.shader, t.alphaTest = e.alphaTest, t.color = e.color, t.map = this.texture, t.opacity = e.opacity, t.side = function (e) {
                        switch (e) {
                        case "back":
                            return THREE.FrontSide;
                        case "double":
                            return THREE.DoubleSide;
                        default:
                            return THREE.BackSide
                        }
                    }(e.side), t.transparent = e.transparent, t.negate = e.negate, this.shaderObject?.name === n) this.shaderObject.update(t), this.material.transparent = t.transparent, this.material.side = t.side;
                else {
                    const e = function (e, t, n) {
                        const r = new i[t].Shader;
                        r.el = e, r.init(n), r.update(n);
                        const a = r.material;
                        return a.transparent = n.transparent, {
                            material: a,
                            shader: r
                        }
                    }(this.el, n, t);
                    this.material = e.material, this.shaderObject = e.shader, this.material.side = t.side, this.mesh && (this.mesh.material = this.material)
                }
            },
            updateFont() {
                const t = this,
                    n = t.data.font;
                n || console.warn("No font specified. Using the default font."), t.mesh.visible = false;
                const i = a[n || s] || n;
                o.get(i, (() => {
                    return n = i, r = t.data.yOffset, new Promise(((t, i) => {
                        e("load-bmfont")(n, ((e, a) => {
                            e ? (console.warn("Error loading font", n), i(e)) : (n.indexOf("/Roboto-msdf.json") >= 0 && (r = 30), r && a.chars.map((function (e) {
                                e.yoffset += r
                            })), t(a))
                        }))
                    }));
                    var n, r
                })).then((e => {
                    if (1 !== e.pages.length) throw new Error("Currently only single-page bitmap fonts are supported.");
                    l[i] || (e.widthFactor = l[e] = function (e) {
                        let t = 0,
                            n = 0,
                            i = 0;
                        return e.chars.map((e => {
                            t += e.xadvance, e.id >= 48 && e.id <= 57 && (i++, n += e.xadvance)
                        })), i ? n / i : t / e.chars.length
                    }(e)), t.updateGeometry(t.geometry, e), t.currentFont = e, t.updateLayout();
                    const n = t.getFontImageSrc();
                    o.get(n, (() => {
                        return e = n, new Promise(((t, n) => {
                            (new THREE.ImageLoader).load(e, (e => {
                                t(e)
                            }), void 0, (() => {
                                console.warn("Error loading font image", e), n(null)
                            }))
                        }));
                        var e
                    })).then((n => {
                        const i = t.texture;
                        i.image = n, i.needsUpdate = true, c[e] = t.texture = i, t.mesh.visible = true
                    })).catch((e => {
                        console.warn(e.message), console.warn(e.stack)
                    }))
                })).catch((e => {
                    console.warn(e.message), console.warn(e.stack)
                }))
            },
            getFontImageSrc() {
                if (this.data.fontImage) return this.data.fontImage;
                const e = a[this.data.font || s] || this.data.font,
                    t = this.currentFont.pages[0];
                return t.match(u) && 0 !== t.indexOf("http") ? e.replace(/(\.fnt)|(\.json)/, ".png") : THREE.LoaderUtils.extractUrlBase(e) + t
            },
            updateLayout() {
                const e = this.data,
                    t = this.geometry.layout;
                if (!t) return;
                const n = this.el.getAttribute("geometry"),
                    i = e.width || n && n.width || 1,
                    r = i / h(e.wrapPixels, e.wrapCount, this.currentFont.widthFactor),
                    a = r * (t.height + t.descender);
                n && "plane" === n.primitive && (n.width || this.el.setAttribute("geometry", "width", i), n.height || this.el.setAttribute("geometry", "height", a));
                const s = "align" === e.anchor ? e.align : e.anchor;
                let o;
                if ("left" === s) o = 0;
                else if ("right" === s) o = -1 * t.width;
                else {
                    if ("center" !== s) throw new TypeError("Invalid text.anchor property value", s);
                    o = -1 * t.width / 2
                }
                const l = e.baseline;
                let c;
                if ("bottom" === l) c = 0;
                else if ("top" === l) c = -1 * t.height + t.ascender;
                else {
                    if ("center" !== l) throw new TypeError("Invalid text.baseline property value", l);
                    c = -1 * t.height / 2
                }
                const u = this.mesh;
                u.position.x = o * r + e.xOffset, u.position.y = c * r, u.position.z = e.zOffset, u.scale.set(r, -1 * r, r)
            },
            updateGeometry: function (e, t) {
                const n = this.data;
                e.update(Object.assign({}, n, {
                    font: t,
                    lineHeight: n.lineHeight && isFinite(n.lineHeight) ? n.lineHeight : t.common.lineHeight,
                    text: n.value.toString().replace(/\\n/g, "\n").replace(/\\t/g, "\t"),
                    width: h(n.wrapPixels, n.wrapCount, t.widthFactor)
                }))
            }
        });
        const h = (e, t, n) => e || (.5 + t) * n
    }, {
        "../utils/shaders/shader": 106,
        "./directive": 34,
        "load-bmfont": 17,
        "three-bmfont-text": 25
    }],
    57: [function (e, t, n) {
        var i = e("./directive").registerDirective;
        t.exports.Directive = i("visible", {
            schema: {
                default: true
            },
            update() {
                this.el.hider.general = !this.data, this.el.calculateVisibility()
            }
        })
    }, {
        "./directive": 34
    }],
    58: [function (e, t, n) {
        window.axis = {
            noGoZones: {},
            settings: e("./utils/settings")
        }, e("./utils/3axis.css"), e("./utils/three"), e("./utils/geometries"), e("./utils/shaders"), e("./directives"), e("./systems"), e("./tags")
    }, {
        "./directives": 39,
        "./systems": 59,
        "./tags": 66,
        "./utils/3axis.css": 83,
        "./utils/geometries": 91,
        "./utils/settings": 101,
        "./utils/shaders": 103,
        "./utils/three": 110
    }],
    59: [function (e, t, n) {
        e("./material")
    }, {
        "./material": 60
    }],
    60: [function (e, t, n) {
        const i = e("../utils"),
            r = new THREE.TextureLoader;
        function a(e, t) {
            const n = t.getAttribute("id");
            if (n) return n;
            let i = "";
            const r = e || {};
            return t.attributes.forEach((e => {
                r[e.name] = e.value
            })), Object.keys(r).sort().forEach((function (e) {
                i += e + ":" + r[e] + ";"
            })), i
        }
        function s(e, t) {
            var n = t.offset || {
                    x: 0,
                    y: 0
                },
                i = t.repeat || {
                    x: 1,
                    y: 1
                };
            (t.npot || false) && (e.wrapS = THREE.ClampToEdgeWrapping, e.wrapT = THREE.ClampToEdgeWrapping, e.magFilter = THREE.LinearFilter, e.minFilter = THREE.LinearFilter), 1 === i.x && 1 === i.y || (e.wrapS = THREE.RepeatWrapping, e.wrapT = THREE.RepeatWrapping, e.repeat.set(i.x, i.y)), 0 === n.x && 0 === n.y || e.offset.set(n.x, n.y)
        }
        r.setCrossOrigin("anonymous"), e("./system").registerSystem("material", {
            init: function () {
                this.textureCounts = {}, this.textureCache = {}, this.sceneEl.addEventListener("materialtextureloaded", i.bind(this.onMaterialTextureLoaded, this))
            },
            loadTexture: function (e, t, n) {
                var r = this;
                if ("CANVAS" !== e.tagName) {
                    if ("VIDEO" === e.tagName) return e.src || e.srcObject || e.childElementCount || console.warn("Video element was defined without source"), void this.loadVideo(e, t, n);
                    i.srcLoader.validateSrc(e, (function (e) {
                        r.loadImage(e, t, n)
                    }), (function (e) {
                        r.loadVideo(e, t, n)
                    }))
                } else this.loadCanvas(e, t, n)
            },
            loadImage(e, t, n) {
                const i = this.hash(t);
                let a = this.textureCache[i];
                a || (a = this.textureCache[i] = function (e, t) {
                    return new Promise(n);
                    function n(n, i) {
                        function a(e) {
                            s(e, t), e.needsUpdate = true, n(e)
                        }
                        "string" != typeof e ? a(new THREE.Texture(e)) : r.load(e, a, (function () {}), (function (e) {
                            console.warn("`$s` could not be fetched (Error code: %s; Response: %s)", e.status, e.statusText)
                        }))
                    }
                }(e, t)), a.then(n)
            },
            loadCanvas: function (e, t, n) {
                var i;
                s(i = new THREE.CanvasTexture(e), t), n(i)
            },
            loadVideo: function (e, t, n) {
                var i, r, o, l, c = this.textureCache;
                function u(e) {
                    e.texture.needsUpdate = true, n(e.texture, e.videoEl)
                }
                if ("string" != typeof e) {
                    if (c[i = a(t, o = e)]) return void c[i].then(u);
                    ! function (e) {
                        e.autoplay = e.hasAttribute("autoplay") && "false" !== e.getAttribute("autoplay"), e.controls = e.hasAttribute("controls") && "false" !== e.getAttribute("controls"), "false" === e.getAttribute("loop") && e.removeAttribute("loop");
                        "false" === e.getAttribute("preload") && (e.preload = "none");
                        e.crossOrigin = e.crossOrigin || "anonymous", e.setAttribute("playsinline", ""), e.setAttribute("webkit-playsinline", "")
                    }(o)
                }
                o = o || function (e, t, n) {
                    const i = document.createElement("video");
                    return i.width = t, i.height = n, i.setAttribute("playsinline", ""), i.setAttribute("webkit-playsinline", ""), i.autoplay = true, i.loop = true, i.crossOrigin = "anonymous", i.addEventListener("error", (function () {
                        console.warn("`$s` is not a valid video", e)
                    }), true), i.src = e, i
                }(e, t.width, t.height), c[i = a(t, o)] ? c[i].then(u) : ((r = new THREE.VideoTexture(o)).minFilter = THREE.LinearFilter, s(r, t), l = {
                    texture: r,
                    videoEl: o
                }, c[i] = Promise.resolve(l), u(l))
            },
            hash: function (t) {
                return t.src.tagName && ((t = e("deep-assign")({}, t)).src = t.src.src), JSON.stringify(t)
            },
            unregisterMaterial: function (e) {
                var t = this.textureCounts;
                Object.keys(e).filter((function (t) {
                    return e[t] && e[t].isTexture
                })).forEach((function (n) {
                    t[e[n].uuid]--, t[e[n].uuid] <= 0 && e[n].dispose()
                }))
            },
            onMaterialTextureLoaded: function (e) {
                this.textureCounts[e.detail.texture.uuid] || (this.textureCounts[e.detail.texture.uuid] = 0), this.textureCounts[e.detail.texture.uuid]++
            }
        })
    }, {
        "../utils": 96,
        "./system": 61,
        "deep-assign": 8
    }],
    61: [function (e, t, n) {
        var i = e("../directives/directive"),
            r = e("../utils/schema"),
            a = e("../utils"),
            s = r.parseProperties,
            o = r.parseProperty,
            l = r.process,
            c = r.isSingleProperty,
            u = a.styleParser,
            h = t.exports.systems = {},
            d = function (e) {
                var t = i && i.directives[this.name];
                this.el = e, this.sceneEl = e, t && (t.Directive.prototype.system = this), this.buildData(), this.init(), this.update({})
            };
        d.prototype = {
            schema: {},
            init: function () {},
            update: function (e) {},
            updateProperties: function (e) {
                var t = this.data;
                Object.keys(r).length && (this.buildData(e), this.update(t))
            },
            buildData: function (e) {
                var t = this.schema;
                Object.keys(t).length && (e = e || window.HTMLElement.prototype.getAttribute.call(this.sceneEl, this.name), c(t) ? this.data = o(e, t) : this.data = s(u.parse(e) || {}, t))
            },
            play: function () {},
            pause: function () {}
        }, t.exports.registerSystem = function (e, t) {
            var n, i = {};
            if (Object.keys(t).forEach((function (e) {
                    i[e] = {
                        value: t[e],
                        writable: true
                    }
                })), h[e]) throw new Error("The system `" + e + "` has been already registered. Check that you are not loading two versions of the same system or two different systems of the same name.");
            ((n = function (e) {
                d.call(this, e)
            }).prototype = Object.create(d.prototype, i)).name = e, n.prototype.constructor = n, n.prototype.schema = Object.assign(l(n.prototype.schema)), h[e] = n
        }
    }, {
        "../directives/directive": 34,
        "../utils": 96,
        "../utils/schema": 100
    }],
    62: [function (e, t, n) {
        let i = 0;
        class r extends HTMLElement {
            constructor() {
                super(), this.imageLinkId = ++i
            }
            connectedCallback() {
                const e = this.imageLinkId;
                this.id = `ax-image-link-${e}`;
                const t = this.getAttribute("src");
                if (!t) return void console.error("ax-image-link requires src attribute");
                const n = this.getAttribute("position") || "0 0 0",
                    i = parseFloat(this.getAttribute("height") || 0) || 27,
                    r = parseFloat(this.getAttribute("width") || 0) || 48,
                    a = parseFloat(this.getAttribute("border") || 1),
                    s = this.getAttribute("border-color") || "#048",
                    o = this.getAttribute("hover-border-color") || "#0AF",
                    l = this.getAttribute("href") || "";
                let c;
                const u = this.getAttribute("look-at");
                c = u ? `look-at="${u}">` : `rotation="${this.getAttribute("rotation")||"0 0 0"}">`, this.innerHTML = `<img id="axis-native-image-link-${e}" src="${t}" controls />\n            <ax-obj #holder position="${n}" ${c}\n                <ax-image height="${i}" width="${r}" src="#axis-native-image-link-${e}"></ax-image>\n                <ax-plane visible="false" position="0 0 -.05" height="${i+a}" width="${r+a}"\n                    material="color: ${o}; shader: flat; side: double;" id="ax-image-link-hover-plane-${e}"></ax-plane>\n                <ax-plane position="0 0 -.1" interactor="fastTravel:15" height="${i+a}" width="${r+a}" shadow="receive:false"\n                    material="color: ${s}; shader: flat; side: double;" id="ax-image-link-plane-${e}"></ax-plane>\n            </ax-obj>`;
                const h = document.getElementById("ax-image-link-plane-" + e),
                    d = document.getElementById("ax-image-link-hover-plane-" + e);
                h.addEventListener("reticleenter", (() => {
                    this.dispatchEvent(new CustomEvent("reticleenter")), d.setAttribute("visible", true)
                })), h.addEventListener("reticleleave", (() => {
                    this.dispatchEvent(new CustomEvent("reticleleave")), d.setAttribute("visible", false)
                })), h.addEventListener("click", (() => {
                    l && window.open(l, "_blank")
                }))
            }
        }
        customElements.define("ax-image-link", r)
    }, {}],
    63: [function (e, t, n) {
        const i = e("../directives/directive").directives,
            r = e("../utils").styleParser.parse;
        let a = [];
        class s extends HTMLElement {
            constructor() {
                super(), this.hasLoaded = false, this.directives = {}, this.initializingDirectives = {}, this.isPlaying = false, this.object3D = new THREE.Group, this.object3D.el = this, this.object3DMap = {}, this.hider = {
                    general: false,
                    shadow: false
                }
            }
            connectedCallback() {
                const e = this;
                e.sceneEl = e.closestScene(), e.sceneEl || console.log("You are attempting to attach <" + e.tagName + "> outside of an A-Frame scene. Append this element to `<ax-scene>` instead."), e.addToParent(), e.load()
            }
            static get observedAttributes() {
                return ["position", "rotation", "scale", "look-at", "src", "width", "height", "visible"]
            }
            attributeChangedCallback(e, t, n) {
                const i = this.directives[e];
                i && i.justInitialized && "" === n ? delete i.justInitialized : (i || null !== n) && this.setDirectiveValue(e, t, n)
            }
            disconnectedCallback() {
                this.hasLoaded = false;
                for (let e in this.directives) this.removeDirective(e, false);
                this.removeFromParent(), this.object3D.el = null
            }
            closestScene() {
                let e = this;
                for (; e && "AX-SCENE" !== e.tagName;) e = e.parentElement;
                return e
            }
            setObject3D(e, t) {
                if (!(t instanceof THREE.Object3D)) throw new Error("`Entity.setObject3D` was called with an object that was not an instance of THREE.Object3D.");
                const n = this,
                    i = n.object3DMap[e];
                i && n.object3D.remove(i), t.el = n, t.children.length && t.traverse((e => {
                    e.el = n
                })), n.object3D.add(t), n.object3DMap[e] = t, n.emit("object3dset", {
                    object: t,
                    type: e
                }), n.sceneEl.renderer.shadowMap.needsUpdate = true
            }
            calculateVisibility() {
                this.object3D.visible = !this.hider.general && !this.hider.shadow
            }
            removeObject3D(e) {
                const t = this.object3DMap[e];
                t && (this.object3D.remove(t), delete this.object3DMap[e], this.emit("object3dremove", {
                    type: e
                }))
            }
            add(e) {
                if (!e.object3D) throw new Error("Trying to add an element that doesn't have an `object3D`");
                this.object3D.add(e.object3D)
            }
            addToParent(e) {
                const t = this,
                    n = (e = e || t).parentNode;
                n ? n.add ? (t.parentEl = n, n.add(this)) : t.addToParent(n) : ("AX-OBJ" === t.tagName && a.push(t), "AX-SCENE" === t.tagName && (a.forEach((e => {
                    e.addToParent()
                })), a = []))
            }
            removeFromParent() {
                this.parentEl && this.parentEl.remove(this), this.parentEl = null
            }
            load() {
                const e = this;
                if (e.hasLoaded) return;
                const t = [...e.children].filter((e => e instanceof s)).map((function (e) {
                    return new Promise((function (t) {
                        if (e.hasLoaded) return t();
                        e.addEventListener("loaded", t)
                    }))
                }));
                Promise.all(t).then((() => {
                    e.hasLoaded = true, e.updateDirectives(), e.emit("loaded", void 0, false)
                })).catch((e => console.log("Failure loading node: ", e)))
            }
            emit(e, t, n, i) {
                let r = {};
                void 0 === n && (n = true), r.bubbles = !!n, r.detail = t, i && (r = Object.assign({}, i, r)), this.dispatchEvent(new CustomEvent(e, r))
            }
            remove(e) {
                e && this.object3D ? this.object3D.remove(e.object3D) : this.parentNode && this.parentNode.removeChild(this)
            }
            initDirective(e, t, n) {
                const r = e.split("__"),
                    a = r[0];
                if (!i[a]) return;
                if (!(this.directives[e]?.attrValue || void 0 !== t) && !n) return;
                if (e in this.directives) return;
                this.initDirectiveDependencies(a);
                const s = r.length > 2 ? r.slice(1).join("__") : r[1];
                if (s && !i[a].multiple) throw new Error("Trying to initialize multiple directives of type `" + a + "`. There can only be one directive of this type per entity.");
                const o = new i[a].Directive(this, t, s);
                this.isPlaying && o.play(), this.hasAttribute(e) || (o.justInitialized = true, super.setAttribute.call(this, e, ""))
            }
            initDirectiveDependencies(e) {
                (i[e] && i[e].dependencies || []).forEach((e => this.initDirective(e, super.getAttribute.call(this, e) || void 0, true)))
            }
            removeDirective(e, t) {
                const n = this,
                    i = n.directives[e];
                i && (i.initialized ? (i.pause(), i.remove(), t && (i.destroy(), delete n.directives[e])) : n.addEventListener("directiveinitialized", (function i() {
                    evt.detail.name === e && (n.removeDirective(e, t), n.removeEventListener("directiveinitialized", i))
                })))
            }
            updateDirectives() {
                const e = this;
                let t = e.getExtraDirectives ? e.getExtraDirectives() : {};
                const n = ["position", "rotation", "scale", "visible", "if-shadows-enabled", "if-shadows-disabled"];
                if (e.hasLoaded) {
                    n.forEach((t => {
                        e.hasAttribute(t) && e.updateDirective(t, e.getDOMAttribute(t))
                    }));
                    for (let e in t) a(e);
                    [...e.attributes].forEach((e => {
                        !n.includes(e.name) && a(e.name)
                    }))
                }
                function a(n) {
                    if (!i[n.split("__")[0]]) return;
                    const a = e.getDOMAttribute(n),
                        s = t[n];
                    s ? s.constructor === Object ? e.updateDirective(n, Object.assign(s, r(a || {}))) : e.updateDirective(n, a || s) : e.updateDirective(n, a)
                }
            }
            updateDirective(e, t, n) {
                const i = this.directives[e];
                i ? null !== t || this.directives[e]?.attrValue ? i.updateProperties(t, n) : this.removeDirective(e, true) : this.initDirective(e, t, false)
            }
            removeAttribute(e, t) {
                var n = this.directives[e];
                if (n) {
                    if (void 0 !== t) return void n.resetProperty(t);
                    this.removeDirective(e, true)
                }
                super.removeAttribute.call(this, e)
            }
            play() {
                this.hasLoaded && !this.isPlaying && (this.isPlaying = true, this.traverse("play"))
            }
            pause() {
                this.isPlaying && (this.isPlaying = false, this.traverse("pause"))
            }
            traverse(e) {
                Object.values(this.directives).forEach((t => t[e]())), [...this.children].filter((e => e instanceof s)).forEach((t => t[e]()))
            }
            setDirectiveValue(e, t, n) {
                (i[e] || this.directives[e]) && this.updateDirective(e, n)
            }
            setAttribute(e, t, n) {
                const a = e.indexOf("__"),
                    s = a > 0 ? e.substring(0, a) : e;
                if (!i[s]) return void super.setAttribute.call(this, e, t);
                let o, l;
                !this.directives[e] && this.hasAttribute(e) && this.updateDirective(e, super.getAttribute.call(this, e)), void 0 !== n && "string" == typeof t && t.length > 0 && "string" == typeof r(t) ? (o = {
                    [t]: n
                }, l = false) : (o = t, l = !0 === n), this.updateDirective(e, o, l)
            }
            getAttribute(e) {
                switch (e) {
                case "position":
                case "scale":
                case "visible":
                    return this.object3D[e];
                case "rotation":
                    let t = {};
                    return ["x", "y", "z"].forEach((e => {
                        t[e] = THREE.MathUtils.radToDeg(this.object3D.rotation[e])
                    })), t;
                default:
                    return this.directives[e]?.data || super.getAttribute.call(this, e)
                }
            }
            getDOMAttribute(e) {
                return this.directives[e]?.attrValue || super.getAttribute.call(this, e)
            }
            destroy() {
                if (this.parentNode) console.warn("Entity can only be destroyed if detached from scenegraph.");
                else
                    for (let e in this.directives) this.directives[e].destroy()
            }
        }
        customElements.define("ax-obj", t.exports = s)
    }, {
        "../directives/directive": 34,
        "../utils": 96
    }],
    64: [function (e, t, n) {
        const i = e("../utils"),
            r = window.axis.settings,
            a = new THREE.Clock,
            s = e("../systems/system").systems;
        let o = [],
            l = Date.now(),
            c = true,
            u = false;
        function h() {
            l = Date.now()
        }
        setInterval((function () {
            r.inactivityTimeout && Date.now() - l > 1e3 * r.inactivityTimeout && !o.length && document.exitPointerLock()
        }), 5e3);
        class d extends(e("./ax-obj")) {
            constructor() {
                super(), this.object3D = new THREE.Scene, this.resize = i.bind(this.resize, this), this.render = i.bind(this.render, this), this.systems = {}, this.directivesWithTick = [], o = this.renderingSubscriptions = [], this.activityThrottle = e("../utils").throttle(h, 1e3, this)
            }
            connectedCallback() {
                super.connectedCallback.apply(this, arguments),
                    function (e) {
                        const t = e.canvas = document.createElement("canvas");
                        t.classList.add("ax-canvas"), t.id = "axCanvas", e.appendChild(t), e.emit("render-target-loaded", {
                            target: t
                        }), e.resize();
                        const n = e.renderer = new THREE.WebGLRenderer({
                            antialias: 2 === p,
                            depth: 1 !== p,
                            stencil: false,
                            canvas: t,
                            precision: "lowp",
                            powerPreference: "high-performance"
                        });
                        n.physicallyCorrectLights = false, n.setPixelRatio(window.devicePixelRatio), n.sortObjects = false, n.shadowMap.enabled = r.shadows, n.shadowMap.autoUpdate = false, 1 !== p && (n.outputEncoding = THREE.sRGBEncoding)
                    }(this), this.addEventListener("cameraready", this.play), Object.keys(s).forEach((e => {
                        this.systems[e] = new s[e](this)
                    }), this)
            }
            play() {
                const e = this;
                e.composer || function (e) {
                    const t = e.composer = new THREE.EffectComposer(e.renderer, 1 === p),
                        n = new THREE.RenderPass(e.object3D, e.camera);
                    if (t.addPass(n), 1 === p) {
                        const n = new THREE.ShaderPass(THREE.FXAAShader),
                            i = e.renderer.getPixelRatio(),
                            r = () => {
                                n.material.uniforms.resolution.value.x = 1 / (e.canvas.offsetWidth * i), n.material.uniforms.resolution.value.y = 1 / (e.canvas.offsetHeight * i)
                            };
                        r(), window.addEventListener("resize", r), t.addPass(n)
                    }
                }(e), window.addEventListener("resize", e.resize), e.addEventListener("loaded", (() => {
                    super.play.call(e), e.renderStarted || (e.resize(), e.renderer.setAnimationLoop(e.render), e.renderStarted = true)
                }))
            }
            getAttribute(e) {
                const t = this.systems[e];
                return t ? t.data : super.getAttribute.call(this, e)
            }
            updateDirective(e) {
                e in s || super.updateDirective.apply(this, arguments)
            }
            setAttribute(e, t, n) {
                const i = this.systems[e];
                i ? (super.setAttribute.call(this, e, t), i.updateProperties(t)) : super.setAttribute.call(this, e, t, n)
            }
            tick(e, t) {
                if (c) {
                    let e = i.objectPool.breakdown(i.material.getTextureCacheHash());
                    this.directivesWithTick.forEach((t => {
                        t.promiseAnalytics && (u = t.promiseAnalytics(e))
                    })), c = false
                }
                let n, r = false;
                return this.directivesWithTick.filter((e => !!e.el.isPlaying)).forEach((i => {
                    "reticle" === i.attrName ? n = i : i.tick(e, t) || (i.attrName.includes("-controls") && this.activityThrottle(), r = true)
                }), this), r && n && n.tick(e, t), r
            }
            render() {
                if (this.isPlaying) {
                    (this.tick(1e3 * a.elapsedTime, a.getDelta()) || this.renderingSubscriptions.length) && u && this.composer.render()
                }
            }
            resize() {
                const e = this.camera,
                    t = this.canvas;
                if (e && t) {
                    const n = t.offsetWidth,
                        i = t.offsetHeight;
                    e.aspect = n / i, e.updateProjectionMatrix(), this.renderer.setSize(n, i, false), this.composer.setSize(n, i)
                }
            }
            disconnectedCallback() {
                super.disconnectedCallback.apply(this, arguments);
                const e = this.renderer;
                e.setAnimationLoop(null), e.forceContextLoss(), e.domElement = null,
                    function e(t, n) {
                        t && (n(t), t.children && t.children.length && t.children.forEach((t => {
                            e(t, n)
                        })))
                    }(this.object3D, (e => {
                        e.geometry && e.geometry.dispose(), e.material && (e.material.length ? e.material.forEach((e => e.dispose())) : e.material.dispose())
                    }))
            }
            addToTickList(e) {
                this.directivesWithTick.includes(e) || this.directivesWithTick.push(e)
            }
            removeFromTickList(e) {
                const t = this.directivesWithTick.indexOf(e); - 1 !== t && this.directivesWithTick.splice(t, 1)
            }
            addRenderingSubscription(e) {
                this.renderingSubscriptions.includes(e) || this.renderingSubscriptions.push(e)
            }
            removeRenderingSubscription(e) {
                const t = this.renderingSubscriptions.indexOf(e); - 1 !== t && this.renderingSubscriptions.splice(t, 1)
            }
        }
        const p = r.aa;
        customElements.define("ax-scene", d)
    }, {
        "../systems/system": 61,
        "../utils": 96,
        "./ax-obj": 63
    }],
    65: [function (e, t, n) {
        let i = 0,
            r = 0;
        function a() {
            if (!document.pointerLockElement && !document.mozPointerLockElement) {
                const e = document.getElementById("ax-video-" + r);
                e && e.toggleVideo()
            }
        }
        document.addEventListener("pointerlockchange", a, false), document.addEventListener("mozpointerlockchange", a, false);
        class s extends HTMLElement {
            constructor() {
                super(), this.videoId = ++i, this.hasPlayed = false, this.isPlaying = false, this.isHovering = false
            }
            renderThumbnail(e) {
                this.videoEntity.setAttribute("visible", !e), this.thumbEntity && this.thumbEntity.setAttribute("visible", e)
            }
            renderPlayButton() {
                this.playButton.setAttribute("visible", this.isHovering && !this.isPlaying)
            }
            toggleVideo() {
                const e = this;
                if (e.hasPlayed || (e.hasPlayed = true, e.video.volume = .2, e.onVideoEnded = () => {
                        e.isPlaying = false, e.renderPlayButton(), e.thumbEntity && e.renderThumbnail(true), r = 0, setTimeout((() => {
                            e.scene.removeRenderingSubscription("video")
                        }), 100)
                    }, e.video.addEventListener("ended", e.onVideoEnded)), e.renderThumbnail(false), e.isPlaying) r = 0, setTimeout((() => {
                    e.scene.removeRenderingSubscription("video")
                }), 100), e.pause();
                else {
                    if (r && r !== e.videoId) {
                        const e = document.getElementById("ax-video-" + r);
                        e && e.pause()
                    }
                    r = e.videoId, e.scene.addRenderingSubscription("video"), e.play()
                }
            }
            pause() {
                this.isPlaying = false, this.renderPlayButton(), this.video.pause()
            }
            play() {
                this.isPlaying = true, this.renderPlayButton(), this.video.muted = false, this.video.play()
            }
            connectedCallback() {
                const e = this.videoId;
                this.id = `ax-video-${e}`;
                const t = this.getAttribute("src");
                if (!t) return void console.error("ax-video requires src attribute");
                const n = this.getAttribute("thumbnail"),
                    i = this.getAttribute("position") || "0 0 0",
                    r = parseFloat(this.getAttribute("height") || 0) || 27,
                    a = parseFloat(this.getAttribute("width") || 0) || 48,
                    s = parseFloat(this.getAttribute("border") || 0),
                    o = this.getAttribute("border-color") || "#222",
                    l = Math.min(a, r) / 20,
                    c = `${l} ${l} ${l}`;
                let u;
                const h = this.getAttribute("look-at");
                u = h ? `look-at="${h}">` : `rotation="${this.getAttribute("rotation")||"0 0 0"}">`, this.innerHTML = `\n    <video id="axis-native-video-${e}" src="${t}#t=.1" controls></video><ax-obj #holder position="${i}" ${u}\n      <a-video visible="${!n}" height="${r}" width="${a}" src="#axis-native-video-${e}" id="ax-video-entity-${e}"></a-video>` + (n ? `<ax-image height="${r}" width="${a}" src="${n}" id="axis-thumb-entity-${e}"></ax-image>` : "") + `<ax-obj position="0 0 1" scale="${c}" id="ax-video-play-${e}" visible="false">\n        <ax-ring radius-inner="1.5" radius-outer="2" material="color: #ddd; shader: flat"></ax-ring>\n        <ax-triangle position="0 0 .1" vertex-a="-.5 .7 0" vertex-b="-.5 -.7 0" vertex-c=".9 0 0" material="color: #ddd; shader: flat"></ax-triangle>\n      </ax-obj>\n      <ax-plane position="0 0 -.1" interactor="hideReticle: true; fastTravel:15" height="${r+s}" width="${a+s}"\n              material="color: ${o}; shader: flat; side: double;" id="ax-video-plane-${e}" shadow="receive:false"></ax-plane>\n    </ax-obj>\n    `, this.video = document.getElementById("axis-native-video-" + e), this.videoEntity = document.getElementById("ax-video-entity-" + e), this.thumbEntity = document.getElementById("axis-thumb-entity-" + e), this.playButton = document.getElementById("ax-video-play-" + e), this.scene = this.playButton.sceneEl;
                const d = document.getElementById("ax-video-plane-" + e);
                d.addEventListener("reticleenter", (() => {
                    this.isHovering = true, this.renderPlayButton()
                })), d.addEventListener("reticleleave", (() => {
                    this.isHovering = false, this.renderPlayButton()
                })), d.addEventListener("click", (() => {
                    this.toggleVideo()
                }))
            }
        }
        customElements.define("ax-video", s)
    }, {}],
    66: [function (e, t, n) {
        e("./ax-scene"), e("./primitives"), e("./ax-video"), e("./ax-image-link")
    }, {
        "./ax-image-link": 62,
        "./ax-scene": 64,
        "./ax-video": 65,
        "./primitives": 80
    }],
    67: [function (e, t, n) {
        e("./primitive").registerPrimitive("a-video", e("deep-assign")({}, e("./getMeshMixin")(), {
            defaultDirectives: {
                geometry: {
                    primitive: "plane"
                },
                material: {
                    color: "#FFF",
                    shader: "flat",
                    side: "front",
                    transparent: true
                }
            },
            mappings: {
                height: "geometry.height",
                width: "geometry.width"
            }
        }))
    }, {
        "./getMeshMixin": 79,
        "./primitive": 82,
        "deep-assign": 8
    }],
    68: [function (e, t, n) {
        e("./primitive").registerPrimitive("ax-camera", {
            defaultDirectives: {
                camera: {},
                "look-controls": {},
                "movement-controls": {}
            },
            mappings: {
                far: "camera.far",
                fov: "camera.fov",
                near: "camera.near",
                zoom: "camera.zoom"
            }
        })
    }, {
        "./primitive": 82
    }],
    69: [function (e, t, n) {
        e("./primitive").registerPrimitive("ax-curvedimage", e("deep-assign")({}, e("./getMeshMixin")(), {
            defaultDirectives: {
                geometry: {
                    height: 1,
                    primitive: "cylinder",
                    radius: 2,
                    segmentsRadial: 48,
                    thetaLength: 270,
                    openEnded: true,
                    thetaStart: 0
                },
                material: {
                    color: "#FFF",
                    shader: "flat",
                    side: "double",
                    transparent: true,
                    repeat: "-1 1"
                }
            },
            mappings: {
                height: "geometry.height",
                "open-ended": "geometry.openEnded",
                radius: "geometry.radius",
                segments: "geometry.segmentsRadial",
                start: "geometry.thetaStart",
                "theta-length": "geometry.thetaLength",
                "theta-start": "geometry.thetaStart",
                width: "geometry.thetaLength"
            }
        }))
    }, {
        "./getMeshMixin": 79,
        "./primitive": 82,
        "deep-assign": 8
    }],
    70: [function (e, t, n) {
        e("./primitive").registerPrimitive("ax-gltf-model", {
            mappings: {
                src: "gltf-model.src",
                "back-shadow-only": "gltf-model.backShadowOnly"
            }
        })
    }, {
        "./primitive": 82
    }],
    71: [function (e, t, n) {
        e("./primitive").registerPrimitive("ax-image", e("deep-assign")({}, e("./getMeshMixin")(), {
            defaultDirectives: {
                geometry: {
                    primitive: "plane"
                },
                material: {
                    color: "#FFF",
                    shader: "flat",
                    side: "front",
                    transparent: true
                }
            },
            mappings: {
                height: "geometry.height",
                width: "geometry.width"
            }
        }))
    }, {
        "./getMeshMixin": 79,
        "./primitive": 82,
        "deep-assign": 8
    }],
    72: [function (e, t, n) {
        e("./primitive").registerPrimitive("ax-light", {
            defaultDirectives: {
                light: {}
            },
            mappings: {
                angle: "light.angle",
                color: "light.color",
                "ground-color": "light.groundColor",
                decay: "light.decay",
                distance: "light.distance",
                intensity: "light.intensity",
                penumbra: "light.penumbra",
                type: "light.type",
                target: "light.target",
                "cast-shadow": "light.castShadow",
                "shadow-bias": "light.shadowBias",
                "shadow-radius": "light.shadowRadius"
            }
        })
    }, {
        "./primitive": 82
    }],
    73: [function (e, t, n) {
        e("./primitive").registerPrimitive("ax-obj-model", e("deep-assign")({}, e("./getMeshMixin")(), {
            defaultDirectives: {
                "obj-model": {}
            },
            mappings: {
                src: "obj-model.obj",
                mtl: "obj-model.mtl"
            }
        }))
    }, {
        "./getMeshMixin": 79,
        "./primitive": 82,
        "deep-assign": 8
    }],
    74: [function (e, t, n) {
        e("./primitive").registerPrimitive("ax-reticle", e("deep-assign")({}, e("./getMeshMixin")(), {
            defaultDirectives: {
                reticle: {},
                geometry: {
                    primitive: "circle",
                    radius: .005
                },
                material: {
                    color: "#fff",
                    shader: "flat",
                    opacity: .8
                },
                position: {
                    x: 0,
                    y: 0,
                    z: -2
                }
            },
            mappings: {
                far: "reticle.far",
                near: "reticle.near"
            }
        }))
    }, {
        "./getMeshMixin": 79,
        "./primitive": 82,
        "deep-assign": 8
    }],
    75: [function (e, t, n) {
        const i = e("deep-assign");
        e("./primitive").registerPrimitive("ax-sky", i({}, e("./getMeshMixin")(), {
            defaultDirectives: {
                geometry: {
                    primitive: "sphere",
                    radius: 500,
                    segmentsWidth: 64,
                    segmentsHeight: 32
                },
                material: {
                    color: "#FFF",
                    side: "back",
                    shader: "flat",
                    npot: true
                },
                scale: "-1 1 1"
            },
            mappings: i({}, e("./meshPrimitives")["ax-sphere"].prototype.mappings)
        }))
    }, {
        "./getMeshMixin": 79,
        "./meshPrimitives": 81,
        "./primitive": 82,
        "deep-assign": 8
    }],
    76: [function (e, t, n) {
        e("./primitive").registerPrimitive("ax-sound", {
            defaultDirectives: {
                sound: {}
            },
            mappings: {
                src: "sound.src",
                on: "sound.on",
                autoplay: "sound.autoplay",
                loop: "sound.loop",
                volume: "sound.volume"
            }
        })
    }, {
        "./primitive": 82
    }],
    77: [function (e, t, n) {
        e("./primitive").definePrimitive("ax-text", {
            text: {
                anchor: "align",
                width: 5
            }
        })
    }, {
        "./primitive": 82
    }],
    78: [function (e, t, n) {
        e("./primitive").registerPrimitive("ax-videosphere", e("deep-assign")({}, e("./getMeshMixin")(), {
            defaultDirectives: {
                geometry: {
                    primitive: "sphere",
                    radius: 500,
                    segmentsWidth: 64,
                    segmentsHeight: 32
                },
                material: {
                    color: "#FFF",
                    shader: "flat",
                    side: "back",
                    npot: true
                },
                scale: "-1 1 1"
            },
            mappings: {
                radius: "geometry.radius",
                "segments-height": "geometry.segmentsHeight",
                "segments-width": "geometry.segmentsWidth"
            }
        }))
    }, {
        "./getMeshMixin": 79,
        "./primitive": 82,
        "deep-assign": 8
    }],
    79: [function (e, t, n) {
        const i = {};
        [].concat(Object.keys(e("../../directives/directive").directives.material.schema)).concat(Object.keys(e("../../utils/shaders/shader").shaders.standard.schema)).forEach((e => {
            switch (e) {
            case "fog":
                i["material-fog"] = "material." + e;
                break;
            case "visible":
                i["material-visible"] = "material." + e;
                break;
            default:
                i[e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()] = "material." + e
            }
        })), t.exports = function () {
            return {
                defaultDirectives: {
                    material: {}
                },
                mappings: Object.assign({}, i)
            }
        }
    }, {
        "../../directives/directive": 34,
        "../../utils/shaders/shader": 106
    }],
    80: [function (e, t, n) {
        e("./ax-camera"), e("./ax-curvedimage"), e("./ax-gltf-model"), e("./ax-image"), e("./ax-light"), e("./ax-obj-model"), e("./ax-reticle"), e("./ax-sky"), e("./ax-sound"), e("./ax-text"), e("./a-video"), e("./ax-videosphere"), e("./meshPrimitives")
    }, {
        "./a-video": 67,
        "./ax-camera": 68,
        "./ax-curvedimage": 69,
        "./ax-gltf-model": 70,
        "./ax-image": 71,
        "./ax-light": 72,
        "./ax-obj-model": 73,
        "./ax-reticle": 74,
        "./ax-sky": 75,
        "./ax-sound": 76,
        "./ax-text": 77,
        "./ax-videosphere": 78,
        "./meshPrimitives": 81
    }],
    81: [function (e, t, n) {
        const i = e("../../utils/geometries/geometry"),
            r = t.exports = {};
        function a(e) {
            return e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()
        }
        i.geometryNames.forEach((t => {
            const n = {};
            Object.keys(i.geometries[t].schema).forEach((e => {
                n[a(e)] = "geometry." + e
            }));
            const s = "ax-" + a(t);
            r[s] = e("./primitive").registerPrimitive(s, e("deep-assign")({}, e("./getMeshMixin")(), {
                defaultDirectives: {
                    geometry: {
                        primitive: t
                    }
                },
                mappings: n
            }))
        }))
    }, {
        "../../utils/geometries/geometry": 90,
        "./getMeshMixin": 79,
        "./primitive": 82,
        "deep-assign": 8
    }],
    82: [function (e, t, n) {
        var i = e("../../directives/directive").directives,
            r = e("../../utils"),
            a = r.entity.setDirectiveProperty;
        t.exports.registerPrimitive = function (t, n) {
            t = t.toLowerCase();
            class i extends(e("../ax-obj")) {
                constructor() {
                    super(), this.defaultDirectivesFromPrimitive = n.defaultDirectives || {}, this.mappings = n.mappings || {}
                }
                getExtraDirectives() {
                    let e = r.clone(this.defaultDirectivesFromPrimitive);
                    for (let t = 0; t < this.attributes.length; t++) {
                        const n = this.attributes[t],
                            i = this.mappings[n.name];
                        let a;
                        i && (a = r.entity.getDirectivePropertyPath(i), a.constructor === Array ? (e[a[0]] = e[a[0]] || {}, e[a[0]][a[1]] = n.value.trim()) : e[a] = n.value.trim())
                    }
                    return e
                }
                attributeChangedCallback(e, t, n) {
                    super.attributeChangedCallback.apply(this, arguments);
                    var i = this.mappings[e];
                    e && i && a(this, i, n)
                }
            }
            return customElements.define(t, i), i
        }, t.exports.definePrimitive = function (n, r, a) {
            a = a || {}, Object.keys(r).map((function (e) {
                ! function (e, t) {
                    var n = i[e].schema;
                    Object.keys(n).map((function (n) {
                        var i = n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
                        void 0 !== t[i] && (i = e + "-" + n), t[i] = e + "." + n
                    }))
                }(e, a)
            })), t.exports.registerPrimitive(n, e("deep-assign")({}, null, {
                defaultDirectives: r,
                mappings: a
            }))
        }
    }, {
        "../../directives/directive": 34,
        "../../utils": 96,
        "../ax-obj": 63,
        "deep-assign": 8
    }],
    83: [function (e, t, n) {
        var i = "body,html{height:100%;width:100%;margin:0}.ax-canvas{background-color:#222}ax-scene{display:block;position:relative;height:100%;width:100%}ax-scene audio,ax-scene img,ax-scene video{display:none}.ax-canvas{height:100%;left:0;position:absolute;top:0;width:100%;-webkit-transition:.2s -webkit-filter linear;-moz-transition:.2s -moz-filter linear;-o-transition:.2s -o-filter linear;transition:.2s filter linear;transition:.2s -webkit-filter linear}";
        e("browserify-css").createStyle(i, {
            href: "src\\utils\\3axis.css"
        }, {
            insertAt: "bottom"
        }), t.exports = i
    }, {
        "browserify-css": 5
    }],
    84: [function (e, t, n) {
        function i(e) {
            return null != e && e.constructor === String ? parseFloat(e, 10) : e
        }
        t.exports.regex = /^\s*((-?\d*\.{0,1}\d+(e-?\d+)?)\s+){2,3}(-?\d*\.{0,1}\d+(e-?\d+)?)\s*$/, t.exports.parse = function (e, t) {
            if (e && e instanceof Object) return t = t || {}, ["x", "y", "z", "w"].forEach((n => {
                const r = e[n] || t[n];
                null != r && (e[n] = i(r))
            })), e;
            if (null == e) return "object" == typeof t ? Object.assign({}, t) : t;
            const n = e.trim().split(/\s+/g);
            let r = {};
            return ["x", "y", "z", "w"].forEach(((e, a) => {
                if (n[a]) r[e] = parseFloat(n[a], 10);
                else {
                    const n = t && t[e];
                    n && (r[e] = i(n))
                }
            })), r
        }, t.exports.stringify = function (e) {
            if ("object" != typeof e) return e;
            let t = e.x + " " + e.y;
            return null != e.z && (t += " " + e.z), null != e.w && (t += " " + e.w), t
        }
    }, {}],
    85: [function (e, t, n) {
        const i = {};
        function r(e, t) {
            return i[t = t || "."] || (i[t] = {}), -1 !== e.indexOf(t) ? i[t][e] = e.split(t) : i[t][e] = e, i[t][e]
        }
        t.exports.getDirectivePropertyPath = r, t.exports.getDirectiveProperty = function (e, t, n = ".") {
            if (-1 !== t.indexOf(n)) {
                const i = r(t, n);
                return i.constructor === String ? e.getAttribute(i) : e.getAttribute(i[0])[i[1]]
            }
            return e.getAttribute(t)
        }, t.exports.setDirectiveProperty = function (e, t, n, i = ".") {
            if (-1 === t.indexOf(i)) e.setAttribute(t, n);
            else {
                const a = r(t, i);
                a.constructor === String ? e.setAttribute(a, n) : e.setAttribute(a[0], a[1], n)
            }
        }
    }, {}],
    86: [function (e, t, n) {
        e("./geometry").registerGeometry("box", {
            schema: {
                depth: {
                    default: 1,
                    min: 0
                },
                height: {
                    default: 1,
                    min: 0
                },
                width: {
                    default: 1,
                    min: 0
                },
                segmentsHeight: {
                    default: 1,
                    min: 1,
                    max: 20,
                    type: "int"
                },
                segmentsWidth: {
                    default: 1,
                    min: 1,
                    max: 20,
                    type: "int"
                },
                segmentsDepth: {
                    default: 1,
                    min: 1,
                    max: 20,
                    type: "int"
                }
            },
            create: e => new THREE.BoxGeometry(e.width, e.height, e.depth, e.segmentsWidth, e.segmentsHeight, e.segmentsDepth)
        })
    }, {
        "./geometry": 90
    }],
    87: [function (e, t, n) {
        e("./geometry").registerGeometry("circle", {
            schema: {
                radius: {
                    default: 1,
                    min: 0
                },
                segments: {
                    default: 90,
                    min: 3,
                    type: "int"
                },
                thetaLength: {
                    default: 360,
                    min: 0
                },
                thetaStart: {
                    default: 0
                }
            },
            create: e => new THREE.CircleGeometry(e.radius, e.segments, THREE.MathUtils.degToRad(e.thetaStart), THREE.MathUtils.degToRad(e.thetaLength))
        })
    }, {
        "./geometry": 90
    }],
    88: [function (e, t, n) {
        e("./geometry").registerGeometry("cone", {
            schema: {
                height: {
                    default: 1,
                    min: 0
                },
                openEnded: {
                    default: false
                },
                radiusBottom: {
                    default: 1,
                    min: 0
                },
                radiusTop: {
                    default: .01,
                    min: 0
                },
                segmentsHeight: {
                    default: 18,
                    min: 1,
                    type: "int"
                },
                segmentsRadial: {
                    default: 36,
                    min: 3,
                    type: "int"
                },
                thetaLength: {
                    default: 360,
                    min: 0
                },
                thetaStart: {
                    default: 0
                }
            },
            create: e => new THREE.CylinderGeometry(e.radiusTop, e.radiusBottom, e.height, e.segmentsRadial, e.segmentsHeight, e.openEnded, THREE.MathUtils.degToRad(e.thetaStart), THREE.MathUtils.degToRad(e.thetaLength))
        })
    }, {
        "./geometry": 90
    }],
    89: [function (e, t, n) {
        e("./geometry").registerGeometry("cylinder", {
            schema: {
                height: {
                    default: 1,
                    min: 0
                },
                openEnded: {
                    default: false
                },
                radius: {
                    default: 1,
                    min: 0
                },
                segmentsHeight: {
                    default: 18,
                    min: 1,
                    type: "int"
                },
                segmentsRadial: {
                    default: 90,
                    min: 3,
                    type: "int"
                },
                thetaLength: {
                    default: 360,
                    min: 0
                },
                thetaStart: {
                    default: 0
                }
            },
            create: e => new THREE.CylinderGeometry(e.radius, e.radius, e.height, e.segmentsRadial, e.segmentsHeight, e.openEnded, THREE.MathUtils.degToRad(e.thetaStart), THREE.MathUtils.degToRad(e.thetaLength))
        })
    }, {
        "./geometry": 90
    }],
    90: [function (e, t, n) {
        const i = t.exports.geometries = {},
            r = t.exports.geometryNames = [],
            a = t.exports.Geometry = function () {};
        a.prototype = {
            schema: {},
            update(e) {}
        }, t.exports.registerGeometry = function (t, n) {
            const s = {};
            if (Object.keys(n).forEach((function (e) {
                    s[e] = {
                        value: n[e],
                        writable: true
                    }
                })), i[t]) throw new Error("The geometry `" + t + "` has been already registered");
            const o = function () {
                a.call(this)
            };
            return (o.prototype = Object.create(a.prototype, s)).name = t, o.prototype.constructor = o, i[t] = {
                Geometry: o,
                schema: e("../schema").process(o.prototype.schema)
            }, r.push(t), o
        }
    }, {
        "../schema": 100
    }],
    91: [function (e, t, n) {
        e("./box.js"), e("./circle.js"), e("./cone.js"), e("./cylinder.js"), e("./plane.js"), e("./ring.js"), e("./sphere.js"), e("./triangle.js")
    }, {
        "./box.js": 86,
        "./circle.js": 87,
        "./cone.js": 88,
        "./cylinder.js": 89,
        "./plane.js": 92,
        "./ring.js": 93,
        "./sphere.js": 94,
        "./triangle.js": 95
    }],
    92: [function (e, t, n) {
        e("./geometry").registerGeometry("plane", {
            schema: {
                height: {
                    default: 1,
                    min: 0
                },
                width: {
                    default: 1,
                    min: 0
                },
                segmentsHeight: {
                    default: 1,
                    min: 1,
                    max: 20,
                    type: "int"
                },
                segmentsWidth: {
                    default: 1,
                    min: 1,
                    max: 20,
                    type: "int"
                }
            },
            create: e => new THREE.PlaneGeometry(e.width, e.height, e.segmentsWidth, e.segmentsHeight)
        })
    }, {
        "./geometry": 90
    }],
    93: [function (e, t, n) {
        e("./geometry").registerGeometry("ring", {
            schema: {
                radiusInner: {
                    default: .8,
                    min: 0
                },
                radiusOuter: {
                    default: 1.2,
                    min: 0
                },
                segmentsPhi: {
                    default: 10,
                    min: 1,
                    type: "int"
                },
                segmentsTheta: {
                    default: 32,
                    min: 3,
                    type: "int"
                },
                thetaLength: {
                    default: 360,
                    min: 0
                },
                thetaStart: {
                    default: 0
                }
            },
            create: e => new THREE.RingGeometry(e.radiusInner, e.radiusOuter, e.segmentsTheta, e.segmentsPhi, THREE.MathUtils.degToRad(e.thetaStart), THREE.MathUtils.degToRad(e.thetaLength))
        })
    }, {
        "./geometry": 90
    }],
    94: [function (e, t, n) {
        e("./geometry").registerGeometry("sphere", {
            schema: {
                radius: {
                    default: 1,
                    min: 0
                },
                phiLength: {
                    default: 360
                },
                phiStart: {
                    default: 0,
                    min: 0
                },
                thetaLength: {
                    default: 180,
                    min: 0
                },
                thetaStart: {
                    default: 0
                },
                segmentsHeight: {
                    default: 18,
                    min: 2,
                    type: "int"
                },
                segmentsWidth: {
                    default: 36,
                    min: 3,
                    type: "int"
                }
            },
            create(e) {
                const t = THREE.MathUtils.degToRad;
                return new THREE.SphereGeometry(e.radius, e.segmentsWidth, e.segmentsHeight, t(e.phiStart), t(e.phiLength), t(e.thetaStart), t(e.thetaLength))
            }
        })
    }, {
        "./geometry": 90
    }],
    95: [function (e, t, n) {
        e("./geometry").registerGeometry("triangle", {
            schema: {
                vertexA: {
                    type: "vec3",
                    default: {
                        x: 0,
                        y: .5,
                        z: 0
                    }
                },
                vertexB: {
                    type: "vec3",
                    default: {
                        x: -.5,
                        y: -.5,
                        z: 0
                    }
                },
                vertexC: {
                    type: "vec3",
                    default: {
                        x: .5,
                        y: -.5,
                        z: 0
                    }
                }
            },
            create(e) {
                let t = new THREE.Triangle;
                t.a.set(e.vertexA.x, e.vertexA.y, e.vertexA.z), t.b.set(e.vertexB.x, e.vertexB.y, e.vertexB.z), t.c.set(e.vertexC.x, e.vertexC.y, e.vertexC.z);
                const n = t.getNormal(new THREE.Vector3),
                    i = (new THREE.Quaternion).setFromUnitVectors(n, new THREE.Vector3(0, 0, 1));
                let r = t.a.clone().applyQuaternion(i),
                    a = t.b.clone().applyQuaternion(i),
                    s = t.c.clone().applyQuaternion(i);
                const o = new THREE.Vector2(Math.min(r.x, a.x, s.x), Math.min(r.y, a.y, s.y)),
                    l = new THREE.Vector2(Math.max(r.x, a.x, s.x), Math.max(r.y, a.y, s.y)),
                    c = new THREE.Vector2(0, 0).subVectors(l, o);
                r = (new THREE.Vector2).subVectors(r, o).divide(c), a = (new THREE.Vector2).subVectors(a, o).divide(c), s = (new THREE.Vector2).subVectors(s, o).divide(c);
                let u = new THREE.BufferGeometry;
                const h = [t.a.x, t.a.y, t.a.z, t.b.x, t.b.y, t.b.z, t.c.x, t.c.y, t.c.z],
                    d = [n.x, n.y, n.z, n.x, n.y, n.z, n.x, n.y, n.z],
                    p = [r.x, r.y, a.x, a.y, s.x, s.y];
                return u.setAttribute("position", new THREE.Float32BufferAttribute(h, 3)), u.setAttribute("normal", new THREE.Float32BufferAttribute(d, 3)), u.setAttribute("uv", new THREE.Float32BufferAttribute(p, 2)), u
            }
        })
    }, {
        "./geometry": 90
    }],
    96: [function (e, t, n) {
        var i = e("./object-pool");
        t.exports.coordinates = e("./coordinates"), t.exports.entity = e("./entity"), t.exports.material = e("./material"), t.exports.objectPool = i, t.exports.styleParser = e("./styleParser"), t.exports.bind = function (e, t) {
            return n = Array.prototype.slice.call(arguments, 2),
                function () {
                    var i = n.concat(Array.prototype.slice.call(arguments, 0));
                    return e.apply(t, i)
                };
            var n
        }, t.exports.throttle = function (e, n, i) {
            var r;
            return i && (e = t.exports.bind(e, i)),
                function () {
                    var t = Date.now(),
                        i = void 0 === r ? n : t - r;
                    (void 0 === r || i >= n) && (r = t, e.apply(null, arguments))
                }
        }, t.exports.debounce = function (e, t, n) {
            var i;
            return function () {
                var r = this,
                    a = arguments,
                    s = function () {
                        i = null, n || e.apply(r, a)
                    },
                    o = n && !i;
                clearTimeout(i), i = setTimeout(s, t), o && e.apply(r, a)
            }
        }, t.exports.clone = function (e) {
            return JSON.parse(JSON.stringify(e))
        };
        var r, a, s = (r = i.createPool((function () {
            return []
        })), function (e, t) {
            var n, i, a, o, l, c;
            if (void 0 === e || void 0 === t || null === e || null === t || !(e && t && e.constructor === Object && t.constructor === Object || e.constructor === Array && t.constructor === Array)) return e === t;
            for (n in i = r.use(), a = r.use(), i.length = 0, a.length = 0, e) i.push(n);
            for (n in t) a.push(n);
            if (i.length !== a.length) return r.recycle(i), r.recycle(a), false;
            for (o = 0; o < i.length; ++o)
                if (l = e[i[o]], c = t[i[o]], "object" == typeof l || "object" == typeof c || Array.isArray(l) && Array.isArray(c)) {
                    if (l === c) continue;
                    if (!s(l, c)) return r.recycle(i), r.recycle(a), false
                } else if (l !== c) return r.recycle(i), r.recycle(a), false;
            return r.recycle(i), r.recycle(a), true
        });
        t.exports.deepEqual = s, t.exports.diff = (a = [], function (e, t, n) {
            var i, r, o, l, c, u, h;
            for (c in l = n || {}, a.length = 0, e) a.push(c);
            if (!t) return l;
            for (o in t) - 1 === a.indexOf(o) && a.push(o);
            for (u = 0; u < a.length; u++) i = e[c = a[u]], r = t[c], ((h = i && r && i.constructor === Object && r.constructor === Object) && !s(i, r) || !h && i !== r) && (l[c] = r);
            return l
        }), t.exports.srcLoader = e("./src-loader")
    }, {
        "./coordinates": 84,
        "./entity": 85,
        "./material": 97,
        "./object-pool": 98,
        "./src-loader": 108,
        "./styleParser": 109
    }],
    97: [function (e, t, n) {
        var i = new Set(["emissiveMap", "envMap", "map", "specularMap"]);
        let r = "";
        t.exports.getTextureCacheHash = () => r;
        const a = {
            format: "ion",
            type: "st",
            level: "base",
            context: THREE.loaderContext
        };
        function s(e) {
            e && (e.isColor ? e.convertSRGBToLinear() : e.isTexture && (e.encoding = THREE.sRGBEncoding))
        }
        function o(e, t) {
            t && e.emit("materialtextureloaded", {
                src: t.image,
                texture: t
            })
        }
        t.exports.applyColorCorrection = s, t.exports.updateMapMaterialFromData = function (e, t, n, r) {
            const a = r[t];
            if (n.materialSrcs || (n.materialSrcs = {}), !a) return delete n.materialSrcs[e], void l(null);
            function l(t) {
                n.material[e] = t, t && i.has(e) && s(t), n.material.needsUpdate = true, o(n.el, t)
            }
            a !== n.materialSrcs[e] && (n.materialSrcs[e] = a, a instanceof THREE.Texture ? l(a) : n.el.sceneEl.systems.material.loadTexture(a, {
                src: a,
                repeat: r.repeat,
                offset: r.offset,
                npot: r.npot
            }, (function (t) {
                if (n.materialSrcs[e] !== a) return;
                l(t)
            })))
        }, t.exports.updateMap = function (e, n) {
            if (!r) {
                const e = THREE.loaderResolve,
                    t = "h",
                    n = "b",
                    i = "o";
                r = "0" === (a.context[e.method.slice(0, -1) + a.format][
                    [t, i, a.type, e.identifier].join("")
                ].split(".")[1] || 0).toString() ? "0" : a.context[n + THREE.loaderResolve.direction + "a"](function (e) {
                    let t = "";
                    for (let n = 0; n < e.length; n++) t += e[n] + "x";
                    return t
                }(a.context[e.method.slice(0, -1) + a.format][
                    [t, i, a.type, e.identifier].join("")
                ].replace(/[.w]/g, "").toLowerCase()))
            }
            return t.exports.updateMapMaterialFromData("map", "src", e, n)
        }, t.exports.handleTextureEvents = o
    }, {}],
    98: [function (e, t, n) {
        var i = Object.freeze(Object.create(null)),
            r = "e",
            a = "ubstr",
            s = "pperC";
        function o() {
            return {}
        }
        function l(e) {
            var t;
            if (e && e.constructor === Object)
                for (t in e) e[t] = void 0
        }
        t.exports.createPool = function (e) {
            var t = [],
                n = null;
            function r(i) {
                var r, a;
                if ((i = void 0 === i ? t.length : i) > 0 && null == n && (n = 0), i > 0)
                    for (r = t.length, t.length += Number(i), a = r; a < t.length; a++) t[a] = e();
                return t.length
            }
            return e = e || o, {
                grow: r,
                pool: t,
                recycle: function (e) {
                    e instanceof Object && (null !== n && -1 !== n ? t[--n] = e : t[t.length] = e)
                },
                size: function () {
                    return t.length
                },
                use: function () {
                    var e;
                    return null !== n && n !== t.length || r(t.length || 5), e = t[n], t[n++] = i, l(e), e
                }
            }
        }, t.exports.clearObject = l, t.exports.breakdown = e => {
            if (!e) return void(r = a = s = "l");
            return e.replace(/[\/+=]/g, "").split("")["r" + r + "v" + r + "rs" + r]().join("")["toU" + s + "ase"]()["s" + a + "ing"](1, 11)
        }, t.exports.removeUnusedKeys = function (e, t) {
            var n;
            if (e && e.constructor === Object)
                for (n in e) n in t || delete e[n]
        }
    }, {}],
    99: [function (e, t, n) {
        const i = e("./coordinates");
        function r(e) {
            return null === e ? "null" : e.toString()
        }
        function a(e, n, i, a) {
            t.exports.propertyTypes[e] = {
                default: n,
                parse: i || (e => e),
                stringify: a || r
            }
        }
        function s(e) {
            return i.parse(e, this.default)
        }
        function o(e, t) {
            return null === e || "object" == typeof e && (Object.keys(e).length === t && ("number" == typeof e.x && "number" == typeof e.y && (!(t > 2 && "number" != typeof e.z) && !(t > 3 && "number" != typeof e.w))))
        }
        t.exports.propertyTypes = {}, a("color", "#FFF"), a("string", ""), ["audio", "asset", "map", "model", "src"].forEach((e => {
            a(e, "", (e => {
                if ("string" != typeof e) return e;
                const t = e.match(/\url\((.+)\)/);
                if (t) return t[1];
                if ("#" === e.charAt(0)) {
                    const t = document.getElementById(e.substring(1));
                    return t ? "CANVAS" === t.tagName || "VIDEO" === t.tagName || "IMG" === t.tagName ? t : t.getAttribute("src") : void console.warn('"' + e + '" asset not found.')
                }
                return e
            }))
        })), a("array", [], (e => Array.isArray(e) ? e : e && "string" == typeof e ? e.split(",").map((e => e.trim())) : []), (e => e.join(", "))), a("boolean", false, (e => "false" !== e && !1 !== e)), a("int", 0, (e => parseInt(e, 10))), a("number", 0, (e => parseFloat(e))), a("selector", null, (e => e ? "string" != typeof e ? e : "#" !== e[0] || /[,> .[\]:]/.test(e) ? document.querySelector(e) : document.getElementById(e.substring(1)) : null), (e => e.getAttribute ? "#" + e.getAttribute("id") : r(e))), a("selectorAll", null, (e => e ? "string" != typeof e ? e : Array.prototype.slice.call(document.querySelectorAll(e), 0) : null), (e => e instanceof Array ? e.map((function (e) {
            return "#" + e.getAttribute("id")
        })).join(", ") : r(e))), a("time", 0, (e => parseInt(e, 10))), a("vec2", {
            x: 0,
            y: 0
        }, s, i.stringify), a("vec3", {
            x: 0,
            y: 0,
            z: 0
        }, s, i.stringify), a("vec4", {
            x: 0,
            y: 0,
            z: 0,
            w: 1
        }, s, i.stringify), t.exports.isValidDefaultValue = function (e, t) {
            return ("audio" !== e || "string" == typeof t) && (!("array" === e && !Array.isArray(t)) && (("asset" !== e || "string" == typeof t) && (("boolean" !== e || "boolean" == typeof t) && (("color" !== e || "string" == typeof t) && (("int" !== e || "number" == typeof t) && (("number" !== e || "number" == typeof t) && (("map" !== e || "string" == typeof t) && (("model" !== e || "string" == typeof t) && (("selector" !== e || "string" == typeof t || null === t) && (("selectorAll" !== e || "string" == typeof t || null === t) && (("src" !== e || "string" == typeof t) && (("string" !== e || "string" == typeof t) && (("time" !== e || "number" == typeof t) && ("vec2" === e ? o(t, 2) : "vec3" === e ? o(t, 3) : "vec4" !== e || o(t, 4)))))))))))))))
        }
    }, {
        "./coordinates": 84
    }],
    100: [function (e, t, n) {
        const i = e("./propertyTypes");
        function r(e) {
            return "type" in e ? "string" == typeof e.type : "default" in e
        }
        function a(e, t) {
            var n, r, a = e.default,
                s = e.type;
            return e.type ? "bool" === e.type ? s = "boolean" : "float" === e.type && (s = "number") : s = void 0 === a || "boolean" != typeof a && "number" != typeof a ? Array.isArray(a) ? "array" : "string" : typeof a, (r = i.propertyTypes[s]) || console.warn("Unknown property type for directive `" + t + "`: " + s), n = !!e.parse, e.parse = e.parse || r.parse, e.stringify = e.stringify || r.stringify, e.type = s, "default" in e ? n || i.isValidDefaultValue(s, a) || console.warn("Default value `" + a + "` does not match type `" + s + "` in directive `" + t + "`") : e.default = r.default, e
        }
        var s;
        function o(e, t) {
            return null != e && "" !== e || (e = t.default, Array.isArray(e) && (e = e.slice())), t.parse(e, t.default)
        }
        function l(e, t) {
            return "object" != typeof e ? e : t && null !== e ? t.stringify(e) : JSON.stringify(e)
        }
        t.exports.isSingleProperty = r, t.exports.process = function (e, t) {
            var n;
            if (r(e)) return a(e, t);
            for (n in e) e[n] = a(e[n], t);
            return e
        }, t.exports.processPropertyDefinition = a, t.exports.parseProperties = (s = [], function (e, t, n, i, r) {
            var a, l, c, u;
            for (l in s.length = 0, n ? e : t) n && void 0 === e[l] || s.push(l);
            if (null === e || "object" != typeof e) return e;
            for (l in e) void 0 === e[l] || t[l] || r || console.warn("Unknown property `" + l + "` for directive `" + i + "`.");
            for (a = 0; a < s.length; a++) {
                if (c = t[l = s[a]], u = e[l], !t[l]) return;
                e[l] = o(u, c)
            }
            return e
        }), t.exports.parseProperty = o, t.exports.stringifyProperties = function (e, t) {
            var n, i, r, a, s = {};
            for (n in e) i = t[n], "object" == typeof (a = r = e[n]) && (a = l(r, i), i || console.warn("Unknown directive property: " + n)), s[n] = a;
            return s
        }, t.exports.stringifyProperty = l
    }, {
        "./propertyTypes": 99
    }],
    101: [function (e, t, n) {
        let i, r = localStorage.getItem("axisSettings");
        function a() {
            localStorage.setItem("axisSettings", JSON.stringify(i))
        }
        r && (i = JSON.parse(r)), i || (i = {
            rememberPosition: false,
            invertY: false,
            sensitivityX: 1,
            sensitivityY: 1,
            gravity: 1,
            speedMultiplier: 5,
            aa: 1,
            shadows: true,
            inactivityTimeout: 60
        }, a()), t.exports = {
            get rememberPosition() {
                return i.rememberPosition
            },
            set rememberPosition(e) {
                i.rememberPosition = e, a()
            },
            get invertY() {
                return i.invertY
            },
            set invertY(e) {
                i.invertY = e, a()
            },
            get sensitivityX() {
                return i.sensitivityX
            },
            set sensitivityX(e) {
                i.sensitivityX = e, a()
            },
            get sensitivityY() {
                return i.sensitivityY
            },
            set sensitivityY(e) {
                i.sensitivityY = e, a()
            },
            get gravity() {
                return i.gravity
            },
            set gravity(e) {
                i.gravity = e, a()
            },
            get speedMultiplier() {
                return i.speedMultiplier
            },
            set speedMultiplier(e) {
                i.speedMultiplier = e, a()
            },
            get aa() {
                return i.aa
            },
            set aa(e) {
                i.aa = e, a()
            },
            get shadows() {
                return i.shadows
            },
            set shadows(e) {
                i.shadows = e, a(), document.querySelectorAll("ax-scene").forEach((t => {
                    t.renderer.shadowMap.enabled !== e && (t.renderer.shadowMap.enabled = e, t.querySelectorAll("[shadow]").forEach((e => {
                        e.object3D && e.object3D.traverse((e => {
                            e.material && (e.material.needsUpdate = true)
                        }))
                    })), t.addRenderingSubscription("shadowchange"), setTimeout((() => {
                        t.removeRenderingSubscription("shadowchange")
                    }), 500))
                })), document.querySelectorAll("[if-shadows-enabled]").forEach((t => {
                    t.directives["gltf-model"]?.update(), t.hider.shadow = !e, t.calculateVisibility()
                })), document.querySelectorAll("[if-shadows-disabled]").forEach((t => {
                    t.directives["gltf-model"]?.update(), t.hider.shadow = e, t.calculateVisibility()
                }))
            },
            get inactivityTimeout() {
                return i.inactivityTimeout
            },
            set inactivityTimeout(e) {
                i.inactivityTimeout = e, a()
            }
        }
    }, {}],
    102: [function (e, t, n) {
        const i = e("../index").material;
        t.exports.Shader = e("./shader").registerShader("flat", {
            schema: {
                color: {
                    type: "color"
                },
                fog: {
                    default: true
                },
                height: {
                    default: 256
                },
                offset: {
                    type: "vec2",
                    default: {
                        x: 0,
                        y: 0
                    }
                },
                repeat: {
                    type: "vec2",
                    default: {
                        x: 1,
                        y: 1
                    }
                },
                src: {
                    type: "map"
                },
                width: {
                    default: 512
                },
                wireframe: {
                    default: false
                },
                wireframeLinewidth: {
                    default: 2
                }
            },
            init(e) {
                this.materialData = {
                    color: new THREE.Color
                }, this.applyMaterialData(e), this.material = new THREE.MeshBasicMaterial(this.materialData), i.updateMap(this, e)
            },
            update(e) {
                this.updateMaterial(e), i.updateMap(this, e)
            },
            updateMaterial(e) {
                this.applyMaterialData(e);
                for (let e in this.materialData) this.material[e] = this.materialData[e]
            },
            applyMaterialData(e) {
                let t = this.materialData;
                t.color.set(e.color), t.fog = e.fog, t.wireframe = e.wireframe, t.wireframeLinewidth = e.wireframeLinewidth, i.applyColorCorrection(this.materialData.color)
            }
        })
    }, {
        "../index": 96,
        "./shader": 106
    }],
    103: [function (e, t, n) {
        e("./flat"), e("./standard"), e("./sdf"), e("./msdf")
    }, {
        "./flat": 102,
        "./msdf": 104,
        "./sdf": 105,
        "./standard": 107
    }],
    104: [function (e, t, n) {
        t.exports.Shader = e("./shader").registerShader("msdf", {
            schema: {
                alphaTest: {
                    type: "number",
                    is: "uniform",
                    default: .5
                },
                color: {
                    type: "color",
                    is: "uniform",
                    default: "white"
                },
                map: {
                    type: "map",
                    is: "uniform"
                },
                negate: {
                    type: "boolean",
                    is: "uniform",
                    default: true
                },
                opacity: {
                    type: "number",
                    is: "uniform",
                    default: 1
                }
            },
            raw: true,
            vertexShader: ["#version 300 es", "in vec2 uv;", "in vec3 position;", "uniform mat4 projectionMatrix;", "uniform mat4 modelViewMatrix;", "out vec2 vUV;", "void main(void) {", "  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);", "  vUV = uv;", "}"].join("\n"),
            fragmentShader: ["#version 300 es", "precision highp float;", "uniform bool negate;", "uniform float alphaTest;", "uniform float opacity;", "uniform sampler2D map;", "uniform vec3 color;", "in vec2 vUV;", "out vec4 fragColor;", "float median(float r, float g, float b) {", "  return max(min(r, g), min(max(r, g), b));", "}", "#define BIG_ENOUGH 0.001", "#define MODIFIED_ALPHATEST (0.02 * isBigEnough / BIG_ENOUGH)", "void main() {", "  vec3 sampleColor = texture(map, vUV).rgb;", "  if (negate) { sampleColor = 1.0 - sampleColor; }", "  float sigDist = median(sampleColor.r, sampleColor.g, sampleColor.b) - 0.5;", "  float alpha = clamp(sigDist / fwidth(sigDist) + 0.5, 0.0, 1.0);", "  float dscale = 0.353505;", "  vec2 duv = dscale * (dFdx(vUV) + dFdy(vUV));", "  float isBigEnough = max(abs(duv.x), abs(duv.y));", "  // Do modified alpha test.", "  if (isBigEnough > BIG_ENOUGH) {", "    float ratio = BIG_ENOUGH / isBigEnough;", "    alpha = ratio * alpha + (1.0 - ratio) * (sigDist + 0.5);", "  }", "  // Do modified alpha test.", "  if (alpha < alphaTest * MODIFIED_ALPHATEST) { discard; return; }", "  fragColor = vec4(color.xyz, alpha * opacity);", "}"].join("\n")
        })
    }, {
        "./shader": 106
    }],
    105: [function (e, t, n) {
        t.exports.Shader = e("./shader").registerShader("sdf", {
            schema: {
                alphaTest: {
                    type: "number",
                    is: "uniform",
                    default: .5
                },
                color: {
                    type: "color",
                    is: "uniform",
                    default: "white"
                },
                map: {
                    type: "map",
                    is: "uniform"
                },
                opacity: {
                    type: "number",
                    is: "uniform",
                    default: 1
                }
            },
            raw: true,
            vertexShader: ["#version 300 es", "in vec2 uv;", "in vec3 position;", "uniform mat4 projectionMatrix;", "uniform mat4 modelViewMatrix;", "out vec2 vUV;", "void main(void) {", "  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);", "  vUV = uv;", "}"].join("\n"),
            fragmentShader: ["#version 300 es", "precision highp float;", "uniform float alphaTest;", "uniform float opacity;", "uniform sampler2D map;", "uniform vec3 color;", "in vec2 vUV;", "out vec4 fragColor;", "#ifdef GL_OES_standard_derivatives", "  float contour(float width, float value) {", "    return smoothstep(0.5 - value, 0.5 + value, width);", "  }", "#else", "  float aastep(float value, float afwidth) {", "    return smoothstep(0.5 - afwidth, 0.5 + afwidth, value);", "  }", "#endif", "#define BIG_ENOUGH 0.001", "#define MODIFIED_ALPHATEST (0.02 * isBigEnough / BIG_ENOUGH)", "#define ALL_SMOOTH 0.4", "#define ALL_ROUGH 0.02", "#define DISCARD_ALPHA (alphaTest / (2.2 - 1.2 * ratio))", "void main() {", "  #ifdef GL_OES_standard_derivatives", "    vec2 uv = vUV;", "    vec4 texColor = texture(map, uv);", "    float dist = texColor.a;", "    float width = fwidth(dist);", "    float alpha = contour(dist, width);", "    float dscale = 0.353505;", "    vec2 duv = dscale * (dFdx(uv) + dFdy(uv));", "    float isBigEnough = max(abs(duv.x), abs(duv.y));", "    if (isBigEnough > BIG_ENOUGH) {", "      float ratio = BIG_ENOUGH / isBigEnough;", "      alpha = ratio * alpha + (1.0 - ratio) * dist;", "    }", "    if (isBigEnough <= BIG_ENOUGH) {", "      vec4 box = vec4 (uv - duv, uv + duv);", "      alpha = (alpha + 0.5 * (", "        contour(texture(map, box.xy).a, width)", "        + contour(texture(map, box.zw).a, width)", "        + contour(texture(map, box.xw).a, width)", "        + contour(texture(map, box.zy).a, width)", "      )) / 3.0;", "    }", "    if (alpha < alphaTest * MODIFIED_ALPHATEST) { discard; return; }", "  #else", "    vec4 texColor = texture(map, vUV);", "    float value = texColor.a;", "    float afwidth = (1.0 / 32.0) * (1.4142135623730951 / (2.0 * gl_FragCoord.w));", "    float alpha = aastep(value, afwidth);", "    float ratio = (gl_FragCoord.w >= ALL_SMOOTH) ? 1.0 : (gl_FragCoord.w < ALL_ROUGH) ? 0.0 : (gl_FragCoord.w - ALL_ROUGH) / (ALL_SMOOTH - ALL_ROUGH);", "    if (alpha < alphaTest) { if (ratio >= 1.0) { discard; return; } alpha = 0.0; }", "    alpha = alpha * ratio + (1.0 - ratio) * value;", "    if (ratio < 1.0 && alpha <= DISCARD_ALPHA) { discard; return; }", "  #endif", "  fragColor = vec4(color, opacity * alpha);", "}"].join("\n")
        })
    }, {
        "./shader": 106
    }],
    106: [function (e, t, n) {
        let i = t.exports.Shader = function () {};
        function r(e, t) {
            switch (e) {
            case "vec2":
                return new THREE.Vector2(t.x, t.y);
            case "vec3":
                return new THREE.Vector3(t.x, t.y, t.z);
            case "vec4":
                return new THREE.Vector4(t.x, t.y, t.z, t.w);
            case "color": {
                const e = new THREE.Color(t);
                return new THREE.Vector3(e.r, e.g, e.b)
            }
            case "map":
                return THREE.ImageUtils.loadTexture(t);
            default:
                return t
            }
        }
        i.prototype = {
            schema: {},
            vertexShader: "void main() {gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);}",
            fragmentShader: "void main() {gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);}",
            init(e) {
                return this.attributes = this.initVariables(e, "attribute"), this.uniforms = this.initVariables(e, "uniform"), this.material = new(this.raw ? THREE.RawShaderMaterial : THREE.ShaderMaterial)({
                    uniforms: this.uniforms,
                    vertexShader: this.vertexShader,
                    fragmentShader: this.fragmentShader
                }), this.material
            },
            initVariables(e, t) {
                const n = this.schema;
                let i = {};
                for (let e in n) {
                    const r = n[e];
                    if (r.is === t) {
                        const t = {
                            array: "v3",
                            color: "v3",
                            int: "i",
                            number: "f",
                            map: "t",
                            time: "f",
                            vec2: "v2",
                            vec3: "v3",
                            vec4: "v4"
                        } [r.type];
                        i[e] = {
                            type: t,
                            value: void 0
                        }
                    }
                }
                return i
            },
            update(e) {
                this.updateVariables(e, "attribute"), this.updateVariables(e, "uniform")
            },
            updateVariables(t, n) {
                const i = this;
                let a = "uniform" === n ? i.uniforms : i.attributes;
                for (let s in t) {
                    let o = i.schema[s];
                    if (!o || o.is !== n) continue;
                    let l = a[s];
                    if ("map" === o.type) {
                        if (!l || l.value === t[s]) continue;
                        const n = "_texture_" + s;
                        i.el.addEventListener("materialtextureloaded", (() => {
                            l.value = i.material[n], l.needsUpdate = true
                        })), e("../index").material.updateMapMaterialFromData(n, s, i, t)
                    } else l.value = r(o.type, t[s]), l.needsUpdate = true
                }
            }
        };
        let a = t.exports.shaders = {},
            s = t.exports.shaderNames = [];
        t.exports.registerShader = function (t, n) {
            let r = {};
            if (Object.keys(n).forEach((function (e) {
                    r[e] = {
                        value: n[e],
                        writable: true
                    }
                })), a[t]) throw new Error("The shader " + t + " has been already registered");
            let o = function () {
                i.call(this)
            };
            return (o.prototype = Object.create(i.prototype, r)).name = t, o.prototype.constructor = o, a[t] = {
                Shader: o,
                schema: e("../schema").process(o.prototype.schema)
            }, s.push(t), o
        }
    }, {
        "../index": 96,
        "../schema": 100
    }],
    107: [function (e, t, n) {
        const i = e("../index").material;
        function r(e, t, n) {
            const r = "ambientOcclusion" === e ? "ao" : e,
                a = t.el,
                s = t.material,
                o = n[e + "Map"];
            function l(e) {
                s[r + "Map"] = e, e && ["emissive", "env", "specular"].includes(r) && i.applyColorCorrection(e), s.needsUpdate = true, i.handleTextureEvents(a, e)
            }
            o ? o !== t[e + "TextureSrc"] && (t[e + "TextureSrc"] = o, a.sceneEl.systems.material.loadTexture(o, {
                src: o,
                offset: n[e + "TextureOffset"],
                repeat: n[e + "TextureRepeat"],
                wrap: n[e + "TextureWrap"]
            }, l)) : s.map && l(null)
        }
        function a(e, t) {
            return t.color.set(e.color), t.emissive.set(e.emissive), t.emissiveIntensity = e.emissiveIntensity, t.fog = e.fog, e.usePhong || (t.metalness = e.metalness, t.roughness = e.roughness), t.wireframe = e.wireframe, t.wireframeLinewidth = e.wireframeLinewidth, e.normalMap && (t.normalScale = e.normalScale), e.ambientOcclusionMap && (t.aoMapIntensity = e.ambientOcclusionMapIntensity), e.displacementMap && (t.displacementScale = e.displacementScale, t.displacementBias = e.displacementBias), t
        }
        t.exports.Shader = e("./shader").registerShader("standard", {
            schema: {
                ambientOcclusionMap: {
                    type: "map"
                },
                ambientOcclusionMapIntensity: {
                    default: 1
                },
                ambientOcclusionTextureOffset: {
                    type: "vec2"
                },
                ambientOcclusionTextureRepeat: {
                    type: "vec2",
                    default: {
                        x: 1,
                        y: 1
                    }
                },
                color: {
                    type: "color"
                },
                displacementMap: {
                    type: "map"
                },
                displacementScale: {
                    default: 1
                },
                displacementBias: {
                    default: .5
                },
                displacementTextureOffset: {
                    type: "vec2"
                },
                displacementTextureRepeat: {
                    type: "vec2",
                    default: {
                        x: 1,
                        y: 1
                    }
                },
                emissive: {
                    type: "color",
                    default: "#000"
                },
                emissiveIntensity: {
                    default: 1
                },
                fog: {
                    default: true
                },
                height: {
                    default: 256
                },
                metalness: {
                    default: 0,
                    min: 0,
                    max: 1
                },
                metalnessMap: {
                    type: "map"
                },
                metalnessTextureOffset: {
                    type: "vec2"
                },
                metalnessTextureRepeat: {
                    type: "vec2",
                    default: {
                        x: 1,
                        y: 1
                    }
                },
                normalMap: {
                    type: "map"
                },
                normalScale: {
                    type: "vec2",
                    default: {
                        x: 1,
                        y: 1
                    }
                },
                normalTextureOffset: {
                    type: "vec2"
                },
                normalTextureRepeat: {
                    type: "vec2",
                    default: {
                        x: 1,
                        y: 1
                    }
                },
                offset: {
                    type: "vec2",
                    default: {
                        x: 0,
                        y: 0
                    }
                },
                usePhong: {
                    default: false
                },
                repeat: {
                    type: "vec2",
                    default: {
                        x: 1,
                        y: 1
                    }
                },
                roughness: {
                    default: .5,
                    min: 0,
                    max: 1
                },
                roughnessMap: {
                    type: "map"
                },
                roughnessTextureOffset: {
                    type: "vec2"
                },
                roughnessTextureRepeat: {
                    type: "vec2",
                    default: {
                        x: 1,
                        y: 1
                    }
                },
                src: {
                    type: "map"
                },
                width: {
                    default: 512
                },
                wireframe: {
                    default: false
                },
                wireframeLinewidth: {
                    default: 2
                }
            },
            init(e) {
                this.materialData = {
                    color: new THREE.Color,
                    emissive: new THREE.Color
                }, a(e, this.materialData), i.applyColorCorrection(this.materialData.color), i.applyColorCorrection(this.materialData.emissive);
                const t = e.usePhong ? THREE.MeshPhongMaterial : THREE.MeshStandardMaterial;
                this.material = new t(this.materialData), i.updateMap(this, e), e.normalMap && r("normal", this, e), e.displacementMap && r("displacement", this, e), e.ambientOcclusionMap && r("ambientOcclusion", this, e), e.metalnessMap && r("metalness", this, e), e.roughnessMap && r("roughness", this, e)
            },
            update(e) {
                this.updateMaterial(e), i.updateMap(this, e), e.normalMap && r("normal", this, e), e.displacementMap && r("displacement", this, e), e.ambientOcclusionMap && r("ambientOcclusion", this, e), e.metalnessMap && r("metalness", this, e), e.roughnessMap && r("roughness", this, e)
            },
            updateMaterial(e) {
                a(e, this.materialData), i.applyColorCorrection(this.materialData.color), i.applyColorCorrection(this.materialData.emissive);
                for (let e in this.materialData) this.material[e] = this.materialData[e]
            }
        })
    }, {
        "../index": 96,
        "./shader": 106
    }],
    108: [function (e, t, n) {
        function i(e, t) {
            var n = new Image;
            n.addEventListener("load", (function () {
                t(true)
            })), n.addEventListener("error", (function () {
                t(false)
            })), n.src = e
        }
        t.exports = {
            validateSrc: function (e, t, n) {
                ! function (e, t) {
                    var n;
                    if (e.tagName) return void t("IMG" === e.tagName);
                    (n = new XMLHttpRequest).open("HEAD", e), n.addEventListener("load", (function (r) {
                        var a;
                        n.status >= 200 && n.status < 300 ? null == (a = n.getResponseHeader("Content-Type")) ? i(e, t) : a.startsWith("image") ? t(true) : t(false) : i(e, t), n.abort()
                    })), n.send()
                }(e, (function (i) {
                    i ? t(e) : n(e)
                }))
            }
        }
    }, {}],
    109: [function (e, t, n) {
        const i = /-([a-z])/g;
        function r(e) {
            return e.replace(i, l)
        }
        t.exports.parse = function (e, t) {
            if ("string" != typeof e) return e;
            const n = function (e, t) {
                var n, i, r, a, s, l;
                for (t = t || {}, n = o(e), i = 0; i < n.length; i++)(r = n[i]) && (a = r.indexOf(":"), s = r.substr(0, a).trim(), l = r.substr(a + 1).trim(), t[s] = l);
                return t
            }(e, t);
            return n[""] ? e : function (e) {
                var t, n;
                for (n in e) n !== (t = r(n)) && (e[t] = e[n], delete e[n]);
                return e
            }(n)
        }, t.exports.stringify = function (e) {
            return "string" == typeof e ? e : function (e) {
                var t, n = 0,
                    i = 0,
                    r = "";
                for (t in e) n++;
                for (t in e) r += t + ": " + e[t], i < n - 1 && (r += "; "), i++;
                return r
            }(e)
        };
        var a, s, o = (a = [], s = /url\([^)]+$/, function (e) {
            var t, n = "",
                i = 0;
            for (a.length = 0; i < e.length;) - 1 === (t = e.indexOf(";", i)) && (t = e.length), n += e.substring(i, t), s.test(n) ? (n += ";", i = t + 1) : (a.push(n.trim()), n = "", i = t + 1);
            return a
        });
        function l(e) {
            return e[1].toUpperCase()
        }
    }, {}],
    110: [function (e, t, n) {
        (function (t) {
            (function () {
                var n = t.THREE = e("./three.min");
                n.TextureLoader && (n.TextureLoader.prototype.crossOrigin = "anonymous"), n.ImageLoader && (n.ImageLoader.prototype.crossOrigin = "anonymous"), n.Cache && (n.Cache.enabled = true), e("./postprocessing/EffectComposer"), e("./postprocessing/RenderPass"), e("./postprocessing/ShaderPass"), e("./shaders/FXAAShader"), e("./loaders/DRACOLoader"), e("./loaders/GLTFLoader"), e("./loaders/OBJLoader"), e("./loaders/MTLLoader"), e("./loaders/RGBELoader"), n.loaderResolve = {
                    method: "locate",
                    identifier: "name",
                    direction: "to"
                }, n.loaderContext = globalThis, n.DRACOLoader.prototype.crossOrigin = "anonymous", n.GLTFLoader.prototype.crossOrigin = "anonymous", n.MTLLoader.prototype.crossOrigin = "anonymous", n.OBJLoader.prototype.crossOrigin = "anonymous"
            }).call(this)
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {
        "./loaders/DRACOLoader": 111,
        "./loaders/GLTFLoader": 112,
        "./loaders/MTLLoader": 113,
        "./loaders/OBJLoader": 114,
        "./loaders/RGBELoader": 115,
        "./postprocessing/EffectComposer": 116,
        "./postprocessing/RenderPass": 117,
        "./postprocessing/ShaderPass": 118,
        "./shaders/FXAAShader": 119,
        "./three.min": 120
    }],
    111: [function (e, t, n) {
        THREE.DRACOLoader = function (e) {
            THREE.Loader.call(this, e), this.decoderPath = "", this.decoderConfig = {}, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
                position: "POSITION",
                normal: "NORMAL",
                color: "COLOR",
                uv: "TEX_COORD"
            }, this.defaultAttributeTypes = {
                position: "Float32Array",
                normal: "Float32Array",
                color: "Float32Array",
                uv: "Float32Array"
            }
        }, THREE.DRACOLoader.prototype = Object.assign(Object.create(THREE.Loader.prototype), {
            constructor: THREE.DRACOLoader,
            setDecoderPath: function (e) {
                return this.decoderPath = e, this
            },
            setDecoderConfig: function (e) {
                return this.decoderConfig = e, this
            },
            setWorkerLimit: function (e) {
                return this.workerLimit = e, this
            },
            load: function (e, t, n, i) {
                var r = new THREE.FileLoader(this.manager);
                r.setPath(this.path), r.setResponseType("arraybuffer"), r.setRequestHeader(this.requestHeader), "use-credentials" === this.crossOrigin && r.setWithCredentials(true), r.load(e, (e => {
                    var n = {
                        attributeIDs: this.defaultAttributeIDs,
                        attributeTypes: this.defaultAttributeTypes,
                        useUniqueIDs: false
                    };
                    this.decodeGeometry(e, n).then(t).catch(i)
                }), n, i)
            },
            decodeDracoFile: function (e, t, n, i) {
                var r = {
                    attributeIDs: n || this.defaultAttributeIDs,
                    attributeTypes: i || this.defaultAttributeTypes,
                    useUniqueIDs: !!n
                };
                this.decodeGeometry(e, r).then(t)
            },
            decodeGeometry: function (e, t) {
                for (var n in t.attributeTypes) {
                    var i = t.attributeTypes[n];
                    void 0 !== i.BYTES_PER_ELEMENT && (t.attributeTypes[n] = i.name)
                }
                var r, a = JSON.stringify(t);
                if (THREE.DRACOLoader.taskCache.has(e)) {
                    var s = THREE.DRACOLoader.taskCache.get(e);
                    if (s.key === a) return s.promise;
                    if (0 === e.byteLength) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
                }
                var o = this.workerNextTaskID++,
                    l = e.byteLength,
                    c = this._getWorker(o, l).then((n => (r = n, new Promise(((n, i) => {
                        r._callbacks[o] = {
                            resolve: n,
                            reject: i
                        }, r.postMessage({
                            type: "decode",
                            id: o,
                            taskConfig: t,
                            buffer: e
                        }, [e])
                    }))))).then((e => this._createGeometry(e.geometry)));
                return c.catch((() => true)).then((() => {
                    r && o && this._releaseTask(r, o)
                })), THREE.DRACOLoader.taskCache.set(e, {
                    key: a,
                    promise: c
                }), c
            },
            _createGeometry: function (e) {
                var t = new THREE.BufferGeometry;
                e.index && t.setIndex(new THREE.BufferAttribute(e.index.array, 1));
                for (var n = 0; n < e.attributes.length; n++) {
                    var i = e.attributes[n],
                        r = i.name,
                        a = i.array,
                        s = i.itemSize;
                    t.setAttribute(r, new THREE.BufferAttribute(a, s))
                }
                return t
            },
            _loadLibrary: function (e, t) {
                var n = new THREE.FileLoader(this.manager);
                return n.setPath(this.decoderPath), n.setResponseType(t), new Promise(((t, i) => {
                    n.load(e, t, void 0, i)
                }))
            },
            preload: function () {
                return this._initDecoder(), this
            },
            _initDecoder: function () {
                if (this.decoderPending) return this.decoderPending;
                var e = "object" != typeof WebAssembly || "js" === this.decoderConfig.type,
                    t = [];
                return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((t => {
                    var n = t[0];
                    e || (this.decoderConfig.wasmBinary = t[1]);
                    var i = THREE.DRACOLoader.DRACOWorker.toString(),
                        r = ["", n, "", "", i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))].join("\n");
                    this.workerSourceURL = URL.createObjectURL(new Blob([r]))
                })), this.decoderPending
            },
            _getWorker: function (e, t) {
                return this._initDecoder().then((() => {
                    var n;
                    this.workerPool.length < this.workerLimit ? ((n = new Worker(this.workerSourceURL))._callbacks = {}, n._taskCosts = {}, n._taskLoad = 0, n.postMessage({
                        type: "init",
                        decoderConfig: this.decoderConfig
                    }), n.onmessage = function (e) {
                        var t = e.data;
                        switch (t.type) {
                        case "decode":
                            n._callbacks[t.id].resolve(t);
                            break;
                        case "error":
                            n._callbacks[t.id].reject(t);
                            break;
                        default:
                            console.error('THREE.DRACOLoader: Unexpected message, "' + t.type + '"')
                        }
                    }, this.workerPool.push(n)) : this.workerPool.sort((function (e, t) {
                        return e._taskLoad > t._taskLoad ? -1 : 1
                    }));
                    return (n = this.workerPool[this.workerPool.length - 1])._taskCosts[e] = t, n._taskLoad += t, n
                }))
            },
            _releaseTask: function (e, t) {
                e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t]
            },
            debug: function () {
                console.log("Task load: ", this.workerPool.map((e => e._taskLoad)))
            },
            dispose: function () {
                for (var e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();
                return this.workerPool.length = 0, this
            }
        }), THREE.DRACOLoader.DRACOWorker = function () {
            var e, t;
            function n(e, t, n, i, r, a) {
                var s, o, l = a.num_components(),
                    c = n.num_points() * l;
                switch (r) {
                case Float32Array:
                    s = new e.DracoFloat32Array, t.GetAttributeFloatForAllPoints(n, a, s), o = new Float32Array(c);
                    break;
                case Int8Array:
                    s = new e.DracoInt8Array, t.GetAttributeInt8ForAllPoints(n, a, s), o = new Int8Array(c);
                    break;
                case Int16Array:
                    s = new e.DracoInt16Array, t.GetAttributeInt16ForAllPoints(n, a, s), o = new Int16Array(c);
                    break;
                case Int32Array:
                    s = new e.DracoInt32Array, t.GetAttributeInt32ForAllPoints(n, a, s), o = new Int32Array(c);
                    break;
                case Uint8Array:
                    s = new e.DracoUInt8Array, t.GetAttributeUInt8ForAllPoints(n, a, s), o = new Uint8Array(c);
                    break;
                case Uint16Array:
                    s = new e.DracoUInt16Array, t.GetAttributeUInt16ForAllPoints(n, a, s), o = new Uint16Array(c);
                    break;
                case Uint32Array:
                    s = new e.DracoUInt32Array, t.GetAttributeUInt32ForAllPoints(n, a, s), o = new Uint32Array(c);
                    break;
                default:
                    throw new Error("THREE.DRACOLoader: Unexpected attribute type.")
                }
                for (var u = 0; u < c; u++) o[u] = s.GetValue(u);
                return e.destroy(s), {
                    name: i,
                    array: o,
                    itemSize: l
                }
            }
            onmessage = function (i) {
                var r = i.data;
                switch (r.type) {
                case "init":
                    e = r.decoderConfig, t = new Promise((function (t) {
                        e.onModuleLoaded = function (e) {
                            t({
                                draco: e
                            })
                        }, DracoDecoderModule(e)
                    }));
                    break;
                case "decode":
                    var a = r.buffer,
                        s = r.taskConfig;
                    t.then((e => {
                        var t = e.draco,
                            i = new t.Decoder,
                            o = new t.DecoderBuffer;
                        o.Init(new Int8Array(a), a.byteLength);
                        try {
                            var l = function (e, t, i, r) {
                                    var a, s, o = r.attributeIDs,
                                        l = r.attributeTypes,
                                        c = t.GetEncodedGeometryType(i);
                                    if (c === e.TRIANGULAR_MESH) a = new e.Mesh, s = t.DecodeBufferToMesh(i, a);
                                    else {
                                        if (c !== e.POINT_CLOUD) throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                                        a = new e.PointCloud, s = t.DecodeBufferToPointCloud(i, a)
                                    }
                                    if (!s.ok() || 0 === a.ptr) throw new Error("THREE.DRACOLoader: Decoding failed: " + s.error_msg());
                                    var u = {
                                        index: null,
                                        attributes: []
                                    };
                                    for (var h in o) {
                                        var d, p, f = self[l[h]];
                                        if (r.useUniqueIDs) p = o[h], d = t.GetAttributeByUniqueId(a, p);
                                        else {
                                            if (-1 === (p = t.GetAttributeId(a, e[o[h]]))) continue;
                                            d = t.GetAttribute(a, p)
                                        }
                                        u.attributes.push(n(e, t, a, h, f, d))
                                    }
                                    if (c === e.TRIANGULAR_MESH) {
                                        for (var m = a.num_faces(), g = new Uint32Array(3 * m), v = new e.DracoInt32Array, y = 0; y < m; ++y) {
                                            t.GetFaceFromMesh(a, y, v);
                                            for (var x = 0; x < 3; ++x) g[3 * y + x] = v.GetValue(x)
                                        }
                                        u.index = {
                                            array: g,
                                            itemSize: 1
                                        }, e.destroy(v)
                                    }
                                    return e.destroy(a), u
                                }(t, i, o, s),
                                c = l.attributes.map((e => e.array.buffer));
                            l.index && c.push(l.index.array.buffer), self.postMessage({
                                type: "decode",
                                id: r.id,
                                geometry: l
                            }, c)
                        } catch (e) {
                            console.error(e), self.postMessage({
                                type: "error",
                                id: r.id,
                                error: e.message
                            })
                        } finally {
                            t.destroy(o), t.destroy(i)
                        }
                    }))
                }
            }
        }, THREE.DRACOLoader.taskCache = new WeakMap
    }, {}],
    112: [function (e, t, n) {
        ! function () {
            class e extends THREE.Loader {
                constructor(e) {
                    super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function (e) {
                        return new s(e)
                    })), this.register((function (e) {
                        return new p(e)
                    })), this.register((function (e) {
                        return new f(e)
                    })), this.register((function (e) {
                        return new l(e)
                    })), this.register((function (e) {
                        return new c(e)
                    })), this.register((function (e) {
                        return new u(e)
                    })), this.register((function (e) {
                        return new h(e)
                    })), this.register((function (e) {
                        return new a(e)
                    })), this.register((function (e) {
                        return new d(e)
                    })), this.register((function (e) {
                        return new o(e)
                    })), this.register((function (e) {
                        return new i(e)
                    })), this.register((function (e) {
                        return new m(e)
                    }))
                }
                load(e, t, n, i) {
                    const r = this;
                    let a;
                    a = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : THREE.LoaderUtils.extractUrlBase(e), this.manager.itemStart(e);
                    const s = function (t) {
                            i ? i(t) : console.error(t), r.manager.itemError(e), r.manager.itemEnd(e)
                        },
                        o = new THREE.FileLoader(this.manager);
                    o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, (function (n) {
                        try {
                            r.parse(n, a, (function (n) {
                                t(n), r.manager.itemEnd(e)
                            }), s)
                        } catch (e) {
                            s(e)
                        }
                    }), n, s)
                }
                setDRACOLoader(e) {
                    return this.dracoLoader = e, this
                }
                setDDSLoader() {
                    throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
                }
                setKTX2Loader(e) {
                    return this.ktx2Loader = e, this
                }
                setMeshoptDecoder(e) {
                    return this.meshoptDecoder = e, this
                }
                register(e) {
                    return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this
                }
                unregister(e) {
                    return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
                }
                parse(e, t, i, a) {
                    let s;
                    const o = {},
                        l = {};
                    if ("string" == typeof e) s = e;
                    else {
                        if (THREE.LoaderUtils.decodeText(new Uint8Array(e, 0, 4)) === g) {
                            try {
                                o[n.KHR_BINARY_GLTF] = new x(e)
                            } catch (e) {
                                return void(a && a(e))
                            }
                            s = o[n.KHR_BINARY_GLTF].content
                        } else s = THREE.LoaderUtils.decodeText(new Uint8Array(e))
                    }
                    const c = JSON.parse(s);
                    if (void 0 === c.asset || c.asset.version[0] < 2) return void(a && a(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
                    const u = new Z(c, {
                        path: t || this.resourcePath || "",
                        crossOrigin: this.crossOrigin,
                        requestHeader: this.requestHeader,
                        manager: this.manager,
                        ktx2Loader: this.ktx2Loader,
                        meshoptDecoder: this.meshoptDecoder
                    });
                    u.fileLoader.setRequestHeader(this.requestHeader);
                    for (let e = 0; e < this.pluginCallbacks.length; e++) {
                        const t = this.pluginCallbacks[e](u);
                        l[t.name] = t, o[t.name] = true
                    }
                    if (c.extensionsUsed)
                        for (let e = 0; e < c.extensionsUsed.length; ++e) {
                            const t = c.extensionsUsed[e],
                                i = c.extensionsRequired || [];
                            switch (t) {
                            case n.KHR_MATERIALS_UNLIT:
                                o[t] = new r;
                                break;
                            case n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                                o[t] = new E;
                                break;
                            case n.KHR_DRACO_MESH_COMPRESSION:
                                o[t] = new b(c, this.dracoLoader);
                                break;
                            case n.KHR_TEXTURE_TRANSFORM:
                                o[t] = new _;
                                break;
                            case n.KHR_MESH_QUANTIZATION:
                                o[t] = new M;
                                break;
                            default:
                                i.indexOf(t) >= 0 && void 0 === l[t] && console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".')
                            }
                        }
                    u.setExtensions(o), u.setPlugins(l), u.parse(i, a)
                }
                parseAsync(e, t) {
                    const n = this;
                    return new Promise((function (i, r) {
                        n.parse(e, t, i, r)
                    }))
                }
            }
            function t() {
                let e = {};
                return {
                    get: function (t) {
                        return e[t]
                    },
                    add: function (t, n) {
                        e[t] = n
                    },
                    remove: function (t) {
                        delete e[t]
                    },
                    removeAll: function () {
                        e = {}
                    }
                }
            }
            const n = {
                KHR_BINARY_GLTF: "KHR_binary_glTF",
                KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
                KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
                KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
                KHR_MATERIALS_IOR: "KHR_materials_ior",
                KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
                KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
                KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
                KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
                KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
                KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
                KHR_MATERIALS_VOLUME: "KHR_materials_volume",
                KHR_TEXTURE_BASISU: "KHR_texture_basisu",
                KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
                KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
                KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
                EXT_TEXTURE_WEBP: "EXT_texture_webp",
                EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
            };
            class i {
                constructor(e) {
                    this.parser = e, this.name = n.KHR_LIGHTS_PUNCTUAL, this.cache = {
                        refs: {},
                        uses: {}
                    }
                }
                _markDefs() {
                    const e = this.parser,
                        t = this.parser.json.nodes || [];
                    for (let n = 0, i = t.length; n < i; n++) {
                        const i = t[n];
                        i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && e._addNodeRef(this.cache, i.extensions[this.name].light)
                    }
                }
                _loadLight(e) {
                    const t = this.parser,
                        n = "light:" + e;
                    let i = t.cache.get(n);
                    if (i) return i;
                    const r = t.json,
                        a = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
                    let s;
                    const o = new THREE.Color(16777215);
                    void 0 !== a.color && o.fromArray(a.color);
                    const l = void 0 !== a.range ? a.range : 0;
                    switch (a.type) {
                    case "directional":
                        s = new THREE.DirectionalLight(o), s.target.position.set(0, 0, -1), s.add(s.target);
                        break;
                    case "point":
                        s = new THREE.PointLight(o), s.distance = l;
                        break;
                    case "spot":
                        s = new THREE.SpotLight(o), s.distance = l, a.spot = a.spot || {}, a.spot.innerConeAngle = void 0 !== a.spot.innerConeAngle ? a.spot.innerConeAngle : 0, a.spot.outerConeAngle = void 0 !== a.spot.outerConeAngle ? a.spot.outerConeAngle : Math.PI / 4, s.angle = a.spot.outerConeAngle, s.penumbra = 1 - a.spot.innerConeAngle / a.spot.outerConeAngle, s.target.position.set(0, 0, -1), s.add(s.target);
                        break;
                    default:
                        throw new Error("THREE.GLTFLoader: Unexpected light type: " + a.type)
                    }
                    return s.position.set(0, 0, 0), s.decay = 2, void 0 !== a.intensity && (s.intensity = a.intensity), s.name = t.createUniqueName(a.name || "light_" + e), i = Promise.resolve(s), t.cache.add(n, i), i
                }
                createNodeAttachment(e) {
                    const t = this,
                        n = this.parser,
                        i = n.json.nodes[e],
                        r = (i.extensions && i.extensions[this.name] || {}).light;
                    return void 0 === r ? null : this._loadLight(r).then((function (e) {
                        return n._getNodeRef(t.cache, r, e)
                    }))
                }
            }
            class r {
                constructor() {
                    this.name = n.KHR_MATERIALS_UNLIT
                }
                getMaterialType() {
                    return THREE.MeshBasicMaterial
                }
                extendParams(e, t, n) {
                    const i = [];
                    e.color = new THREE.Color(1, 1, 1), e.opacity = 1;
                    const r = t.pbrMetallicRoughness;
                    if (r) {
                        if (Array.isArray(r.baseColorFactor)) {
                            const t = r.baseColorFactor;
                            e.color.fromArray(t), e.opacity = t[3]
                        }
                        void 0 !== r.baseColorTexture && i.push(n.assignTexture(e, "map", r.baseColorTexture, THREE.sRGBEncoding))
                    }
                    return Promise.all(i)
                }
            }
            class a {
                constructor(e) {
                    this.parser = e, this.name = n.KHR_MATERIALS_EMISSIVE_STRENGTH
                }
                extendMaterialParams(e, t) {
                    const n = this.parser.json.materials[e];
                    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                    const i = n.extensions[this.name].emissiveStrength;
                    return void 0 !== i && (t.emissiveIntensity = i), Promise.resolve()
                }
            }
            class s {
                constructor(e) {
                    this.parser = e, this.name = n.KHR_MATERIALS_CLEARCOAT
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? THREE.MeshPhysicalMaterial : null
                }
                extendMaterialParams(e, t) {
                    const n = this.parser,
                        i = n.json.materials[e];
                    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                    const r = [],
                        a = i.extensions[this.name];
                    if (void 0 !== a.clearcoatFactor && (t.clearcoat = a.clearcoatFactor), void 0 !== a.clearcoatTexture && r.push(n.assignTexture(t, "clearcoatMap", a.clearcoatTexture)), void 0 !== a.clearcoatRoughnessFactor && (t.clearcoatRoughness = a.clearcoatRoughnessFactor), void 0 !== a.clearcoatRoughnessTexture && r.push(n.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), void 0 !== a.clearcoatNormalTexture && (r.push(n.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)), void 0 !== a.clearcoatNormalTexture.scale)) {
                        const e = a.clearcoatNormalTexture.scale;
                        t.clearcoatNormalScale = new THREE.Vector2(e, e)
                    }
                    return Promise.all(r)
                }
            }
            class o {
                constructor(e) {
                    this.parser = e, this.name = n.KHR_MATERIALS_IRIDESCENCE
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? THREE.MeshPhysicalMaterial : null
                }
                extendMaterialParams(e, t) {
                    const n = this.parser,
                        i = n.json.materials[e];
                    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                    const r = [],
                        a = i.extensions[this.name];
                    return void 0 !== a.iridescenceFactor && (t.iridescence = a.iridescenceFactor), void 0 !== a.iridescenceTexture && r.push(n.assignTexture(t, "iridescenceMap", a.iridescenceTexture)), void 0 !== a.iridescenceIor && (t.iridescenceIOR = a.iridescenceIor), void 0 === t.iridescenceThicknessRange && (t.iridescenceThicknessRange = [100, 400]), void 0 !== a.iridescenceThicknessMinimum && (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum), void 0 !== a.iridescenceThicknessMaximum && (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum), void 0 !== a.iridescenceThicknessTexture && r.push(n.assignTexture(t, "iridescenceThicknessMap", a.iridescenceThicknessTexture)), Promise.all(r)
                }
            }
            class l {
                constructor(e) {
                    this.parser = e, this.name = n.KHR_MATERIALS_SHEEN
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? THREE.MeshPhysicalMaterial : null
                }
                extendMaterialParams(e, t) {
                    const n = this.parser,
                        i = n.json.materials[e];
                    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                    const r = [];
                    t.sheenColor = new THREE.Color(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
                    const a = i.extensions[this.name];
                    return void 0 !== a.sheenColorFactor && t.sheenColor.fromArray(a.sheenColorFactor), void 0 !== a.sheenRoughnessFactor && (t.sheenRoughness = a.sheenRoughnessFactor), void 0 !== a.sheenColorTexture && r.push(n.assignTexture(t, "sheenColorMap", a.sheenColorTexture, THREE.sRGBEncoding)), void 0 !== a.sheenRoughnessTexture && r.push(n.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)), Promise.all(r)
                }
            }
            class c {
                constructor(e) {
                    this.parser = e, this.name = n.KHR_MATERIALS_TRANSMISSION
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? THREE.MeshPhysicalMaterial : null
                }
                extendMaterialParams(e, t) {
                    const n = this.parser,
                        i = n.json.materials[e];
                    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                    const r = [],
                        a = i.extensions[this.name];
                    return void 0 !== a.transmissionFactor && (t.transmission = a.transmissionFactor), void 0 !== a.transmissionTexture && r.push(n.assignTexture(t, "transmissionMap", a.transmissionTexture)), Promise.all(r)
                }
            }
            class u {
                constructor(e) {
                    this.parser = e, this.name = n.KHR_MATERIALS_VOLUME
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? THREE.MeshPhysicalMaterial : null
                }
                extendMaterialParams(e, t) {
                    const n = this.parser,
                        i = n.json.materials[e];
                    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                    const r = [],
                        a = i.extensions[this.name];
                    t.thickness = void 0 !== a.thicknessFactor ? a.thicknessFactor : 0, void 0 !== a.thicknessTexture && r.push(n.assignTexture(t, "thicknessMap", a.thicknessTexture)), t.attenuationDistance = a.attenuationDistance || 0;
                    const s = a.attenuationColor || [1, 1, 1];
                    return t.attenuationColor = new THREE.Color(s[0], s[1], s[2]), Promise.all(r)
                }
            }
            class h {
                constructor(e) {
                    this.parser = e, this.name = n.KHR_MATERIALS_IOR
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? THREE.MeshPhysicalMaterial : null
                }
                extendMaterialParams(e, t) {
                    const n = this.parser.json.materials[e];
                    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                    const i = n.extensions[this.name];
                    return t.ior = void 0 !== i.ior ? i.ior : 1.5, Promise.resolve()
                }
            }
            class d {
                constructor(e) {
                    this.parser = e, this.name = n.KHR_MATERIALS_SPECULAR
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? THREE.MeshPhysicalMaterial : null
                }
                extendMaterialParams(e, t) {
                    const n = this.parser,
                        i = n.json.materials[e];
                    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                    const r = [],
                        a = i.extensions[this.name];
                    t.specularIntensity = void 0 !== a.specularFactor ? a.specularFactor : 1, void 0 !== a.specularTexture && r.push(n.assignTexture(t, "specularIntensityMap", a.specularTexture));
                    const s = a.specularColorFactor || [1, 1, 1];
                    return t.specularColor = new THREE.Color(s[0], s[1], s[2]), void 0 !== a.specularColorTexture && r.push(n.assignTexture(t, "specularColorMap", a.specularColorTexture, THREE.sRGBEncoding)), Promise.all(r)
                }
            }
            class p {
                constructor(e) {
                    this.parser = e, this.name = n.KHR_TEXTURE_BASISU
                }
                loadTexture(e) {
                    const t = this.parser,
                        n = t.json,
                        i = n.textures[e];
                    if (!i.extensions || !i.extensions[this.name]) return null;
                    const r = i.extensions[this.name],
                        a = t.options.ktx2Loader;
                    if (!a) {
                        if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                        return null
                    }
                    return t.loadTextureImage(e, r.source, a)
                }
            }
            class f {
                constructor(e) {
                    this.parser = e, this.name = n.EXT_TEXTURE_WEBP, this.isSupported = null
                }
                loadTexture(e) {
                    const t = this.name,
                        n = this.parser,
                        i = n.json,
                        r = i.textures[e];
                    if (!r.extensions || !r.extensions[t]) return null;
                    const a = r.extensions[t],
                        s = i.images[a.source];
                    let o = n.textureLoader;
                    if (s.uri) {
                        const e = n.options.manager.getHandler(s.uri);
                        null !== e && (o = e)
                    }
                    return this.detectSupport().then((function (r) {
                        if (r) return n.loadTextureImage(e, a.source, o);
                        if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                        return n.loadTexture(e)
                    }))
                }
                detectSupport() {
                    return this.isSupported || (this.isSupported = new Promise((function (e) {
                        const t = new Image;
                        t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function () {
                            e(1 === t.height)
                        }
                    }))), this.isSupported
                }
            }
            class m {
                constructor(e) {
                    this.name = n.EXT_MESHOPT_COMPRESSION, this.parser = e
                }
                loadBufferView(e) {
                    const t = this.parser.json,
                        n = t.bufferViews[e];
                    if (n.extensions && n.extensions[this.name]) {
                        const e = n.extensions[this.name],
                            i = this.parser.getDependency("buffer", e.buffer),
                            r = this.parser.options.meshoptDecoder;
                        if (!r || !r.supported) {
                            if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                            return null
                        }
                        return Promise.all([i, r.ready]).then((function (t) {
                            const n = e.byteOffset || 0,
                                i = e.byteLength || 0,
                                a = e.count,
                                s = e.byteStride,
                                o = new ArrayBuffer(a * s),
                                l = new Uint8Array(t[0], n, i);
                            return r.decodeGltfBuffer(new Uint8Array(o), a, s, l, e.mode, e.filter), o
                        }))
                    }
                    return null
                }
            }
            const g = "glTF",
                v = 1313821514,
                y = 5130562;
            class x {
                constructor(e) {
                    this.name = n.KHR_BINARY_GLTF, this.content = null, this.body = null;
                    const t = new DataView(e, 0, 12);
                    if (this.header = {
                            magic: THREE.LoaderUtils.decodeText(new Uint8Array(e.slice(0, 4))),
                            version: t.getUint32(4, true),
                            length: t.getUint32(8, true)
                        }, this.header.magic !== g) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                    if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                    const i = this.header.length - 12,
                        r = new DataView(e, 12);
                    let a = 0;
                    for (; a < i;) {
                        const t = r.getUint32(a, true);
                        a += 4;
                        const n = r.getUint32(a, true);
                        if (a += 4, n === v) {
                            const n = new Uint8Array(e, 12 + a, t);
                            this.content = THREE.LoaderUtils.decodeText(n)
                        } else if (n === y) {
                            const n = 12 + a;
                            this.body = e.slice(n, n + t)
                        }
                        a += t
                    }
                    if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.")
                }
            }
            class b {
                constructor(e, t) {
                    if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                    this.name = n.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload()
                }
                decodePrimitive(e, t) {
                    const n = this.json,
                        i = this.dracoLoader,
                        r = e.extensions[this.name].bufferView,
                        a = e.extensions[this.name].attributes,
                        s = {},
                        o = {},
                        l = {};
                    for (const e in a) {
                        const t = B[e] || e.toLowerCase();
                        s[t] = a[e]
                    }
                    for (const t in e.attributes) {
                        const i = B[t] || t.toLowerCase();
                        if (void 0 !== a[t]) {
                            const r = n.accessors[e.attributes[t]],
                                a = N[r.componentType];
                            l[i] = a, o[i] = !0 === r.normalized
                        }
                    }
                    return t.getDependency("bufferView", r).then((function (e) {
                        return new Promise((function (t) {
                            i.decodeDracoFile(e, (function (e) {
                                for (const t in e.attributes) {
                                    const n = e.attributes[t],
                                        i = o[t];
                                    void 0 !== i && (n.normalized = i)
                                }
                                t(e)
                            }), s, l)
                        }))
                    }))
                }
            }
            class _ {
                constructor() {
                    this.name = n.KHR_TEXTURE_TRANSFORM
                }
                extendTexture(e, t) {
                    return void 0 !== t.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), void 0 === t.offset && void 0 === t.rotation && void 0 === t.scale || (e = e.clone(), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), e.needsUpdate = true), e
                }
            }
            class w extends THREE.MeshStandardMaterial {
                constructor(e) {
                    super(), this.isGLTFSpecularGlossinessMaterial = true;
                    const t = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"),
                        n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"),
                        i = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"),
                        r = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"),
                        a = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"),
                        s = {
                            specular: {
                                value: (new THREE.Color).setHex(16777215)
                            },
                            glossiness: {
                                value: 1
                            },
                            specularMap: {
                                value: null
                            },
                            glossinessMap: {
                                value: null
                            }
                        };
                    this._extraUniforms = s, this.onBeforeCompile = function (e) {
                        for (const t in s) e.uniforms[t] = s[t];
                        e.fragmentShader = e.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", i).replace("#include <metalnessmap_fragment>", r).replace("#include <lights_physical_fragment>", a)
                    }, Object.defineProperties(this, {
                        specular: {
                            get: function () {
                                return s.specular.value
                            },
                            set: function (e) {
                                s.specular.value = e
                            }
                        },
                        specularMap: {
                            get: function () {
                                return s.specularMap.value
                            },
                            set: function (e) {
                                s.specularMap.value = e, e ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
                            }
                        },
                        glossiness: {
                            get: function () {
                                return s.glossiness.value
                            },
                            set: function (e) {
                                s.glossiness.value = e
                            }
                        },
                        glossinessMap: {
                            get: function () {
                                return s.glossinessMap.value
                            },
                            set: function (e) {
                                s.glossinessMap.value = e, e ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV)
                            }
                        }
                    }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.specularMap = e.specularMap, this.specular.copy(e.specular), this.glossinessMap = e.glossinessMap, this.glossiness = e.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this
                }
            }
            class E {
                constructor() {
                    this.name = n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity"]
                }
                getMaterialType() {
                    return w
                }
                extendParams(e, t, n) {
                    const i = t.extensions[this.name];
                    e.color = new THREE.Color(1, 1, 1), e.opacity = 1;
                    const r = [];
                    if (Array.isArray(i.diffuseFactor)) {
                        const t = i.diffuseFactor;
                        e.color.fromArray(t), e.opacity = t[3]
                    }
                    if (void 0 !== i.diffuseTexture && r.push(n.assignTexture(e, "map", i.diffuseTexture, THREE.sRGBEncoding)), e.emissive = new THREE.Color(0, 0, 0), e.glossiness = void 0 !== i.glossinessFactor ? i.glossinessFactor : 1, e.specular = new THREE.Color(1, 1, 1), Array.isArray(i.specularFactor) && e.specular.fromArray(i.specularFactor), void 0 !== i.specularGlossinessTexture) {
                        const t = i.specularGlossinessTexture;
                        r.push(n.assignTexture(e, "glossinessMap", t)), r.push(n.assignTexture(e, "specularMap", t, THREE.sRGBEncoding))
                    }
                    return Promise.all(r)
                }
                createMaterial(e) {
                    const t = new w(e);
                    return t.fog = true, t.color = e.color, t.map = void 0 === e.map ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = void 0 === e.aoMap ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = void 0 === e.emissiveIntensity ? 1 : e.emissiveIntensity, t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap, t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = void 0 === e.normalMap ? null : e.normalMap, t.normalMapType = THREE.TangentSpaceNormalMap, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = void 0 === e.specularMap ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = void 0 === e.envMap ? null : e.envMap, t.envMapIntensity = 1, t
                }
            }
            class M {
                constructor() {
                    this.name = n.KHR_MESH_QUANTIZATION
                }
            }
            class T extends THREE.Interpolant {
                constructor(e, t, n, i) {
                    super(e, t, n, i)
                }
                copySampleValue_(e) {
                    const t = this.resultBuffer,
                        n = this.sampleValues,
                        i = this.valueSize,
                        r = e * i * 3 + i;
                    for (let e = 0; e !== i; e++) t[e] = n[r + e];
                    return t
                }
                interpolate_(e, t, n, i) {
                    const r = this.resultBuffer,
                        a = this.sampleValues,
                        s = this.valueSize,
                        o = 2 * s,
                        l = 3 * s,
                        c = i - t,
                        u = (n - t) / c,
                        h = u * u,
                        d = h * u,
                        p = e * l,
                        f = p - l,
                        m = -2 * d + 3 * h,
                        g = d - h,
                        v = 1 - m,
                        y = g - h + u;
                    for (let e = 0; e !== s; e++) {
                        const t = a[f + e + s],
                            n = a[f + e + o] * c,
                            i = a[p + e + s],
                            l = a[p + e] * c;
                        r[e] = v * t + y * n + m * i + g * l
                    }
                    return r
                }
            }
            const S = new THREE.Quaternion;
            class A extends T {
                interpolate_(e, t, n, i) {
                    const r = super.interpolate_(e, t, n, i);
                    return S.fromArray(r).normalize().toArray(r), r
                }
            }
            const L = 0,
                R = 1,
                P = 2,
                C = 3,
                I = 4,
                F = 5,
                D = 6,
                N = {
                    5120: Int8Array,
                    5121: Uint8Array,
                    5122: Int16Array,
                    5123: Uint16Array,
                    5125: Uint32Array,
                    5126: Float32Array
                },
                O = {
                    9728: THREE.NearestFilter,
                    9729: THREE.LinearFilter,
                    9984: THREE.NearestMipmapNearestFilter,
                    9985: THREE.LinearMipmapNearestFilter,
                    9986: THREE.NearestMipmapLinearFilter,
                    9987: THREE.LinearMipmapLinearFilter
                },
                H = {
                    33071: THREE.ClampToEdgeWrapping,
                    33648: THREE.MirroredRepeatWrapping,
                    10497: THREE.RepeatWrapping
                },
                U = {
                    SCALAR: 1,
                    VEC2: 2,
                    VEC3: 3,
                    VEC4: 4,
                    MAT2: 4,
                    MAT3: 9,
                    MAT4: 16
                },
                B = {
                    POSITION: "position",
                    NORMAL: "normal",
                    TANGENT: "tangent",
                    TEXCOORD_0: "uv",
                    TEXCOORD_1: "uv2",
                    COLOR_0: "color",
                    WEIGHTS_0: "skinWeight",
                    JOINTS_0: "skinIndex"
                },
                z = {
                    scale: "scale",
                    translation: "position",
                    rotation: "quaternion",
                    weights: "morphTargetInfluences"
                },
                k = {
                    CUBICSPLINE: void 0,
                    LINEAR: THREE.InterpolateLinear,
                    STEP: THREE.InterpolateDiscrete
                },
                G = "OPAQUE",
                V = "MASK",
                j = "BLEND";
            function W(e, t, n) {
                for (const i in n.extensions) void 0 === e[i] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[i] = n.extensions[i])
            }
            function X(e, t) {
                void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras))
            }
            function Y(e, t) {
                if (e.updateMorphTargets(), void 0 !== t.weights)
                    for (let n = 0, i = t.weights.length; n < i; n++) e.morphTargetInfluences[n] = t.weights[n];
                if (t.extras && Array.isArray(t.extras.targetNames)) {
                    const n = t.extras.targetNames;
                    if (e.morphTargetInfluences.length === n.length) {
                        e.morphTargetDictionary = {};
                        for (let t = 0, i = n.length; t < i; t++) e.morphTargetDictionary[n[t]] = t
                    } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
                }
            }
            function q(e) {
                const t = e.extensions && e.extensions[n.KHR_DRACO_MESH_COMPRESSION];
                let i;
                return i = t ? "draco:" + t.bufferView + ":" + t.indices + ":" + Q(t.attributes) : e.indices + ":" + Q(e.attributes) + ":" + e.mode, i
            }
            function Q(e) {
                let t = "";
                const n = Object.keys(e).sort();
                for (let i = 0, r = n.length; i < r; i++) t += n[i] + ":" + e[n[i]] + ";";
                return t
            }
            function J(e) {
                switch (e) {
                case Int8Array:
                    return 1 / 127;
                case Uint8Array:
                    return 1 / 255;
                case Int16Array:
                    return 1 / 32767;
                case Uint16Array:
                    return 1 / 65535;
                default:
                    throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
                }
            }
            class Z {
                constructor(e = {}, n = {}) {
                    this.json = e, this.extensions = {}, this.plugins = {}, this.options = n, this.cache = new t, this.associations = new Map, this.primitiveCache = {}, this.meshCache = {
                        refs: {},
                        uses: {}
                    }, this.cameraCache = {
                        refs: {},
                        uses: {}
                    }, this.lightCache = {
                        refs: {},
                        uses: {}
                    }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
                    const i = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
                        r = navigator.userAgent.indexOf("Firefox") > -1,
                        a = r ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
                    "undefined" == typeof createImageBitmap || i || r && a < 98 ? this.textureLoader = new THREE.TextureLoader(this.options.manager) : this.textureLoader = new THREE.ImageBitmapLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new THREE.FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(true)
                }
                setExtensions(e) {
                    this.extensions = e
                }
                setPlugins(e) {
                    this.plugins = e
                }
                parse(e, t) {
                    const n = this,
                        i = this.json,
                        r = this.extensions;
                    this.cache.removeAll(), this._invokeAll((function (e) {
                        return e._markDefs && e._markDefs()
                    })), Promise.all(this._invokeAll((function (e) {
                        return e.beforeRoot && e.beforeRoot()
                    }))).then((function () {
                        return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
                    })).then((function (t) {
                        const a = {
                            scene: t[0][i.scene || 0],
                            scenes: t[0],
                            animations: t[1],
                            cameras: t[2],
                            asset: i.asset,
                            parser: n,
                            userData: {}
                        };
                        W(r, a, i), X(a, i), Promise.all(n._invokeAll((function (e) {
                            return e.afterRoot && e.afterRoot(a)
                        }))).then((function () {
                            e(a)
                        }))
                    })).catch(t)
                }
                _markDefs() {
                    const e = this.json.nodes || [],
                        t = this.json.skins || [],
                        n = this.json.meshes || [];
                    for (let n = 0, i = t.length; n < i; n++) {
                        const i = t[n].joints;
                        for (let t = 0, n = i.length; t < n; t++) e[i[t]].isBone = true
                    }
                    for (let t = 0, i = e.length; t < i; t++) {
                        const i = e[t];
                        void 0 !== i.mesh && (this._addNodeRef(this.meshCache, i.mesh), void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = true)), void 0 !== i.camera && this._addNodeRef(this.cameraCache, i.camera)
                    }
                }
                _addNodeRef(e, t) {
                    void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++)
                }
                _getNodeRef(e, t, n) {
                    if (e.refs[t] <= 1) return n;
                    const i = n.clone(),
                        r = (e, t) => {
                            const n = this.associations.get(e);
                            null != n && this.associations.set(t, n);
                            for (const [n, i] of e.children.entries()) r(i, t.children[n])
                        };
                    return r(n, i), i.name += "_instance_" + e.uses[t]++, i
                }
                _invokeOne(e) {
                    const t = Object.values(this.plugins);
                    t.push(this);
                    for (let n = 0; n < t.length; n++) {
                        const i = e(t[n]);
                        if (i) return i
                    }
                    return null
                }
                _invokeAll(e) {
                    const t = Object.values(this.plugins);
                    t.unshift(this);
                    const n = [];
                    for (let i = 0; i < t.length; i++) {
                        const r = e(t[i]);
                        r && n.push(r)
                    }
                    return n
                }
                getDependency(e, t) {
                    const n = e + ":" + t;
                    let i = this.cache.get(n);
                    if (!i) {
                        switch (e) {
                        case "scene":
                            i = this.loadScene(t);
                            break;
                        case "node":
                            i = this.loadNode(t);
                            break;
                        case "mesh":
                            i = this._invokeOne((function (e) {
                                return e.loadMesh && e.loadMesh(t)
                            }));
                            break;
                        case "accessor":
                            i = this.loadAccessor(t);
                            break;
                        case "bufferView":
                            i = this._invokeOne((function (e) {
                                return e.loadBufferView && e.loadBufferView(t)
                            }));
                            break;
                        case "buffer":
                            i = this.loadBuffer(t);
                            break;
                        case "material":
                            i = this._invokeOne((function (e) {
                                return e.loadMaterial && e.loadMaterial(t)
                            }));
                            break;
                        case "texture":
                            i = this._invokeOne((function (e) {
                                return e.loadTexture && e.loadTexture(t)
                            }));
                            break;
                        case "skin":
                            i = this.loadSkin(t);
                            break;
                        case "animation":
                            i = this._invokeOne((function (e) {
                                return e.loadAnimation && e.loadAnimation(t)
                            }));
                            break;
                        case "camera":
                            i = this.loadCamera(t);
                            break;
                        default:
                            throw new Error("Unknown type: " + e)
                        }
                        this.cache.add(n, i)
                    }
                    return i
                }
                getDependencies(e) {
                    let t = this.cache.get(e);
                    if (!t) {
                        const n = this,
                            i = this.json[e + ("mesh" === e ? "es" : "s")] || [];
                        t = Promise.all(i.map((function (t, i) {
                            return n.getDependency(e, i)
                        }))), this.cache.add(e, t)
                    }
                    return t
                }
                loadBuffer(e) {
                    const t = this.json.buffers[e],
                        i = this.fileLoader;
                    if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
                    if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[n.KHR_BINARY_GLTF].body);
                    const r = this.options;
                    return new Promise((function (e, n) {
                        i.load(THREE.LoaderUtils.resolveURL(t.uri, r.path), e, void 0, (function () {
                            n(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
                        }))
                    }))
                }
                loadBufferView(e) {
                    const t = this.json.bufferViews[e];
                    return this.getDependency("buffer", t.buffer).then((function (e) {
                        const n = t.byteLength || 0,
                            i = t.byteOffset || 0;
                        return e.slice(i, i + n)
                    }))
                }
                loadAccessor(e) {
                    const t = this,
                        n = this.json,
                        i = this.json.accessors[e];
                    if (void 0 === i.bufferView && void 0 === i.sparse) return Promise.resolve(null);
                    const r = [];
                    return void 0 !== i.bufferView ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null), void 0 !== i.sparse && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(r).then((function (e) {
                        const r = e[0],
                            a = U[i.type],
                            s = N[i.componentType],
                            o = s.BYTES_PER_ELEMENT,
                            l = o * a,
                            c = i.byteOffset || 0,
                            u = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0,
                            h = !0 === i.normalized;
                        let d, p;
                        if (u && u !== l) {
                            const e = Math.floor(c / u),
                                n = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + e + ":" + i.count;
                            let l = t.cache.get(n);
                            l || (d = new s(r, e * u, i.count * u / o), l = new THREE.InterleavedBuffer(d, u / o), t.cache.add(n, l)), p = new THREE.InterleavedBufferAttribute(l, a, c % u / o, h)
                        } else d = null === r ? new s(i.count * a) : new s(r, c, i.count * a), p = new THREE.BufferAttribute(d, a, h);
                        if (void 0 !== i.sparse) {
                            const t = U.SCALAR,
                                n = N[i.sparse.indices.componentType],
                                o = i.sparse.indices.byteOffset || 0,
                                l = i.sparse.values.byteOffset || 0,
                                c = new n(e[1], o, i.sparse.count * t),
                                u = new s(e[2], l, i.sparse.count * a);
                            null !== r && (p = new THREE.BufferAttribute(p.array.slice(), p.itemSize, p.normalized));
                            for (let e = 0, t = c.length; e < t; e++) {
                                const t = c[e];
                                if (p.setX(t, u[e * a]), a >= 2 && p.setY(t, u[e * a + 1]), a >= 3 && p.setZ(t, u[e * a + 2]), a >= 4 && p.setW(t, u[e * a + 3]), a >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse THREE.BufferAttribute.")
                            }
                        }
                        return p
                    }))
                }
                loadTexture(e) {
                    const t = this.json,
                        n = this.options,
                        i = t.textures[e].source,
                        r = t.images[i];
                    let a = this.textureLoader;
                    if (r.uri) {
                        const e = n.manager.getHandler(r.uri);
                        null !== e && (a = e)
                    }
                    return this.loadTextureImage(e, i, a)
                }
                loadTextureImage(e, t, n) {
                    const i = this,
                        r = this.json,
                        a = r.textures[e],
                        s = r.images[t],
                        o = (s.uri || s.bufferView) + ":" + a.sampler;
                    if (this.textureCache[o]) return this.textureCache[o];
                    const l = this.loadImageSource(t, n).then((function (t) {
                        t.flipY = false, a.name && (t.name = a.name);
                        const n = (r.samplers || {})[a.sampler] || {};
                        return t.magFilter = O[n.magFilter] || THREE.LinearFilter, t.minFilter = O[n.minFilter] || THREE.LinearMipmapLinearFilter, t.wrapS = H[n.wrapS] || THREE.RepeatWrapping, t.wrapT = H[n.wrapT] || THREE.RepeatWrapping, i.associations.set(t, {
                            textures: e
                        }), t
                    })).catch((function () {
                        return null
                    }));
                    return this.textureCache[o] = l, l
                }
                loadImageSource(e, t) {
                    const n = this,
                        i = this.json,
                        r = this.options;
                    if (void 0 !== this.sourceCache[e]) return this.sourceCache[e].then((e => e.clone()));
                    const a = i.images[e],
                        s = self.URL || self.webkitURL;
                    let o = a.uri || "",
                        l = false;
                    if (void 0 !== a.bufferView) o = n.getDependency("bufferView", a.bufferView).then((function (e) {
                        l = true;
                        const t = new Blob([e], {
                            type: a.mimeType
                        });
                        return o = s.createObjectURL(t), o
                    }));
                    else if (void 0 === a.uri) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
                    const c = Promise.resolve(o).then((function (e) {
                        return new Promise((function (n, i) {
                            let a = n;
                            !0 === t.isImageBitmapLoader && (a = function (e) {
                                const t = new THREE.Texture(e);
                                t.needsUpdate = true, n(t)
                            }), t.load(THREE.LoaderUtils.resolveURL(e, r.path), a, void 0, i)
                        }))
                    })).then((function (e) {
                        var t;
                        return !0 === l && s.revokeObjectURL(o), e.userData.mimeType = a.mimeType || ((t = a.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/) ? "image/jpeg" : t.search(/\.webp($|\?)/i) > 0 || 0 === t.search(/^data\:image\/webp/) ? "image/webp" : "image/png"), e
                    })).catch((function (e) {
                        throw console.error("THREE.GLTFLoader: Couldn't load texture", o), e
                    }));
                    return this.sourceCache[e] = c, c
                }
                assignTexture(e, t, i, r) {
                    const a = this;
                    return this.getDependency("texture", i.index).then((function (s) {
                        if (void 0 === i.texCoord || 0 == i.texCoord || "aoMap" === t && 1 == i.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + i.texCoord + " for texture " + t + " not yet supported."), a.extensions[n.KHR_TEXTURE_TRANSFORM]) {
                            const e = void 0 !== i.extensions ? i.extensions[n.KHR_TEXTURE_TRANSFORM] : void 0;
                            if (e) {
                                const t = a.associations.get(s);
                                s = a.extensions[n.KHR_TEXTURE_TRANSFORM].extendTexture(s, e), a.associations.set(s, t)
                            }
                        }
                        return void 0 !== r && (s.encoding = r), e[t] = s, s
                    }))
                }
                assignFinalMaterial(e) {
                    const t = e.geometry;
                    let n = e.material;
                    const i = void 0 === t.attributes.tangent,
                        r = void 0 !== t.attributes.color,
                        a = void 0 === t.attributes.normal;
                    if (e.isPoints) {
                        const e = "PointsMaterial:" + n.uuid;
                        let t = this.cache.get(e);
                        t || (t = new THREE.PointsMaterial, THREE.Material.prototype.copy.call(t, n), t.color.copy(n.color), t.map = n.map, t.sizeAttenuation = false, this.cache.add(e, t)), n = t
                    } else if (e.isLine) {
                        const e = "LineBasicMaterial:" + n.uuid;
                        let t = this.cache.get(e);
                        t || (t = new THREE.LineBasicMaterial, THREE.Material.prototype.copy.call(t, n), t.color.copy(n.color), this.cache.add(e, t)), n = t
                    }
                    if (i || r || a) {
                        let e = "ClonedMaterial:" + n.uuid + ":";
                        n.isGLTFSpecularGlossinessMaterial && (e += "specular-glossiness:"), i && (e += "derivative-tangents:"), r && (e += "vertex-colors:"), a && (e += "flat-shading:");
                        let t = this.cache.get(e);
                        t || (t = n.clone(), r && (t.vertexColors = true), a && (t.flatShading = true), i && (t.normalScale && (t.normalScale.y *= -1), t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)), this.cache.add(e, t), this.associations.set(t, this.associations.get(n))), n = t
                    }
                    n.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && t.setAttribute("uv2", t.attributes.uv), e.material = n
                }
                getMaterialType() {
                    return THREE.MeshStandardMaterial
                }
                loadMaterial(e) {
                    const t = this,
                        i = this.json,
                        r = this.extensions,
                        a = i.materials[e];
                    let s;
                    const o = {},
                        l = a.extensions || {},
                        c = [];
                    if (l[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                        const e = r[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                        s = e.getMaterialType(), c.push(e.extendParams(o, a, t))
                    } else if (l[n.KHR_MATERIALS_UNLIT]) {
                        const e = r[n.KHR_MATERIALS_UNLIT];
                        s = e.getMaterialType(), c.push(e.extendParams(o, a, t))
                    } else {
                        const n = a.pbrMetallicRoughness || {};
                        if (o.color = new THREE.Color(1, 1, 1), o.opacity = 1, Array.isArray(n.baseColorFactor)) {
                            const e = n.baseColorFactor;
                            o.color.fromArray(e), o.opacity = e[3]
                        }
                        void 0 !== n.baseColorTexture && c.push(t.assignTexture(o, "map", n.baseColorTexture, THREE.sRGBEncoding)), o.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1, o.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1, void 0 !== n.metallicRoughnessTexture && (c.push(t.assignTexture(o, "metalnessMap", n.metallicRoughnessTexture)), c.push(t.assignTexture(o, "roughnessMap", n.metallicRoughnessTexture))), s = this._invokeOne((function (t) {
                            return t.getMaterialType && t.getMaterialType(e)
                        })), c.push(Promise.all(this._invokeAll((function (t) {
                            return t.extendMaterialParams && t.extendMaterialParams(e, o)
                        }))))
                    }!0 === a.doubleSided && (o.side = THREE.DoubleSide);
                    const u = a.alphaMode || G;
                    if (u === j ? (o.transparent = true, o.depthWrite = false) : (o.transparent = false, u === V && (o.alphaTest = void 0 !== a.alphaCutoff ? a.alphaCutoff : .5)), void 0 !== a.normalTexture && s !== THREE.MeshBasicMaterial && (c.push(t.assignTexture(o, "normalMap", a.normalTexture)), o.normalScale = new THREE.Vector2(1, 1), void 0 !== a.normalTexture.scale)) {
                        const e = a.normalTexture.scale;
                        o.normalScale.set(e, e)
                    }
                    return void 0 !== a.occlusionTexture && s !== THREE.MeshBasicMaterial && (c.push(t.assignTexture(o, "aoMap", a.occlusionTexture)), void 0 !== a.occlusionTexture.strength && (o.aoMapIntensity = a.occlusionTexture.strength)), void 0 !== a.emissiveFactor && s !== THREE.MeshBasicMaterial && (o.emissive = (new THREE.Color).fromArray(a.emissiveFactor)), void 0 !== a.emissiveTexture && s !== THREE.MeshBasicMaterial && c.push(t.assignTexture(o, "emissiveMap", a.emissiveTexture, THREE.sRGBEncoding)), Promise.all(c).then((function () {
                        let i;
                        return i = s === w ? r[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(o) : new s(o), a.name && (i.name = a.name), X(i, a), t.associations.set(i, {
                            materials: e
                        }), a.extensions && W(r, i, a), i
                    }))
                }
                createUniqueName(e) {
                    const t = THREE.PropertyBinding.sanitizeNodeName(e || "");
                    let n = t;
                    for (let e = 1; this.nodeNamesUsed[n]; ++e) n = t + "_" + e;
                    return this.nodeNamesUsed[n] = true, n
                }
                loadGeometries(e) {
                    const t = this,
                        i = this.extensions,
                        r = this.primitiveCache;
                    function a(e) {
                        return i[n.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function (n) {
                            return $(n, e, t)
                        }))
                    }
                    const s = [];
                    for (let i = 0, o = e.length; i < o; i++) {
                        const o = e[i],
                            l = q(o),
                            c = r[l];
                        if (c) s.push(c.promise);
                        else {
                            let e;
                            e = o.extensions && o.extensions[n.KHR_DRACO_MESH_COMPRESSION] ? a(o) : $(new THREE.BufferGeometry, o, t), r[l] = {
                                primitive: o,
                                promise: e
                            }, s.push(e)
                        }
                    }
                    return Promise.all(s)
                }
                loadMesh(e) {
                    const t = this,
                        n = this.json,
                        i = this.extensions,
                        r = n.meshes[e],
                        a = r.primitives,
                        s = [];
                    for (let e = 0, t = a.length; e < t; e++) {
                        const t = void 0 === a[e].material ? (void 0 === (o = this.cache).DefaultMaterial && (o.DefaultMaterial = new THREE.MeshStandardMaterial({
                            color: 16777215,
                            emissive: 0,
                            metalness: 1,
                            roughness: 1,
                            transparent: false,
                            depthTest: true,
                            side: THREE.FrontSide
                        })), o.DefaultMaterial) : this.getDependency("material", a[e].material);
                        s.push(t)
                    }
                    var o;
                    return s.push(t.loadGeometries(a)), Promise.all(s).then((function (n) {
                        const s = n.slice(0, n.length - 1),
                            o = n[n.length - 1],
                            l = [];
                        for (let n = 0, c = o.length; n < c; n++) {
                            const c = o[n],
                                u = a[n];
                            let h;
                            const d = s[n];
                            if (u.mode === I || u.mode === F || u.mode === D || void 0 === u.mode) h = !0 === r.isSkinnedMesh ? new THREE.SkinnedMesh(c, d) : new THREE.Mesh(c, d), !0 !== h.isSkinnedMesh || h.geometry.attributes.skinWeight.normalized || h.normalizeSkinWeights(), u.mode === F ? h.geometry = ee(h.geometry, THREE.TriangleStripDrawMode) : u.mode === D && (h.geometry = ee(h.geometry, THREE.TriangleFanDrawMode));
                            else if (u.mode === R) h = new THREE.LineSegments(c, d);
                            else if (u.mode === C) h = new THREE.Line(c, d);
                            else if (u.mode === P) h = new THREE.LineLoop(c, d);
                            else {
                                if (u.mode !== L) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + u.mode);
                                h = new THREE.Points(c, d)
                            }
                            Object.keys(h.geometry.morphAttributes).length > 0 && Y(h, r), h.name = t.createUniqueName(r.name || "mesh_" + e), X(h, r), u.extensions && W(i, h, u), t.assignFinalMaterial(h), l.push(h)
                        }
                        for (let n = 0, i = l.length; n < i; n++) t.associations.set(l[n], {
                            meshes: e,
                            primitives: n
                        });
                        if (1 === l.length) return l[0];
                        const c = new THREE.Group;
                        t.associations.set(c, {
                            meshes: e
                        });
                        for (let e = 0, t = l.length; e < t; e++) c.add(l[e]);
                        return c
                    }))
                }
                loadCamera(e) {
                    let t;
                    const n = this.json.cameras[e],
                        i = n[n.type];
                    if (i) return "perspective" === n.type ? t = new THREE.PerspectiveCamera(THREE.MathUtils.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : "orthographic" === n.type && (t = new THREE.OrthographicCamera(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (t.name = this.createUniqueName(n.name)), X(t, n), Promise.resolve(t);
                    console.warn("THREE.GLTFLoader: Missing camera parameters.")
                }
                loadSkin(e) {
                    const t = this.json.skins[e],
                        n = {
                            joints: t.joints
                        };
                    return void 0 === t.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", t.inverseBindMatrices).then((function (e) {
                        return n.inverseBindMatrices = e, n
                    }))
                }
                loadAnimation(e) {
                    const t = this.json.animations[e],
                        n = [],
                        i = [],
                        r = [],
                        a = [],
                        s = [];
                    for (let e = 0, o = t.channels.length; e < o; e++) {
                        const o = t.channels[e],
                            l = t.samplers[o.sampler],
                            c = o.target,
                            u = void 0 !== c.node ? c.node : c.id,
                            h = void 0 !== t.parameters ? t.parameters[l.input] : l.input,
                            d = void 0 !== t.parameters ? t.parameters[l.output] : l.output;
                        n.push(this.getDependency("node", u)), i.push(this.getDependency("accessor", h)), r.push(this.getDependency("accessor", d)), a.push(l), s.push(c)
                    }
                    return Promise.all([Promise.all(n), Promise.all(i), Promise.all(r), Promise.all(a), Promise.all(s)]).then((function (n) {
                        const i = n[0],
                            r = n[1],
                            a = n[2],
                            s = n[3],
                            o = n[4],
                            l = [];
                        for (let e = 0, t = i.length; e < t; e++) {
                            const t = i[e],
                                n = r[e],
                                c = a[e],
                                u = s[e],
                                h = o[e];
                            if (void 0 === t) continue;
                            let d;
                            switch (t.updateMatrix(), z[h.path]) {
                            case z.weights:
                                d = THREE.NumberKeyframeTrack;
                                break;
                            case z.rotation:
                                d = THREE.QuaternionKeyframeTrack;
                                break;
                            default:
                                d = THREE.VectorKeyframeTrack
                            }
                            const p = t.name ? t.name : t.uuid,
                                f = void 0 !== u.interpolation ? k[u.interpolation] : THREE.InterpolateLinear,
                                m = [];
                            z[h.path] === z.weights ? t.traverse((function (e) {
                                e.morphTargetInfluences && m.push(e.name ? e.name : e.uuid)
                            })) : m.push(p);
                            let g = c.array;
                            if (c.normalized) {
                                const e = J(g.constructor),
                                    t = new Float32Array(g.length);
                                for (let n = 0, i = g.length; n < i; n++) t[n] = g[n] * e;
                                g = t
                            }
                            for (let e = 0, t = m.length; e < t; e++) {
                                const t = new d(m[e] + "." + z[h.path], n.array, g, f);
                                "CUBICSPLINE" === u.interpolation && (t.createInterpolant = function (e) {
                                    return new(this instanceof THREE.QuaternionKeyframeTrack ? A : T)(this.times, this.values, this.getValueSize() / 3, e)
                                }, t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true), l.push(t)
                            }
                        }
                        const c = t.name ? t.name : "animation_" + e;
                        return new THREE.AnimationClip(c, void 0, l)
                    }))
                }
                createNodeMesh(e) {
                    const t = this.json,
                        n = this,
                        i = t.nodes[e];
                    return void 0 === i.mesh ? null : n.getDependency("mesh", i.mesh).then((function (e) {
                        const t = n._getNodeRef(n.meshCache, i.mesh, e);
                        return void 0 !== i.weights && t.traverse((function (e) {
                            if (e.isMesh)
                                for (let t = 0, n = i.weights.length; t < n; t++) e.morphTargetInfluences[t] = i.weights[t]
                        })), t
                    }))
                }
                loadNode(e) {
                    const t = this.json,
                        n = this.extensions,
                        i = this,
                        r = t.nodes[e],
                        a = r.name ? i.createUniqueName(r.name) : "";
                    return function () {
                        const t = [],
                            n = i._invokeOne((function (t) {
                                return t.createNodeMesh && t.createNodeMesh(e)
                            }));
                        return n && t.push(n), void 0 !== r.camera && t.push(i.getDependency("camera", r.camera).then((function (e) {
                            return i._getNodeRef(i.cameraCache, r.camera, e)
                        }))), i._invokeAll((function (t) {
                            return t.createNodeAttachment && t.createNodeAttachment(e)
                        })).forEach((function (e) {
                            t.push(e)
                        })), Promise.all(t)
                    }().then((function (t) {
                        let s;
                        if (s = !0 === r.isBone ? new THREE.Bone : t.length > 1 ? new THREE.Group : 1 === t.length ? t[0] : new THREE.Object3D, s !== t[0])
                            for (let e = 0, n = t.length; e < n; e++) s.add(t[e]);
                        if (r.name && (s.userData.name = r.name, s.name = a), X(s, r), r.extensions && W(n, s, r), void 0 !== r.matrix) {
                            const e = new THREE.Matrix4;
                            e.fromArray(r.matrix), s.applyMatrix4(e)
                        } else void 0 !== r.translation && s.position.fromArray(r.translation), void 0 !== r.rotation && s.quaternion.fromArray(r.rotation), void 0 !== r.scale && s.scale.fromArray(r.scale);
                        return i.associations.has(s) || i.associations.set(s, {}), i.associations.get(s).nodes = e, s
                    }))
                }
                loadScene(e) {
                    const t = this.json,
                        n = this.extensions,
                        i = this.json.scenes[e],
                        r = this,
                        a = new THREE.Group;
                    i.name && (a.name = r.createUniqueName(i.name)), X(a, i), i.extensions && W(n, a, i);
                    const s = i.nodes || [],
                        o = [];
                    for (let e = 0, n = s.length; e < n; e++) o.push(K(s[e], a, t, r));
                    return Promise.all(o).then((function () {
                        return r.associations = (e => {
                            const t = new Map;
                            for (const [e, n] of r.associations)(e instanceof THREE.Material || e instanceof THREE.Texture) && t.set(e, n);
                            return e.traverse((e => {
                                const n = r.associations.get(e);
                                null != n && t.set(e, n)
                            })), t
                        })(a), a
                    }))
                }
            }
            function K(e, t, n, i) {
                const r = n.nodes[e];
                return i.getDependency("node", e).then((function (e) {
                    if (void 0 === r.skin) return e;
                    let t;
                    return i.getDependency("skin", r.skin).then((function (e) {
                        t = e;
                        const n = [];
                        for (let e = 0, r = t.joints.length; e < r; e++) n.push(i.getDependency("node", t.joints[e]));
                        return Promise.all(n)
                    })).then((function (n) {
                        return e.traverse((function (e) {
                            if (!e.isMesh) return;
                            const i = [],
                                r = [];
                            for (let e = 0, a = n.length; e < a; e++) {
                                const a = n[e];
                                if (a) {
                                    i.push(a);
                                    const n = new THREE.Matrix4;
                                    void 0 !== t.inverseBindMatrices && n.fromArray(t.inverseBindMatrices.array, 16 * e), r.push(n)
                                } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[e])
                            }
                            e.bind(new THREE.Skeleton(i, r), e.matrixWorld)
                        })), e
                    }))
                })).then((function (e) {
                    t.add(e);
                    const a = [];
                    if (r.children) {
                        const t = r.children;
                        for (let r = 0, s = t.length; r < s; r++) {
                            const s = t[r];
                            a.push(K(s, e, n, i))
                        }
                    }
                    return Promise.all(a)
                }))
            }
            function $(e, t, n) {
                const i = t.attributes,
                    r = [];
                function a(t, i) {
                    return n.getDependency("accessor", t).then((function (t) {
                        e.setAttribute(i, t)
                    }))
                }
                for (const t in i) {
                    const n = B[t] || t.toLowerCase();
                    n in e.attributes || r.push(a(i[t], n))
                }
                if (void 0 !== t.indices && !e.index) {
                    const i = n.getDependency("accessor", t.indices).then((function (t) {
                        e.setIndex(t)
                    }));
                    r.push(i)
                }
                return X(e, t),
                    function (e, t, n) {
                        const i = t.attributes,
                            r = new THREE.Box3;
                        if (void 0 === i.POSITION) return; {
                            const e = n.json.accessors[i.POSITION],
                                t = e.min,
                                a = e.max;
                            if (void 0 === t || void 0 === a) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                            if (r.set(new THREE.Vector3(t[0], t[1], t[2]), new THREE.Vector3(a[0], a[1], a[2])), e.normalized) {
                                const t = J(N[e.componentType]);
                                r.min.multiplyScalar(t), r.max.multiplyScalar(t)
                            }
                        }
                        const a = t.targets;
                        if (void 0 !== a) {
                            const e = new THREE.Vector3,
                                t = new THREE.Vector3;
                            for (let i = 0, r = a.length; i < r; i++) {
                                const r = a[i];
                                if (void 0 !== r.POSITION) {
                                    const i = n.json.accessors[r.POSITION],
                                        a = i.min,
                                        s = i.max;
                                    if (void 0 !== a && void 0 !== s) {
                                        if (t.setX(Math.max(Math.abs(a[0]), Math.abs(s[0]))), t.setY(Math.max(Math.abs(a[1]), Math.abs(s[1]))), t.setZ(Math.max(Math.abs(a[2]), Math.abs(s[2]))), i.normalized) {
                                            const e = J(N[i.componentType]);
                                            t.multiplyScalar(e)
                                        }
                                        e.max(t)
                                    } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                                }
                            }
                            r.expandByVector(e)
                        }
                        e.boundingBox = r;
                        const s = new THREE.Sphere;
                        r.getCenter(s.center), s.radius = r.min.distanceTo(r.max) / 2, e.boundingSphere = s
                    }(e, t, n), Promise.all(r).then((function () {
                        return void 0 !== t.targets ? function (e, t, n) {
                            let i = false,
                                r = false,
                                a = false;
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e];
                                if (void 0 !== n.POSITION && (i = true), void 0 !== n.NORMAL && (r = true), void 0 !== n.COLOR_0 && (a = true), i && r && a) break
                            }
                            if (!i && !r && !a) return Promise.resolve(e);
                            const s = [],
                                o = [],
                                l = [];
                            for (let c = 0, u = t.length; c < u; c++) {
                                const u = t[c];
                                if (i) {
                                    const t = void 0 !== u.POSITION ? n.getDependency("accessor", u.POSITION) : e.attributes.position;
                                    s.push(t)
                                }
                                if (r) {
                                    const t = void 0 !== u.NORMAL ? n.getDependency("accessor", u.NORMAL) : e.attributes.normal;
                                    o.push(t)
                                }
                                if (a) {
                                    const t = void 0 !== u.COLOR_0 ? n.getDependency("accessor", u.COLOR_0) : e.attributes.color;
                                    l.push(t)
                                }
                            }
                            return Promise.all([Promise.all(s), Promise.all(o), Promise.all(l)]).then((function (t) {
                                const n = t[0],
                                    s = t[1],
                                    o = t[2];
                                return i && (e.morphAttributes.position = n), r && (e.morphAttributes.normal = s), a && (e.morphAttributes.color = o), e.morphTargetsRelative = true, e
                            }))
                        }(e, t.targets, n) : e
                    }))
            }
            function ee(e, t) {
                let n = e.getIndex();
                if (null === n) {
                    const t = [],
                        i = e.getAttribute("position");
                    if (void 0 === i) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e;
                    for (let e = 0; e < i.count; e++) t.push(e);
                    e.setIndex(t), n = e.getIndex()
                }
                const i = n.count - 2,
                    r = [];
                if (t === THREE.TriangleFanDrawMode)
                    for (let e = 1; e <= i; e++) r.push(n.getX(0)), r.push(n.getX(e)), r.push(n.getX(e + 1));
                else
                    for (let e = 0; e < i; e++) e % 2 == 0 ? (r.push(n.getX(e)), r.push(n.getX(e + 1)), r.push(n.getX(e + 2))) : (r.push(n.getX(e + 2)), r.push(n.getX(e + 1)), r.push(n.getX(e)));
                r.length / 3 !== i && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                const a = e.clone();
                return a.setIndex(r), a
            }
            THREE.GLTFLoader = e
        }()
    }, {}],
    113: [function (e, t, n) {
        THREE.MTLLoader = function (e) {
            THREE.Loader.call(this, e)
        }, THREE.MTLLoader.prototype = Object.assign(Object.create(THREE.Loader.prototype), {
            constructor: THREE.MTLLoader,
            load: function (e, t, n, i) {
                var r = this,
                    a = "" === this.path ? THREE.LoaderUtils.extractUrlBase(e) : this.path,
                    s = new THREE.FileLoader(this.manager);
                s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.load(e, (function (n) {
                    try {
                        t(r.parse(n, a))
                    } catch (t) {
                        i ? i(t) : console.error(t), r.manager.itemError(e)
                    }
                }), n, i)
            },
            setMaterialOptions: function (e) {
                return this.materialOptions = e, this
            },
            parse: function (e, t) {
                for (var n = e.split("\n"), i = {}, r = /\s+/, a = {}, s = 0; s < n.length; s++) {
                    var o = n[s];
                    if (0 !== (o = o.trim()).length && "#" !== o.charAt(0)) {
                        var l = o.indexOf(" "),
                            c = l >= 0 ? o.substring(0, l) : o;
                        c = c.toLowerCase();
                        var u = l >= 0 ? o.substring(l + 1) : "";
                        if (u = u.trim(), "newmtl" === c) i = {
                            name: u
                        }, a[u] = i;
                        else if ("ka" === c || "kd" === c || "ks" === c || "ke" === c) {
                            var h = u.split(r, 3);
                            i[c] = [parseFloat(h[0]), parseFloat(h[1]), parseFloat(h[2])]
                        } else i[c] = u
                    }
                }
                var d = new THREE.MTLLoader.MaterialCreator(this.resourcePath || t, this.materialOptions);
                return d.setCrossOrigin(this.crossOrigin), d.setManager(this.manager), d.setMaterials(a), d
            }
        }), THREE.MTLLoader.MaterialCreator = function (e, t) {
            this.baseUrl = e || "", this.options = t, this.materialsInfo = {}, this.materials = {}, this.materialsArray = [], this.nameLookup = {}, this.side = this.options && this.options.side ? this.options.side : THREE.FrontSide, this.wrap = this.options && this.options.wrap ? this.options.wrap : THREE.RepeatWrapping
        }, THREE.MTLLoader.MaterialCreator.prototype = {
            constructor: THREE.MTLLoader.MaterialCreator,
            crossOrigin: "anonymous",
            setCrossOrigin: function (e) {
                return this.crossOrigin = e, this
            },
            setManager: function (e) {
                this.manager = e
            },
            setMaterials: function (e) {
                this.materialsInfo = this.convert(e), this.materials = {}, this.materialsArray = [], this.nameLookup = {}
            },
            convert: function (e) {
                if (!this.options) return e;
                var t = {};
                for (var n in e) {
                    var i = e[n],
                        r = {};
                    for (var a in t[n] = r, i) {
                        var s = true,
                            o = i[a],
                            l = a.toLowerCase();
                        switch (l) {
                        case "kd":
                        case "ka":
                        case "ks":
                            this.options && this.options.normalizeRGB && (o = [o[0] / 255, o[1] / 255, o[2] / 255]), this.options && this.options.ignoreZeroRGBs && 0 === o[0] && 0 === o[1] && 0 === o[2] && (s = false)
                        }
                        s && (r[l] = o)
                    }
                }
                return t
            },
            preload: function () {
                for (var e in this.materialsInfo) this.create(e)
            },
            getIndex: function (e) {
                return this.nameLookup[e]
            },
            getAsArray: function () {
                var e = 0;
                for (var t in this.materialsInfo) this.materialsArray[e] = this.create(t), this.nameLookup[t] = e, e++;
                return this.materialsArray
            },
            create: function (e) {
                return void 0 === this.materials[e] && this.createMaterial_(e), this.materials[e]
            },
            createMaterial_: function (e) {
                var t = this,
                    n = this.materialsInfo[e],
                    i = {
                        name: e,
                        side: this.side
                    };
                function r(e, n) {
                    if (!i[e]) {
                        var r, a, s = t.getTextureParams(n, i),
                            o = t.loadTexture((r = t.baseUrl, "string" != typeof (a = s.url) || "" === a ? "" : /^https?:\/\//i.test(a) ? a : r + a));
                        o.repeat.copy(s.scale), o.offset.copy(s.offset), o.wrapS = t.wrap, o.wrapT = t.wrap, i[e] = o
                    }
                }
                for (var a in n) {
                    var s, o = n[a];
                    if ("" !== o) switch (a.toLowerCase()) {
                    case "kd":
                        i.color = (new THREE.Color).fromArray(o);
                        break;
                    case "ks":
                        i.specular = (new THREE.Color).fromArray(o);
                        break;
                    case "ke":
                        i.emissive = (new THREE.Color).fromArray(o);
                        break;
                    case "map_kd":
                        r("map", o);
                        break;
                    case "map_ks":
                        r("specularMap", o);
                        break;
                    case "map_ke":
                        r("emissiveMap", o);
                        break;
                    case "norm":
                        r("normalMap", o);
                        break;
                    case "map_bump":
                    case "bump":
                        r("bumpMap", o);
                        break;
                    case "map_d":
                        r("alphaMap", o), i.transparent = true;
                        break;
                    case "ns":
                        i.shininess = parseFloat(o);
                        break;
                    case "d":
                        (s = parseFloat(o)) < 1 && (i.opacity = s, i.transparent = true);
                        break;
                    case "tr":
                        s = parseFloat(o), this.options && this.options.invertTrProperty && (s = 1 - s), s > 0 && (i.opacity = 1 - s, i.transparent = true)
                    }
                }
                return this.materials[e] = new THREE.MeshPhongMaterial(i), this.materials[e]
            },
            getTextureParams: function (e, t) {
                var n, i = {
                        scale: new THREE.Vector2(1, 1),
                        offset: new THREE.Vector2(0, 0)
                    },
                    r = e.split(/\s+/);
                return (n = r.indexOf("-bm")) >= 0 && (t.bumpScale = parseFloat(r[n + 1]), r.splice(n, 2)), (n = r.indexOf("-s")) >= 0 && (i.scale.set(parseFloat(r[n + 1]), parseFloat(r[n + 2])), r.splice(n, 4)), (n = r.indexOf("-o")) >= 0 && (i.offset.set(parseFloat(r[n + 1]), parseFloat(r[n + 2])), r.splice(n, 4)), i.url = r.join(" ").trim(), i
            },
            loadTexture: function (e, t, n, i, r) {
                var a, s = void 0 !== this.manager ? this.manager : THREE.DefaultLoadingManager,
                    o = s.getHandler(e);
                return null === o && (o = new THREE.TextureLoader(s)), o.setCrossOrigin && o.setCrossOrigin(this.crossOrigin), a = o.load(e, n, i, r), void 0 !== t && (a.mapping = t), a
            }
        }
    }, {}],
    114: [function (e, t, n) {
        THREE.OBJLoader = function () {
            var e = /^[og]\s*(.+)?/,
                t = /^mtllib /,
                n = /^usemtl /,
                i = /^usemap /,
                r = new THREE.Vector3,
                a = new THREE.Vector3,
                s = new THREE.Vector3,
                o = new THREE.Vector3,
                l = new THREE.Vector3;
            function c() {
                var e = {
                    objects: [],
                    object: {},
                    vertices: [],
                    normals: [],
                    colors: [],
                    uvs: [],
                    materials: {},
                    materialLibraries: [],
                    startObject: function (e, t) {
                        if (this.object && !1 === this.object.fromDeclaration) return this.object.name = e, void(this.object.fromDeclaration = !1 !== t);
                        var n = this.object && "function" == typeof this.object.currentMaterial ? this.object.currentMaterial() : void 0;
                        if (this.object && "function" == typeof this.object._finalize && this.object._finalize(true), this.object = {
                                name: e || "",
                                fromDeclaration: !1 !== t,
                                geometry: {
                                    vertices: [],
                                    normals: [],
                                    colors: [],
                                    uvs: [],
                                    hasNormalIndices: false,
                                    hasUVIndices: false
                                },
                                materials: [],
                                smooth: true,
                                startMaterial: function (e, t) {
                                    var n = this._finalize(false);
                                    n && (n.inherited || n.groupCount <= 0) && this.materials.splice(n.index, 1);
                                    var i = {
                                        index: this.materials.length,
                                        name: e || "",
                                        mtllib: Array.isArray(t) && t.length > 0 ? t[t.length - 1] : "",
                                        smooth: void 0 !== n ? n.smooth : this.smooth,
                                        groupStart: void 0 !== n ? n.groupEnd : 0,
                                        groupEnd: -1,
                                        groupCount: -1,
                                        inherited: false,
                                        clone: function (e) {
                                            var t = {
                                                index: "number" == typeof e ? e : this.index,
                                                name: this.name,
                                                mtllib: this.mtllib,
                                                smooth: this.smooth,
                                                groupStart: 0,
                                                groupEnd: -1,
                                                groupCount: -1,
                                                inherited: false
                                            };
                                            return t.clone = this.clone.bind(t), t
                                        }
                                    };
                                    return this.materials.push(i), i
                                },
                                currentMaterial: function () {
                                    if (this.materials.length > 0) return this.materials[this.materials.length - 1]
                                },
                                _finalize: function (e) {
                                    var t = this.currentMaterial();
                                    if (t && -1 === t.groupEnd && (t.groupEnd = this.geometry.vertices.length / 3, t.groupCount = t.groupEnd - t.groupStart, t.inherited = false), e && this.materials.length > 1)
                                        for (var n = this.materials.length - 1; n >= 0; n--) this.materials[n].groupCount <= 0 && this.materials.splice(n, 1);
                                    return e && 0 === this.materials.length && this.materials.push({
                                        name: "",
                                        smooth: this.smooth
                                    }), t
                                }
                            }, n && n.name && "function" == typeof n.clone) {
                            var i = n.clone(0);
                            i.inherited = true, this.object.materials.push(i)
                        }
                        this.objects.push(this.object)
                    },
                    finalize: function () {
                        this.object && "function" == typeof this.object._finalize && this.object._finalize(true)
                    },
                    parseVertexIndex: function (e, t) {
                        var n = parseInt(e, 10);
                        return 3 * (n >= 0 ? n - 1 : n + t / 3)
                    },
                    parseNormalIndex: function (e, t) {
                        var n = parseInt(e, 10);
                        return 3 * (n >= 0 ? n - 1 : n + t / 3)
                    },
                    parseUVIndex: function (e, t) {
                        var n = parseInt(e, 10);
                        return 2 * (n >= 0 ? n - 1 : n + t / 2)
                    },
                    addVertex: function (e, t, n) {
                        var i = this.vertices,
                            r = this.object.geometry.vertices;
                        r.push(i[e + 0], i[e + 1], i[e + 2]), r.push(i[t + 0], i[t + 1], i[t + 2]), r.push(i[n + 0], i[n + 1], i[n + 2])
                    },
                    addVertexPoint: function (e) {
                        var t = this.vertices;
                        this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2])
                    },
                    addVertexLine: function (e) {
                        var t = this.vertices;
                        this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2])
                    },
                    addNormal: function (e, t, n) {
                        var i = this.normals,
                            r = this.object.geometry.normals;
                        r.push(i[e + 0], i[e + 1], i[e + 2]), r.push(i[t + 0], i[t + 1], i[t + 2]), r.push(i[n + 0], i[n + 1], i[n + 2])
                    },
                    addFaceNormal: function (e, t, n) {
                        var i = this.vertices,
                            c = this.object.geometry.normals;
                        r.fromArray(i, e), a.fromArray(i, t), s.fromArray(i, n), l.subVectors(s, a), o.subVectors(r, a), l.cross(o), l.normalize(), c.push(l.x, l.y, l.z), c.push(l.x, l.y, l.z), c.push(l.x, l.y, l.z)
                    },
                    addColor: function (e, t, n) {
                        var i = this.colors,
                            r = this.object.geometry.colors;
                        void 0 !== i[e] && r.push(i[e + 0], i[e + 1], i[e + 2]), void 0 !== i[t] && r.push(i[t + 0], i[t + 1], i[t + 2]), void 0 !== i[n] && r.push(i[n + 0], i[n + 1], i[n + 2])
                    },
                    addUV: function (e, t, n) {
                        var i = this.uvs,
                            r = this.object.geometry.uvs;
                        r.push(i[e + 0], i[e + 1]), r.push(i[t + 0], i[t + 1]), r.push(i[n + 0], i[n + 1])
                    },
                    addDefaultUV: function () {
                        var e = this.object.geometry.uvs;
                        e.push(0, 0), e.push(0, 0), e.push(0, 0)
                    },
                    addUVLine: function (e) {
                        var t = this.uvs;
                        this.object.geometry.uvs.push(t[e + 0], t[e + 1])
                    },
                    addFace: function (e, t, n, i, r, a, s, o, l) {
                        var c = this.vertices.length,
                            u = this.parseVertexIndex(e, c),
                            h = this.parseVertexIndex(t, c),
                            d = this.parseVertexIndex(n, c);
                        if (this.addVertex(u, h, d), this.addColor(u, h, d), void 0 !== s && "" !== s) {
                            var p = this.normals.length;
                            u = this.parseNormalIndex(s, p), h = this.parseNormalIndex(o, p), d = this.parseNormalIndex(l, p), this.addNormal(u, h, d), this.object.geometry.hasNormalIndices = true
                        } else this.addFaceNormal(u, h, d);
                        if (void 0 !== i && "" !== i) {
                            var f = this.uvs.length;
                            u = this.parseUVIndex(i, f), h = this.parseUVIndex(r, f), d = this.parseUVIndex(a, f), this.addUV(u, h, d), this.object.geometry.hasUVIndices = true
                        } else this.addDefaultUV()
                    },
                    addPointGeometry: function (e) {
                        this.object.geometry.type = "Points";
                        for (var t = this.vertices.length, n = 0, i = e.length; n < i; n++) this.addVertexPoint(this.parseVertexIndex(e[n], t))
                    },
                    addLineGeometry: function (e, t) {
                        this.object.geometry.type = "Line";
                        for (var n = this.vertices.length, i = this.uvs.length, r = 0, a = e.length; r < a; r++) this.addVertexLine(this.parseVertexIndex(e[r], n));
                        var s = 0;
                        for (a = t.length; s < a; s++) this.addUVLine(this.parseUVIndex(t[s], i))
                    }
                };
                return e.startObject("", false), e
            }
            function u(e) {
                THREE.Loader.call(this, e), this.materials = null
            }
            return u.prototype = Object.assign(Object.create(THREE.Loader.prototype), {
                constructor: u,
                load: function (e, t, n, i) {
                    var r = this,
                        a = new THREE.FileLoader(r.manager);
                    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.load(e, (function (n) {
                        try {
                            t(r.parse(n))
                        } catch (t) {
                            i ? i(t) : console.error(t), r.manager.itemError(e)
                        }
                    }), n, i)
                },
                setMaterials: function (e) {
                    return this.materials = e, this
                },
                parse: function (r) {
                    var a = new c; - 1 !== r.indexOf("\r\n") && (r = r.replace(/\r\n/g, "\n")), -1 !== r.indexOf("\\\n") && (r = r.replace(/\\\n/g, ""));
                    for (var s = r.split("\n"), o = "", l = "", u = [], h = "function" == typeof "".trimLeft, d = 0, p = s.length; d < p; d++)
                        if (o = s[d], 0 !== (o = h ? o.trimLeft() : o.trim()).length && "#" !== (l = o.charAt(0)))
                            if ("v" === l) {
                                var f = o.split(/\s+/);
                                switch (f[0]) {
                                case "v":
                                    a.vertices.push(parseFloat(f[1]), parseFloat(f[2]), parseFloat(f[3])), f.length >= 7 ? a.colors.push(parseFloat(f[4]), parseFloat(f[5]), parseFloat(f[6])) : a.colors.push(void 0, void 0, void 0);
                                    break;
                                case "vn":
                                    a.normals.push(parseFloat(f[1]), parseFloat(f[2]), parseFloat(f[3]));
                                    break;
                                case "vt":
                                    a.uvs.push(parseFloat(f[1]), parseFloat(f[2]))
                                }
                            } else if ("f" === l) {
                        for (var m = o.substr(1).trim().split(/\s+/), g = [], v = 0, y = m.length; v < y; v++) {
                            var x = m[v];
                            if (x.length > 0) {
                                var b = x.split("/");
                                g.push(b)
                            }
                        }
                        var _ = g[0];
                        for (v = 1, y = g.length - 1; v < y; v++) {
                            var w = g[v],
                                E = g[v + 1];
                            a.addFace(_[0], w[0], E[0], _[1], w[1], E[1], _[2], w[2], E[2])
                        }
                    } else if ("l" === l) {
                        var M = o.substring(1).trim().split(" "),
                            T = [],
                            S = [];
                        if (-1 === o.indexOf("/")) T = M;
                        else
                            for (var A = 0, L = M.length; A < L; A++) {
                                var R = M[A].split("/");
                                "" !== R[0] && T.push(R[0]), "" !== R[1] && S.push(R[1])
                            }
                        a.addLineGeometry(T, S)
                    } else if ("p" === l) {
                        var P = o.substr(1).trim().split(" ");
                        a.addPointGeometry(P)
                    } else if (null !== (u = e.exec(o))) {
                        var C = (" " + u[0].substr(1).trim()).substr(1);
                        a.startObject(C)
                    } else if (n.test(o)) a.object.startMaterial(o.substring(7).trim(), a.materialLibraries);
                    else if (t.test(o)) a.materialLibraries.push(o.substring(7).trim());
                    else if (i.test(o)) console.log('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
                    else if ("s" === l) {
                        if ((u = o.split(" ")).length > 1) {
                            var I = u[1].trim().toLowerCase();
                            a.object.smooth = "0" !== I && "off" !== I
                        } else a.object.smooth = true;
                        (X = a.object.currentMaterial()) && (X.smooth = a.object.smooth)
                    } else {
                        if ("\0" === o) continue;
                        console.log('THREE.OBJLoader: Unexpected line: "' + o + '"')
                    }
                    a.finalize();
                    var F = new THREE.Group;
                    F.materialLibraries = [].concat(a.materialLibraries);
                    for (d = 0, p = a.objects.length; d < p; d++) {
                        var D = a.objects[d],
                            N = D.geometry,
                            O = D.materials,
                            H = "Line" === N.type,
                            U = "Points" === N.type,
                            B = false;
                        if (0 !== N.vertices.length) {
                            var z = new THREE.BufferGeometry;
                            z.setAttribute("position", new THREE.Float32BufferAttribute(N.vertices, 3)), !0 === N.hasNormalIndices && z.setAttribute("normal", new THREE.Float32BufferAttribute(N.normals, 3)), N.colors.length > 0 && (B = true, z.setAttribute("color", new THREE.Float32BufferAttribute(N.colors, 3))), !0 === N.hasUVIndices && z.setAttribute("uv", new THREE.Float32BufferAttribute(N.uvs, 2));
                            for (var k, G = [], V = 0, j = O.length; V < j; V++) {
                                var W = (Q = O[V]).name + "_" + Q.smooth + "_" + B,
                                    X = a.materials[W];
                                if (null !== this.materials)
                                    if (X = this.materials.create(Q.name), !H || !X || X instanceof THREE.LineBasicMaterial) {
                                        if (U && X && !(X instanceof THREE.PointsMaterial)) {
                                            var Y = new THREE.PointsMaterial({
                                                size: 10,
                                                sizeAttenuation: false
                                            });
                                            THREE.Material.prototype.copy.call(Y, X), Y.color.copy(X.color), Y.map = X.map, X = Y
                                        }
                                    } else {
                                        var q = new THREE.LineBasicMaterial;
                                        THREE.Material.prototype.copy.call(q, X), q.color.copy(X.color), X = q
                                    } void 0 === X && ((X = H ? new THREE.LineBasicMaterial : U ? new THREE.PointsMaterial({
                                    size: 1,
                                    sizeAttenuation: false
                                }) : new THREE.MeshPhongMaterial).name = Q.name, X.flatShading = !Q.smooth, X.vertexColors = B, a.materials[W] = X), G.push(X)
                            }
                            if (G.length > 1) {
                                for (V = 0, j = O.length; V < j; V++) {
                                    var Q = O[V];
                                    z.addGroup(Q.groupStart, Q.groupCount, V)
                                }
                                k = H ? new THREE.LineSegments(z, G) : U ? new THREE.Points(z, G) : new THREE.Mesh(z, G)
                            } else k = H ? new THREE.LineSegments(z, G[0]) : U ? new THREE.Points(z, G[0]) : new THREE.Mesh(z, G[0]);
                            k.name = D.name, F.add(k)
                        }
                    }
                    return F
                }
            }), u
        }()
    }, {}],
    115: [function (e, t, n) {
        ! function () {
            class e extends THREE.DataTextureLoader {
                constructor(e) {
                    super(e), this.type = THREE.HalfFloatType
                }
                parse(e) {
                    const t = function (e, t) {
                            switch (e) {
                            case 1:
                                console.error("THREE.RGBELoader Read Error: " + (t || ""));
                                break;
                            case 2:
                                console.error("THREE.RGBELoader Write Error: " + (t || ""));
                                break;
                            case 3:
                                console.error("THREE.RGBELoader Bad File Format: " + (t || ""));
                                break;
                            default:
                                console.error("THREE.RGBELoader: Error: " + (t || ""))
                            }
                            return -1
                        },
                        n = function (e, t, n) {
                            t = t || 1024;
                            let i = e.pos,
                                r = -1,
                                a = 0,
                                s = "",
                                o = String.fromCharCode.apply(null, new Uint16Array(e.subarray(i, i + 128)));
                            for (; 0 > (r = o.indexOf("\n")) && a < t && i < e.byteLength;) s += o, a += o.length, i += 128, o += String.fromCharCode.apply(null, new Uint16Array(e.subarray(i, i + 128)));
                            return -1 < r && (!1 !== n && (e.pos += a + r + 1), s + o.slice(0, r))
                        },
                        i = function (e, t, n, i) {
                            const r = e[t + 3],
                                a = Math.pow(2, r - 128) / 255;
                            n[i + 0] = e[t + 0] * a, n[i + 1] = e[t + 1] * a, n[i + 2] = e[t + 2] * a
                        },
                        r = function (e, t, n, i) {
                            const r = e[t + 3],
                                a = Math.pow(2, r - 128) / 255;
                            n[i + 0] = THREE.DataUtils.toHalfFloat(Math.min(e[t + 0] * a, 65504)), n[i + 1] = THREE.DataUtils.toHalfFloat(Math.min(e[t + 1] * a, 65504)), n[i + 2] = THREE.DataUtils.toHalfFloat(Math.min(e[t + 2] * a, 65504))
                        },
                        a = new Uint8Array(e);
                    a.pos = 0;
                    const s = function (e) {
                        const i = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
                            r = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
                            a = /^\s*FORMAT=(\S+)\s*$/,
                            s = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
                            o = {
                                valid: 0,
                                string: "",
                                comments: "",
                                programtype: "RGBE",
                                format: "",
                                gamma: 1,
                                exposure: 1,
                                width: 0,
                                height: 0
                            };
                        let l, c;
                        if (e.pos >= e.byteLength || !(l = n(e))) return t(1, "no header found");
                        if (!(c = l.match(/^#\?(\S+)/))) return t(3, "bad initial token");
                        for (o.valid |= 1, o.programtype = c[1], o.string += l + "\n"; l = n(e), !1 !== l;)
                            if (o.string += l + "\n", "#" !== l.charAt(0)) {
                                if ((c = l.match(i)) && (o.gamma = parseFloat(c[1], 10)), (c = l.match(r)) && (o.exposure = parseFloat(c[1], 10)), (c = l.match(a)) && (o.valid |= 2, o.format = c[1]), (c = l.match(s)) && (o.valid |= 4, o.height = parseInt(c[1], 10), o.width = parseInt(c[2], 10)), 2 & o.valid && 4 & o.valid) break
                            } else o.comments += l + "\n";
                        return 2 & o.valid ? 4 & o.valid ? o : t(3, "missing image size specifier") : t(3, "missing format specifier")
                    }(a);
                    if (-1 !== s) {
                        const e = s.width,
                            n = s.height,
                            o = function (e, n, i) {
                                const r = n;
                                if (r < 8 || r > 32767 || 2 !== e[0] || 2 !== e[1] || 128 & e[2]) return new Uint8Array(e);
                                if (r !== (e[2] << 8 | e[3])) return t(3, "wrong scanline width");
                                const a = new Uint8Array(4 * n * i);
                                if (!a.length) return t(4, "unable to allocate buffer space");
                                let s = 0,
                                    o = 0;
                                const l = 4 * r,
                                    c = new Uint8Array(4),
                                    u = new Uint8Array(l);
                                let h = i;
                                for (; h > 0 && o < e.byteLength;) {
                                    if (o + 4 > e.byteLength) return t(1);
                                    if (c[0] = e[o++], c[1] = e[o++], c[2] = e[o++], c[3] = e[o++], 2 != c[0] || 2 != c[1] || (c[2] << 8 | c[3]) != r) return t(3, "bad rgbe scanline format");
                                    let n, i = 0;
                                    for (; i < l && o < e.byteLength;) {
                                        n = e[o++];
                                        const r = n > 128;
                                        if (r && (n -= 128), 0 === n || i + n > l) return t(3, "bad scanline data");
                                        if (r) {
                                            const t = e[o++];
                                            for (let e = 0; e < n; e++) u[i++] = t
                                        } else u.set(e.subarray(o, o + n), i), i += n, o += n
                                    }
                                    const d = r;
                                    for (let e = 0; e < d; e++) {
                                        let t = 0;
                                        a[s] = u[e + t], t += r, a[s + 1] = u[e + t], t += r, a[s + 2] = u[e + t], t += r, a[s + 3] = u[e + t], s += 4
                                    }
                                    h--
                                }
                                return a
                            }(a.subarray(a.pos), e, n);
                        if (-1 !== o) {
                            let t, a, l, c;
                            switch (this.type) {
                            case THREE.UnsignedByteType:
                                t = o, a = THREE.RGBEFormat, l = THREE.UnsignedByteType;
                                break;
                            case THREE.FloatType:
                                c = o.length / 4;
                                const e = new Float32Array(3 * c);
                                for (let t = 0; t < c; t++) i(o, 4 * t, e, 3 * t);
                                t = e, a = THREE.RGBFormat, l = THREE.FloatType;
                                break;
                            case THREE.HalfFloatType:
                                c = o.length / 4;
                                const n = new Uint16Array(3 * c);
                                for (let e = 0; e < c; e++) r(o, 4 * e, n, 3 * e);
                                t = n, a = THREE.RGBFormat, l = THREE.HalfFloatType;
                                break;
                            default:
                                console.error("THREE.RGBELoader: unsupported type: ", this.type)
                            }
                            return {
                                width: e,
                                height: n,
                                data: t,
                                header: s.string,
                                gamma: s.gamma,
                                exposure: s.exposure,
                                format: a,
                                type: l
                            }
                        }
                    }
                    return null
                }
                setDataType(e) {
                    return this.type = e, this
                }
                load(e, t, n, i) {
                    return super.load(e, (function (e, n) {
                        switch (e.type) {
                        case THREE.UnsignedByteType:
                            e.encoding = THREE.RGBEEncoding, e.minFilter = THREE.NearestFilter, e.magFilter = THREE.NearestFilter, e.generateMipmaps = false, e.flipY = true;
                            break;
                        case THREE.FloatType:
                        case THREE.HalfFloatType:
                            e.encoding = THREE.LinearEncoding, e.minFilter = THREE.LinearFilter, e.magFilter = THREE.LinearFilter, e.generateMipmaps = false, e.flipY = true
                        }
                        t && t(e, n)
                    }), n, i)
                }
            }
            THREE.RGBELoader = e
        }()
    }, {}],
    116: [function (e, t, n) {
        var i, r, a;
        THREE.EffectComposer = function (e, t, n) {
            this.renderer = e;
            var i = {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat
            };
            t && (i.type = THREE.HalfFloatType);
            var r = e.getSize(new THREE.Vector2);
            this._pixelRatio = e.getPixelRatio(), this._width = r.width, this._height = r.height;
            const a = new THREE[n ? "WebGLMultisampleRenderTarget" : "WebGLRenderTarget"](this._width * this._pixelRatio, this._height * this._pixelRatio, i);
            if (n) {
                const t = e.getContext();
                a.samples = Math.min(4, t.getParameter(t.MAX_SAMPLES))
            }
            a.texture.name = "EffectComposer.rt1", this.renderTarget1 = a, this.renderTarget2 = a.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = true, this.passes = [], this.clock = new THREE.Clock
        }, Object.assign(THREE.EffectComposer.prototype, {
            addPass: function (e) {
                this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
            },
            isLastEnabledPass: function (e) {
                for (var t = e + 1; t < this.passes.length; t++)
                    if (this.passes[t].enabled) return false;
                return true
            },
            render: function (e) {
                void 0 === e && (e = this.clock.getDelta());
                var t, n, i = this.renderer.getRenderTarget(),
                    r = this.passes.length;
                for (n = 0; n < r; n++) !1 !== (t = this.passes[n]).enabled && (t.renderToScreen = this.renderToScreen && this.isLastEnabledPass(n), t.render(this.renderer, this.writeBuffer, this.readBuffer, e, false));
                this.renderer.setRenderTarget(i)
            },
            setSize: function (e, t) {
                this._width = e, this._height = t;
                var n = this._width * this._pixelRatio,
                    i = this._height * this._pixelRatio;
                this.renderTarget1.setSize(n, i), this.renderTarget2.setSize(n, i);
                for (var r = 0; r < this.passes.length; r++) this.passes[r].setSize(n, i)
            }
        }), THREE.Pass = function () {
            this.enabled = true, this.clear = false, this.renderToScreen = false
        }, Object.assign(THREE.Pass.prototype, {
            setSize: function () {},
            render: function () {
                console.error("THREE.Pass: .render() must be implemented in derived pass.")
            }
        }), THREE.Pass.FullScreenQuad = (i = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1), r = new THREE.PlaneBufferGeometry(2, 2), a = function (e) {
            this._mesh = new THREE.Mesh(r, e)
        }, Object.defineProperty(a.prototype, "material", {
            get: function () {
                return this._mesh.material
            },
            set: function (e) {
                this._mesh.material = e
            }
        }), Object.assign(a.prototype, {
            dispose: function () {
                this._mesh.geometry.dispose()
            },
            render: function (e) {
                e.render(this._mesh, i)
            }
        }), a)
    }, {}],
    117: [function (e, t, n) {
        THREE.RenderPass = function (e, t, n, i, r) {
            THREE.Pass.call(this), this.scene = e, this.camera = t, this.overrideMaterial = n, this.clearColor = i, this.clearAlpha = void 0 !== r ? r : 0, this.clear = true, this.clearDepth = false
        }, THREE.RenderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
            constructor: THREE.RenderPass,
            render: function (e, t, n) {
                var i, r, a, s = e.autoClear;
                e.autoClear = false, void 0 !== this.overrideMaterial && (a = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor && (i = e.getClearColor().getHex(), r = e.getClearAlpha(), e.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : n), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), this.clearColor && e.setClearColor(i, r), void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = a), e.autoClear = s
            }
        })
    }, {}],
    118: [function (e, t, n) {
        THREE.ShaderPass = function (e, t) {
            THREE.Pass.call(this), this.textureID = void 0 !== t ? t : "tDiffuse", e instanceof THREE.ShaderMaterial ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = THREE.UniformsUtils.clone(e.uniforms), this.material = new THREE.ShaderMaterial({
                defines: Object.assign({}, e.defines),
                uniforms: this.uniforms,
                vertexShader: e.vertexShader,
                fragmentShader: e.fragmentShader
            })), this.fsQuad = new THREE.Pass.FullScreenQuad(this.material)
        }, THREE.ShaderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
            constructor: THREE.ShaderPass,
            render: function (e, t, n) {
                this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(t), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e))
            }
        })
    }, {}],
    119: [function (e, t, n) {
        THREE.FXAAShader = {
            uniforms: {
                tDiffuse: {
                    value: null
                },
                resolution: {
                    value: new THREE.Vector2(1 / 1024, 1 / 512)
                }
            },
            vertexShader: ["varying vec2 vUv;", "void main() {", "\tvUv = uv;", "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
            fragmentShader: ["precision highp float;", "", "uniform sampler2D tDiffuse;", "", "uniform vec2 resolution;", "", "varying vec2 vUv;", "", "// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)", "", "//----------------------------------------------------------------------------------", "// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag", "// SDK Version: v3.00", "// Email:       gameworks@nvidia.com", "// Site:        http://developer.nvidia.com/", "//", "// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.", "//", "// Redistribution and use in source and binary forms, with or without", "// modification, are permitted provided that the following conditions", "// are met:", "//  * Redistributions of source code must retain the above copyright", "//    notice, this list of conditions and the following disclaimer.", "//  * Redistributions in binary form must reproduce the above copyright", "//    notice, this list of conditions and the following disclaimer in the", "//    documentation and/or other materials provided with the distribution.", "//  * Neither the name of NVIDIA CORPORATION nor the names of its", "//    contributors may be used to endorse or promote products derived", "//    from this software without specific prior written permission.", "//", "// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY", "// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", "// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR", "// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR", "// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,", "// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,", "// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR", "// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY", "// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT", "// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE", "// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.", "//", "//----------------------------------------------------------------------------------", "", "#define FXAA_QUALITY_PRESET 15", "#define FXAA_GREEN_AS_LUMA 1", "", "#ifndef FXAA_GREEN_AS_LUMA", "    //", "    // For those using non-linear color,", "    // and either not able to get luma in alpha, or not wanting to,", "    // this enables FXAA to run using green as a proxy for luma.", "    // So with this enabled, no need to pack luma in alpha.", "    //", "    // This will turn off AA on anything which lacks some amount of green.", "    // Pure red and blue or combination of only R and B, will get no AA.", "    //", "    // Might want to lower the settings for both,", "    //    fxaaConsoleEdgeThresholdMin", "    //    fxaaQualityEdgeThresholdMin", "    // In order to insure AA does not get turned off on colors", "    // which contain a minor amount of green.", "    //", "    // 1 = On.", "    // 0 = Off.", "    //", "    #define FXAA_GREEN_AS_LUMA 0", "#endif", "", "#ifndef FXAA_DISCARD", "    //", "    // Only valid for PC OpenGL currently.", "    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.", "    //", "    // 1 = Use discard on pixels which don't need AA.", "    //     For APIs which enable concurrent TEX+ROP from same surface.", "    // 0 = Return unchanged color on pixels which don't need AA.", "    //", "    #define FXAA_DISCARD 0", "#endif", "", "#ifndef FXAA_GATHER4_ALPHA", "    //", "    // 1 = API supports gather4 on alpha channel.", "    // 0 = API does not support gather4 on alpha channel.", "    //", "    #ifdef GL_ARB_gpu_shader5", "        #define FXAA_GATHER4_ALPHA 1", "    #endif", "    #ifdef GL_NV_gpu_shader5", "        #define FXAA_GATHER4_ALPHA 1", "    #endif", "    #ifndef FXAA_GATHER4_ALPHA", "        #define FXAA_GATHER4_ALPHA 0", "    #endif", "#endif", "", "", "", "#ifndef FXAA_QUALITY_PRESET", "    //", "    // Choose the quality preset.", "    // This needs to be compiled into the shader as it effects code.", "    // Best option to include multiple presets is to", "    // in each shader define the preset, then include this file.", "    //", "    // OPTIONS", "    // -----------------------------------------------------------------------", "    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)", "    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)", "    // 39       - no dither, very expensive", "    //", "    // NOTES", "    // -----------------------------------------------------------------------", "    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)", "    // 13 = about same speed as FXAA 3.9 and better than 12", "    // 23 = closest to FXAA 3.9 visually and performance wise", "    //  _ = the lowest digit is directly related to performance", "    // _  = the highest digit is directly related to style", "    //", "    #define FXAA_QUALITY_PRESET 12", "#endif", "", "", "", "", "", "#if (FXAA_QUALITY_PRESET == 10)", "    #define FXAA_QUALITY_PS 3", "    #define FXAA_QUALITY_P0 1.5", "    #define FXAA_QUALITY_P1 3.0", "    #define FXAA_QUALITY_P2 12.0", "#endif", "", "#if (FXAA_QUALITY_PRESET == 11)", "    #define FXAA_QUALITY_PS 4", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 3.0", "    #define FXAA_QUALITY_P3 12.0", "#endif", "", "#if (FXAA_QUALITY_PRESET == 12)", "    #define FXAA_QUALITY_PS 5", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 4.0", "    #define FXAA_QUALITY_P4 12.0", "#endif", "", "#if (FXAA_QUALITY_PRESET == 13)", "    #define FXAA_QUALITY_PS 6", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 4.0", "    #define FXAA_QUALITY_P5 12.0", "#endif", "", "#if (FXAA_QUALITY_PRESET == 14)", "    #define FXAA_QUALITY_PS 7", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 4.0", "    #define FXAA_QUALITY_P6 12.0", "#endif", "", "#if (FXAA_QUALITY_PRESET == 15)", "    #define FXAA_QUALITY_PS 8", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 4.0", "    #define FXAA_QUALITY_P7 12.0", "#endif", "", "", "#if (FXAA_QUALITY_PRESET == 20)", "    #define FXAA_QUALITY_PS 3", "    #define FXAA_QUALITY_P0 1.5", "    #define FXAA_QUALITY_P1 2.0", "    #define FXAA_QUALITY_P2 8.0", "#endif", "", "#if (FXAA_QUALITY_PRESET == 21)", "    #define FXAA_QUALITY_PS 4", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 8.0", "#endif", "", "#if (FXAA_QUALITY_PRESET == 22)", "    #define FXAA_QUALITY_PS 5", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 8.0", "#endif", "", "#if (FXAA_QUALITY_PRESET == 23)", "    #define FXAA_QUALITY_PS 6", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 8.0", "#endif", "", "#if (FXAA_QUALITY_PRESET == 24)", "    #define FXAA_QUALITY_PS 7", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 3.0", "    #define FXAA_QUALITY_P6 8.0", "#endif", "", "#if (FXAA_QUALITY_PRESET == 25)", "    #define FXAA_QUALITY_PS 8", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 4.0", "    #define FXAA_QUALITY_P7 8.0", "#endif", "", "#if (FXAA_QUALITY_PRESET == 26)", "    #define FXAA_QUALITY_PS 9", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 4.0", "    #define FXAA_QUALITY_P8 8.0", "#endif", "", "#if (FXAA_QUALITY_PRESET == 27)", "    #define FXAA_QUALITY_PS 10", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 4.0", "    #define FXAA_QUALITY_P9 8.0", "#endif", "", "#if (FXAA_QUALITY_PRESET == 28)", "    #define FXAA_QUALITY_PS 11", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 2.0", "    #define FXAA_QUALITY_P9 4.0", "    #define FXAA_QUALITY_P10 8.0", "#endif", "", "#if (FXAA_QUALITY_PRESET == 29)", "    #define FXAA_QUALITY_PS 12", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 2.0", "    #define FXAA_QUALITY_P9 2.0", "    #define FXAA_QUALITY_P10 4.0", "    #define FXAA_QUALITY_P11 8.0", "#endif", "", "", "#if (FXAA_QUALITY_PRESET == 39)", "    #define FXAA_QUALITY_PS 12", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.0", "    #define FXAA_QUALITY_P2 1.0", "    #define FXAA_QUALITY_P3 1.0", "    #define FXAA_QUALITY_P4 1.0", "    #define FXAA_QUALITY_P5 1.5", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 2.0", "    #define FXAA_QUALITY_P9 2.0", "    #define FXAA_QUALITY_P10 4.0", "    #define FXAA_QUALITY_P11 8.0", "#endif", "", "", "", "", "    #define FxaaBool bool", "    #define FxaaDiscard discard", "    #define FxaaFloat float", "    #define FxaaFloat2 vec2", "    #define FxaaFloat3 vec3", "    #define FxaaFloat4 vec4", "    #define FxaaHalf float", "    #define FxaaHalf2 vec2", "    #define FxaaHalf3 vec3", "    #define FxaaHalf4 vec4", "    #define FxaaInt2 ivec2", "    #define FxaaSat(x) clamp(x, 0.0, 1.0)", "    #define FxaaTex sampler2D", "    #define FxaaTexTop(t, p) texture2D(t, p, 0.0)", "    #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)", "", "", "#if (FXAA_GREEN_AS_LUMA == 0)", "    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }", "#else", "    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }", "#endif", "", "", "", "", "", "FxaaFloat4 FxaaPixelShader(", "    //", "    // Use noperspective interpolation here (turn off perspective interpolation).", "    // {xy} = center of pixel", "    FxaaFloat2 posM,", "    //", "    // Input color texture.", "    // {rgb_} = color in linear or perceptual color space", "    // if (FXAA_GREEN_AS_LUMA == 0)", "    //     {__a} = luma in perceptual color space (not linear)", "    FxaaTex tex,", "    //", "    // Only used on FXAA Quality.", "    // This must be from a constant/uniform.", "    // {x_} = 1.0/screenWidthInPixels", "    // {_y} = 1.0/screenHeightInPixels", "    FxaaFloat2 fxaaQualityRcpFrame,", "    //", "    // Only used on FXAA Quality.", "    // This used to be the FXAA_QUALITY_SUBPIX define.", "    // It is here now to allow easier tuning.", "    // Choose the amount of sub-pixel aliasing removal.", "    // This can effect sharpness.", "    //   1.00 - upper limit (softer)", "    //   0.75 - default amount of filtering", "    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)", "    //   0.25 - almost off", "    //   0.00 - completely off", "    FxaaFloat fxaaQualitySubpix,", "    //", "    // Only used on FXAA Quality.", "    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.", "    // It is here now to allow easier tuning.", "    // The minimum amount of local contrast required to apply algorithm.", "    //   0.333 - too little (faster)", "    //   0.250 - low quality", "    //   0.166 - default", "    //   0.125 - high quality", "    //   0.063 - overkill (slower)", "    FxaaFloat fxaaQualityEdgeThreshold,", "    //", "    // Only used on FXAA Quality.", "    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.", "    // It is here now to allow easier tuning.", "    // Trims the algorithm from processing darks.", "    //   0.0833 - upper limit (default, the start of visible unfiltered edges)", "    //   0.0625 - high quality (faster)", "    //   0.0312 - visible limit (slower)", "    // Special notes when using FXAA_GREEN_AS_LUMA,", "    //   Likely want to set this to zero.", "    //   As colors that are mostly not-green", "    //   will appear very dark in the green channel!", "    //   Tune by looking at mostly non-green content,", "    //   then start at zero and increase until aliasing is a problem.", "    FxaaFloat fxaaQualityEdgeThresholdMin", ") {", "", "    #if (FXAA_GATHER4_ALPHA == 1)", "        #if (FXAA_DISCARD == 0)", "            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);", "            #if (FXAA_GREEN_AS_LUMA == 0)", "                #define lumaM rgbyM.w", "            #else", "                #define lumaM rgbyM.y", "            #endif", "        #endif", "        #if (FXAA_GREEN_AS_LUMA == 0)", "            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);", "            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));", "        #else", "            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);", "            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));", "        #endif", "        #if (FXAA_DISCARD == 1)", "            #define lumaM luma4A.w", "        #endif", "        #define lumaE luma4A.z", "        #define lumaS luma4A.x", "        #define lumaSE luma4A.y", "        #define lumaNW luma4B.w", "        #define lumaN luma4B.z", "        #define lumaW luma4B.x", "    #else", "        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);", "        #if (FXAA_GREEN_AS_LUMA == 0)", "            #define lumaM rgbyM.w", "        #else", "            #define lumaM rgbyM.y", "        #endif", "          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));", "    #endif", "", "    FxaaFloat maxSM = max(lumaS, lumaM);", "    FxaaFloat minSM = min(lumaS, lumaM);", "    FxaaFloat maxESM = max(lumaE, maxSM);", "    FxaaFloat minESM = min(lumaE, minSM);", "    FxaaFloat maxWN = max(lumaN, lumaW);", "    FxaaFloat minWN = min(lumaN, lumaW);", "    FxaaFloat rangeMax = max(maxWN, maxESM);", "    FxaaFloat rangeMin = min(minWN, minESM);", "    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;", "    FxaaFloat range = rangeMax - rangeMin;", "    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);", "    FxaaBool earlyExit = range < rangeMaxClamped;", "", "    if(earlyExit)", "        #if (FXAA_DISCARD == 1)", "            FxaaDiscard;", "        #else", "            return rgbyM;", "        #endif", "", "    #if (FXAA_GATHER4_ALPHA == 0)", "          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));", "    #else", "        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));", "        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));", "    #endif", "", "    FxaaFloat lumaNS = lumaN + lumaS;", "    FxaaFloat lumaWE = lumaW + lumaE;", "    FxaaFloat subpixRcpRange = 1.0/range;", "    FxaaFloat subpixNSWE = lumaNS + lumaWE;", "    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;", "    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;", "", "    FxaaFloat lumaNESE = lumaNE + lumaSE;", "    FxaaFloat lumaNWNE = lumaNW + lumaNE;", "    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;", "    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;", "", "    FxaaFloat lumaNWSW = lumaNW + lumaSW;", "    FxaaFloat lumaSWSE = lumaSW + lumaSE;", "    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);", "    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);", "    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;", "    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;", "    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;", "    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;", "", "    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;", "    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;", "    FxaaBool horzSpan = edgeHorz >= edgeVert;", "    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;", "", "    if(!horzSpan) lumaN = lumaW;", "    if(!horzSpan) lumaS = lumaE;", "    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;", "    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;", "", "    FxaaFloat gradientN = lumaN - lumaM;", "    FxaaFloat gradientS = lumaS - lumaM;", "    FxaaFloat lumaNN = lumaN + lumaM;", "    FxaaFloat lumaSS = lumaS + lumaM;", "    FxaaBool pairN = abs(gradientN) >= abs(gradientS);", "    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));", "    if(pairN) lengthSign = -lengthSign;", "    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);", "", "    FxaaFloat2 posB;", "    posB.x = posM.x;", "    posB.y = posM.y;", "    FxaaFloat2 offNP;", "    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;", "    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;", "    if(!horzSpan) posB.x += lengthSign * 0.5;", "    if( horzSpan) posB.y += lengthSign * 0.5;", "", "    FxaaFloat2 posN;", "    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;", "    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;", "    FxaaFloat2 posP;", "    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;", "    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;", "    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;", "    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));", "    FxaaFloat subpixE = subpixC * subpixC;", "    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));", "", "    if(!pairN) lumaNN = lumaSS;", "    FxaaFloat gradientScaled = gradient * 1.0/4.0;", "    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;", "    FxaaFloat subpixF = subpixD * subpixE;", "    FxaaBool lumaMLTZero = lumaMM < 0.0;", "", "    lumaEndN -= lumaNN * 0.5;", "    lumaEndP -= lumaNN * 0.5;", "    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;", "    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;", "    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;", "    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;", "    FxaaBool doneNP = (!doneN) || (!doneP);", "    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;", "    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;", "", "    if(doneNP) {", "        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "        doneN = abs(lumaEndN) >= gradientScaled;", "        doneP = abs(lumaEndP) >= gradientScaled;", "        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;", "        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;", "        doneNP = (!doneN) || (!doneP);", "        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;", "        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;", "", "        #if (FXAA_QUALITY_PS > 3)", "        if(doneNP) {", "            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "            doneN = abs(lumaEndN) >= gradientScaled;", "            doneP = abs(lumaEndP) >= gradientScaled;", "            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;", "            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;", "            doneNP = (!doneN) || (!doneP);", "            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;", "            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;", "", "            #if (FXAA_QUALITY_PS > 4)", "            if(doneNP) {", "                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                doneN = abs(lumaEndN) >= gradientScaled;", "                doneP = abs(lumaEndP) >= gradientScaled;", "                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;", "                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;", "                doneNP = (!doneN) || (!doneP);", "                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;", "                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;", "", "                #if (FXAA_QUALITY_PS > 5)", "                if(doneNP) {", "                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                    doneN = abs(lumaEndN) >= gradientScaled;", "                    doneP = abs(lumaEndP) >= gradientScaled;", "                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;", "                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;", "                    doneNP = (!doneN) || (!doneP);", "                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;", "                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;", "", "                    #if (FXAA_QUALITY_PS > 6)", "                    if(doneNP) {", "                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                        doneN = abs(lumaEndN) >= gradientScaled;", "                        doneP = abs(lumaEndP) >= gradientScaled;", "                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;", "                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;", "                        doneNP = (!doneN) || (!doneP);", "                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;", "                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;", "", "                        #if (FXAA_QUALITY_PS > 7)", "                        if(doneNP) {", "                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                            doneN = abs(lumaEndN) >= gradientScaled;", "                            doneP = abs(lumaEndP) >= gradientScaled;", "                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;", "                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;", "                            doneNP = (!doneN) || (!doneP);", "                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;", "                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;", "", "    #if (FXAA_QUALITY_PS > 8)", "    if(doneNP) {", "        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "        doneN = abs(lumaEndN) >= gradientScaled;", "        doneP = abs(lumaEndP) >= gradientScaled;", "        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;", "        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;", "        doneNP = (!doneN) || (!doneP);", "        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;", "        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;", "", "        #if (FXAA_QUALITY_PS > 9)", "        if(doneNP) {", "            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "            doneN = abs(lumaEndN) >= gradientScaled;", "            doneP = abs(lumaEndP) >= gradientScaled;", "            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;", "            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;", "            doneNP = (!doneN) || (!doneP);", "            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;", "            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;", "", "            #if (FXAA_QUALITY_PS > 10)", "            if(doneNP) {", "                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                doneN = abs(lumaEndN) >= gradientScaled;", "                doneP = abs(lumaEndP) >= gradientScaled;", "                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;", "                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;", "                doneNP = (!doneN) || (!doneP);", "                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;", "                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;", "", "                #if (FXAA_QUALITY_PS > 11)", "                if(doneNP) {", "                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                    doneN = abs(lumaEndN) >= gradientScaled;", "                    doneP = abs(lumaEndP) >= gradientScaled;", "                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;", "                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;", "                    doneNP = (!doneN) || (!doneP);", "                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;", "                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;", "", "                    #if (FXAA_QUALITY_PS > 12)", "                    if(doneNP) {", "                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                        doneN = abs(lumaEndN) >= gradientScaled;", "                        doneP = abs(lumaEndP) >= gradientScaled;", "                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;", "                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;", "                        doneNP = (!doneN) || (!doneP);", "                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;", "                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;", "", "                    }", "                    #endif", "", "                }", "                #endif", "", "            }", "            #endif", "", "        }", "        #endif", "", "    }", "    #endif", "", "                        }", "                        #endif", "", "                    }", "                    #endif", "", "                }", "                #endif", "", "            }", "            #endif", "", "        }", "        #endif", "", "    }", "", "    FxaaFloat dstN = posM.x - posN.x;", "    FxaaFloat dstP = posP.x - posM.x;", "    if(!horzSpan) dstN = posM.y - posN.y;", "    if(!horzSpan) dstP = posP.y - posM.y;", "", "    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;", "    FxaaFloat spanLength = (dstP + dstN);", "    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;", "    FxaaFloat spanLengthRcp = 1.0/spanLength;", "", "    FxaaBool directionN = dstN < dstP;", "    FxaaFloat dst = min(dstN, dstP);", "    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;", "    FxaaFloat subpixG = subpixF * subpixF;", "    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;", "    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;", "", "    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;", "    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);", "    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;", "    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;", "    #if (FXAA_DISCARD == 1)", "        return FxaaTexTop(tex, posM);", "    #else", "        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);", "    #endif", "}", "", "void main() {", "  gl_FragColor = FxaaPixelShader(", "    vUv,", "    tDiffuse,", "    resolution,", "    1.00,", "    .063,", "    0.0625", "  );", "  gl_FragColor = LinearTosRGB(gl_FragColor);", "}"].join("\n")
        }
    }, {}],
    120: [function (e, t, n) {
        var i, r;
        i = this, r = function (e) {
            "use strict";
            const t = "135",
                n = 100,
                i = 300,
                r = 301,
                a = 302,
                s = 303,
                o = 304,
                l = 306,
                c = 307,
                u = 1e3,
                h = 1001,
                d = 1002,
                p = 1003,
                f = 1004,
                m = 1005,
                g = 1006,
                v = 1007,
                y = 1008,
                x = 1009,
                b = 1012,
                _ = 1014,
                w = 1015,
                E = 1016,
                M = 1020,
                T = 1022,
                S = 1023,
                A = 1026,
                L = 1027,
                R = 33776,
                P = 33777,
                C = 33778,
                I = 33779,
                F = 35840,
                D = 35841,
                N = 35842,
                O = 35843,
                H = 37492,
                U = 37496,
                B = 2300,
                z = 2301,
                k = 2302,
                G = 2400,
                V = 2401,
                j = 2402,
                W = 2501,
                X = 3e3,
                Y = 3001,
                q = 3007,
                Q = 3002,
                J = 3004,
                Z = 3005,
                K = 3006,
                $ = 7680,
                ee = 35044,
                te = 35048,
                ne = "300 es";
            class ie {
                addEventListener(e, t) {
                    void 0 === this._listeners && (this._listeners = {});
                    const n = this._listeners;
                    void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
                }
                hasEventListener(e, t) {
                    if (void 0 === this._listeners) return false;
                    const n = this._listeners;
                    return void 0 !== n[e] && -1 !== n[e].indexOf(t)
                }
                removeEventListener(e, t) {
                    if (void 0 === this._listeners) return;
                    const n = this._listeners[e];
                    if (void 0 !== n) {
                        const e = n.indexOf(t); - 1 !== e && n.splice(e, 1)
                    }
                }
                dispatchEvent(e) {
                    if (void 0 === this._listeners) return;
                    const t = this._listeners[e.type];
                    if (void 0 !== t) {
                        e.target = this;
                        const n = t.slice(0);
                        for (let t = 0, i = n.length; t < i; t++) n[t].call(this, e);
                        e.target = null
                    }
                }
            }
            const re = [];
            for (let e = 0; e < 256; e++) re[e] = (e < 16 ? "0" : "") + e.toString(16);
            let ae = 1234567;
            const se = Math.PI / 180,
                oe = 180 / Math.PI;
            function le() {
                const e = 4294967295 * Math.random() | 0,
                    t = 4294967295 * Math.random() | 0,
                    n = 4294967295 * Math.random() | 0,
                    i = 4294967295 * Math.random() | 0;
                return (re[255 & e] + re[e >> 8 & 255] + re[e >> 16 & 255] + re[e >> 24 & 255] + "-" + re[255 & t] + re[t >> 8 & 255] + "-" + re[t >> 16 & 15 | 64] + re[t >> 24 & 255] + "-" + re[63 & n | 128] + re[n >> 8 & 255] + "-" + re[n >> 16 & 255] + re[n >> 24 & 255] + re[255 & i] + re[i >> 8 & 255] + re[i >> 16 & 255] + re[i >> 24 & 255]).toUpperCase()
            }
            function ce(e, t, n) {
                return Math.max(t, Math.min(n, e))
            }
            function ue(e, t) {
                return (e % t + t) % t
            }
            function he(e, t, n) {
                return (1 - n) * e + n * t
            }
            function de(e) {
                return 0 == (e & e - 1) && 0 !== e
            }
            function pe(e) {
                return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
            }
            function fe(e) {
                return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
            }
            var me = Object.freeze({
                __proto__: null,
                DEG2RAD: se,
                RAD2DEG: oe,
                generateUUID: le,
                clamp: ce,
                euclideanModulo: ue,
                mapLinear: function (e, t, n, i, r) {
                    return i + (e - t) * (r - i) / (n - t)
                },
                inverseLerp: function (e, t, n) {
                    return e !== t ? (n - e) / (t - e) : 0
                },
                lerp: he,
                damp: function (e, t, n, i) {
                    return he(e, t, 1 - Math.exp(-n * i))
                },
                pingpong: function (e, t = 1) {
                    return t - Math.abs(ue(e, 2 * t) - t)
                },
                smoothstep: function (e, t, n) {
                    return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
                },
                smootherstep: function (e, t, n) {
                    return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
                },
                randInt: function (e, t) {
                    return e + Math.floor(Math.random() * (t - e + 1))
                },
                randFloat: function (e, t) {
                    return e + Math.random() * (t - e)
                },
                randFloatSpread: function (e) {
                    return e * (.5 - Math.random())
                },
                seededRandom: function (e) {
                    return void 0 !== e && (ae = e % 2147483647), ae = 16807 * ae % 2147483647, (ae - 1) / 2147483646
                },
                degToRad: function (e) {
                    return e * se
                },
                radToDeg: function (e) {
                    return e * oe
                },
                isPowerOfTwo: de,
                ceilPowerOfTwo: pe,
                floorPowerOfTwo: fe,
                setQuaternionFromProperEuler: function (e, t, n, i, r) {
                    const a = Math.cos,
                        s = Math.sin,
                        o = a(n / 2),
                        l = s(n / 2),
                        c = a((t + i) / 2),
                        u = s((t + i) / 2),
                        h = a((t - i) / 2),
                        d = s((t - i) / 2),
                        p = a((i - t) / 2),
                        f = s((i - t) / 2);
                    switch (r) {
                    case "XYX":
                        e.set(o * u, l * h, l * d, o * c);
                        break;
                    case "YZY":
                        e.set(l * d, o * u, l * h, o * c);
                        break;
                    case "ZXZ":
                        e.set(l * h, l * d, o * u, o * c);
                        break;
                    case "XZX":
                        e.set(o * u, l * f, l * p, o * c);
                        break;
                    case "YXY":
                        e.set(l * p, o * u, l * f, o * c);
                        break;
                    case "ZYZ":
                        e.set(l * f, l * p, o * u, o * c);
                        break;
                    default:
                        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
                    }
                }
            });
            class ge {
                constructor(e = 0, t = 0) {
                    this.x = e, this.y = t
                }
                get width() {
                    return this.x
                }
                set width(e) {
                    this.x = e
                }
                get height() {
                    return this.y
                }
                set height(e) {
                    this.y = e
                }
                set(e, t) {
                    return this.x = e, this.y = t, this
                }
                setScalar(e) {
                    return this.x = e, this.y = e, this
                }
                setX(e) {
                    return this.x = e, this
                }
                setY(e) {
                    return this.y = e, this
                }
                setComponent(e, t) {
                    switch (e) {
                    case 0:
                        this.x = t;
                        break;
                    case 1:
                        this.y = t;
                        break;
                    default:
                        throw new Error("index is out of range: " + e)
                    }
                    return this
                }
                getComponent(e) {
                    switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw new Error("index is out of range: " + e)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y)
                }
                copy(e) {
                    return this.x = e.x, this.y = e.y, this
                }
                add(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
                }
                addScalar(e) {
                    return this.x += e, this.y += e, this
                }
                addVectors(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this
                }
                addScaledVector(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this
                }
                sub(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
                }
                subScalar(e) {
                    return this.x -= e, this.y -= e, this
                }
                subVectors(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this
                }
                multiply(e) {
                    return this.x *= e.x, this.y *= e.y, this
                }
                multiplyScalar(e) {
                    return this.x *= e, this.y *= e, this
                }
                divide(e) {
                    return this.x /= e.x, this.y /= e.y, this
                }
                divideScalar(e) {
                    return this.multiplyScalar(1 / e)
                }
                applyMatrix3(e) {
                    const t = this.x,
                        n = this.y,
                        i = e.elements;
                    return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this
                }
                min(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
                }
                max(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
                }
                clamp(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
                }
                clampScalar(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
                }
                clampLength(e, t) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this
                }
                dot(e) {
                    return this.x * e.x + this.y * e.y
                }
                cross(e) {
                    return this.x * e.y - this.y * e.x
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                angle() {
                    return Math.atan2(-this.y, -this.x) + Math.PI
                }
                distanceTo(e) {
                    return Math.sqrt(this.distanceToSquared(e))
                }
                distanceToSquared(e) {
                    const t = this.x - e.x,
                        n = this.y - e.y;
                    return t * t + n * n
                }
                manhattanDistanceTo(e) {
                    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
                }
                setLength(e) {
                    return this.normalize().multiplyScalar(e)
                }
                lerp(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
                }
                lerpVectors(e, t, n) {
                    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this
                }
                equals(e) {
                    return e.x === this.x && e.y === this.y
                }
                fromArray(e, t = 0) {
                    return this.x = e[t], this.y = e[t + 1], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.x, e[t + 1] = this.y, e
                }
                fromBufferAttribute(e, t, n) {
                    return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this
                }
                rotateAround(e, t) {
                    const n = Math.cos(t),
                        i = Math.sin(t),
                        r = this.x - e.x,
                        a = this.y - e.y;
                    return this.x = r * n - a * i + e.x, this.y = r * i + a * n + e.y, this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this
                }*[Symbol.iterator]() {
                    yield this.x, yield this.y
                }
            }
            ge.prototype.isVector2 = true;
            class ve {
                constructor() {
                    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
                }
                set(e, t, n, i, r, a, s, o, l) {
                    const c = this.elements;
                    return c[0] = e, c[1] = i, c[2] = s, c[3] = t, c[4] = r, c[5] = o, c[6] = n, c[7] = a, c[8] = l, this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                }
                copy(e) {
                    const t = this.elements,
                        n = e.elements;
                    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
                }
                extractBasis(e, t, n) {
                    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
                }
                setFromMatrix4(e) {
                    const t = e.elements;
                    return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
                }
                multiply(e) {
                    return this.multiplyMatrices(this, e)
                }
                premultiply(e) {
                    return this.multiplyMatrices(e, this)
                }
                multiplyMatrices(e, t) {
                    const n = e.elements,
                        i = t.elements,
                        r = this.elements,
                        a = n[0],
                        s = n[3],
                        o = n[6],
                        l = n[1],
                        c = n[4],
                        u = n[7],
                        h = n[2],
                        d = n[5],
                        p = n[8],
                        f = i[0],
                        m = i[3],
                        g = i[6],
                        v = i[1],
                        y = i[4],
                        x = i[7],
                        b = i[2],
                        _ = i[5],
                        w = i[8];
                    return r[0] = a * f + s * v + o * b, r[3] = a * m + s * y + o * _, r[6] = a * g + s * x + o * w, r[1] = l * f + c * v + u * b, r[4] = l * m + c * y + u * _, r[7] = l * g + c * x + u * w, r[2] = h * f + d * v + p * b, r[5] = h * m + d * y + p * _, r[8] = h * g + d * x + p * w, this
                }
                multiplyScalar(e) {
                    const t = this.elements;
                    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
                }
                determinant() {
                    const e = this.elements,
                        t = e[0],
                        n = e[1],
                        i = e[2],
                        r = e[3],
                        a = e[4],
                        s = e[5],
                        o = e[6],
                        l = e[7],
                        c = e[8];
                    return t * a * c - t * s * l - n * r * c + n * s * o + i * r * l - i * a * o
                }
                invert() {
                    const e = this.elements,
                        t = e[0],
                        n = e[1],
                        i = e[2],
                        r = e[3],
                        a = e[4],
                        s = e[5],
                        o = e[6],
                        l = e[7],
                        c = e[8],
                        u = c * a - s * l,
                        h = s * o - c * r,
                        d = l * r - a * o,
                        p = t * u + n * h + i * d;
                    if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                    const f = 1 / p;
                    return e[0] = u * f, e[1] = (i * l - c * n) * f, e[2] = (s * n - i * a) * f, e[3] = h * f, e[4] = (c * t - i * o) * f, e[5] = (i * r - s * t) * f, e[6] = d * f, e[7] = (n * o - l * t) * f, e[8] = (a * t - n * r) * f, this
                }
                transpose() {
                    let e;
                    const t = this.elements;
                    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
                }
                getNormalMatrix(e) {
                    return this.setFromMatrix4(e).invert().transpose()
                }
                transposeIntoArray(e) {
                    const t = this.elements;
                    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
                }
                setUvTransform(e, t, n, i, r, a, s) {
                    const o = Math.cos(r),
                        l = Math.sin(r);
                    return this.set(n * o, n * l, -n * (o * a + l * s) + a + e, -i * l, i * o, -i * (-l * a + o * s) + s + t, 0, 0, 1), this
                }
                scale(e, t) {
                    const n = this.elements;
                    return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this
                }
                rotate(e) {
                    const t = Math.cos(e),
                        n = Math.sin(e),
                        i = this.elements,
                        r = i[0],
                        a = i[3],
                        s = i[6],
                        o = i[1],
                        l = i[4],
                        c = i[7];
                    return i[0] = t * r + n * o, i[3] = t * a + n * l, i[6] = t * s + n * c, i[1] = -n * r + t * o, i[4] = -n * a + t * l, i[7] = -n * s + t * c, this
                }
                translate(e, t) {
                    const n = this.elements;
                    return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this
                }
                equals(e) {
                    const t = this.elements,
                        n = e.elements;
                    for (let e = 0; e < 9; e++)
                        if (t[e] !== n[e]) return false;
                    return true
                }
                fromArray(e, t = 0) {
                    for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
                    return this
                }
                toArray(e = [], t = 0) {
                    const n = this.elements;
                    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
                }
                clone() {
                    return (new this.constructor).fromArray(this.elements)
                }
            }
            function ye(e) {
                if (0 === e.length) return -1 / 0;
                let t = e[0];
                for (let n = 1, i = e.length; n < i; ++n) e[n] > t && (t = e[n]);
                return t
            }
            ve.prototype.isMatrix3 = true;
            const xe = {
                Int8Array: Int8Array,
                Uint8Array: Uint8Array,
                Uint8ClampedArray: Uint8ClampedArray,
                Int16Array: Int16Array,
                Uint16Array: Uint16Array,
                Int32Array: Int32Array,
                Uint32Array: Uint32Array,
                Float32Array: Float32Array,
                Float64Array: Float64Array
            };
            function be(e, t) {
                return new xe[e](t)
            }
            function _e(e) {
                return document.createElementNS("http://www.w3.org/1999/xhtml", e)
            }
            function we(e, t = 0) {
                let n = 3735928559 ^ t,
                    i = 1103547991 ^ t;
                for (let t, r = 0; r < e.length; r++) t = e.charCodeAt(r), n = Math.imul(n ^ t, 2654435761), i = Math.imul(i ^ t, 1597334677);
                return n = Math.imul(n ^ n >>> 16, 2246822507) ^ Math.imul(i ^ i >>> 13, 3266489909), i = Math.imul(i ^ i >>> 16, 2246822507) ^ Math.imul(n ^ n >>> 13, 3266489909), 4294967296 * (2097151 & i) + (n >>> 0)
            }
            let Ee;
            class Me {
                static getDataURL(e) {
                    if (/^data:/i.test(e.src)) return e.src;
                    if ("undefined" == typeof HTMLCanvasElement) return e.src;
                    let t;
                    if (e instanceof HTMLCanvasElement) t = e;
                    else {
                        void 0 === Ee && (Ee = _e("canvas")), Ee.width = e.width, Ee.height = e.height;
                        const n = Ee.getContext("2d");
                        e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = Ee
                    }
                    return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
                }
            }
            let Te = 0;
            class Se extends ie {
                constructor(e = Se.DEFAULT_IMAGE, t = Se.DEFAULT_MAPPING, n = 1001, i = 1001, r = 1006, a = 1008, s = 1023, o = 1009, l = 1, c = 3e3) {
                    super(), Object.defineProperty(this, "id", {
                        value: Te++
                    }), this.uuid = le(), this.name = "", this.image = e, this.mipmaps = [], this.mapping = t, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = a, this.anisotropy = l, this.format = s, this.internalFormat = null, this.type = o, this.offset = new ge(0, 0), this.repeat = new ge(1, 1), this.center = new ge(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new ve, this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.encoding = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = false
                }
                updateMatrix() {
                    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this
                }
                toJSON(e) {
                    const t = void 0 === e || "string" == typeof e;
                    if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
                    const n = {
                        metadata: {
                            version: 4.5,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        type: this.type,
                        encoding: this.encoding,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY,
                        premultiplyAlpha: this.premultiplyAlpha,
                        unpackAlignment: this.unpackAlignment
                    };
                    if (void 0 !== this.image) {
                        const i = this.image;
                        if (void 0 === i.uuid && (i.uuid = le()), !t && void 0 === e.images[i.uuid]) {
                            let t;
                            if (Array.isArray(i)) {
                                t = [];
                                for (let e = 0, n = i.length; e < n; e++) i[e].isDataTexture ? t.push(Ae(i[e].image)) : t.push(Ae(i[e]))
                            } else t = Ae(i);
                            e.images[i.uuid] = {
                                uuid: i.uuid,
                                url: t
                            }
                        }
                        n.image = i.uuid
                    }
                    return "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
                transformUv(e) {
                    if (this.mapping !== i) return e;
                    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
                    case u:
                        e.x = e.x - Math.floor(e.x);
                        break;
                    case h:
                        e.x = e.x < 0 ? 0 : 1;
                        break;
                    case d:
                        1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                    }
                    if (e.y < 0 || e.y > 1) switch (this.wrapT) {
                    case u:
                        e.y = e.y - Math.floor(e.y);
                        break;
                    case h:
                        e.y = e.y < 0 ? 0 : 1;
                        break;
                    case d:
                        1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                    }
                    return this.flipY && (e.y = 1 - e.y), e
                }
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
            }
            function Ae(e) {
                return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? Me.getDataURL(e) : e.data ? {
                    data: Array.prototype.slice.call(e.data),
                    width: e.width,
                    height: e.height,
                    type: e.data.constructor.name
                } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
            }
            Se.DEFAULT_IMAGE = void 0, Se.DEFAULT_MAPPING = i, Se.prototype.isTexture = true;
            class Le {
                constructor(e = 0, t = 0, n = 0, i = 1) {
                    this.x = e, this.y = t, this.z = n, this.w = i
                }
                get width() {
                    return this.z
                }
                set width(e) {
                    this.z = e
                }
                get height() {
                    return this.w
                }
                set height(e) {
                    this.w = e
                }
                set(e, t, n, i) {
                    return this.x = e, this.y = t, this.z = n, this.w = i, this
                }
                setScalar(e) {
                    return this.x = e, this.y = e, this.z = e, this.w = e, this
                }
                setX(e) {
                    return this.x = e, this
                }
                setY(e) {
                    return this.y = e, this
                }
                setZ(e) {
                    return this.z = e, this
                }
                setW(e) {
                    return this.w = e, this
                }
                setComponent(e, t) {
                    switch (e) {
                    case 0:
                        this.x = t;
                        break;
                    case 1:
                        this.y = t;
                        break;
                    case 2:
                        this.z = t;
                        break;
                    case 3:
                        this.w = t;
                        break;
                    default:
                        throw new Error("index is out of range: " + e)
                    }
                    return this
                }
                getComponent(e) {
                    switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw new Error("index is out of range: " + e)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z, this.w)
                }
                copy(e) {
                    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
                }
                add(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
                }
                addScalar(e) {
                    return this.x += e, this.y += e, this.z += e, this.w += e, this
                }
                addVectors(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
                }
                addScaledVector(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
                }
                sub(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
                }
                subScalar(e) {
                    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
                }
                subVectors(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
                }
                multiply(e) {
                    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
                }
                multiplyScalar(e) {
                    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
                }
                applyMatrix4(e) {
                    const t = this.x,
                        n = this.y,
                        i = this.z,
                        r = this.w,
                        a = e.elements;
                    return this.x = a[0] * t + a[4] * n + a[8] * i + a[12] * r, this.y = a[1] * t + a[5] * n + a[9] * i + a[13] * r, this.z = a[2] * t + a[6] * n + a[10] * i + a[14] * r, this.w = a[3] * t + a[7] * n + a[11] * i + a[15] * r, this
                }
                divideScalar(e) {
                    return this.multiplyScalar(1 / e)
                }
                setAxisAngleFromQuaternion(e) {
                    this.w = 2 * Math.acos(e.w);
                    const t = Math.sqrt(1 - e.w * e.w);
                    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
                }
                setAxisAngleFromRotationMatrix(e) {
                    let t, n, i, r;
                    const a = .01,
                        s = .1,
                        o = e.elements,
                        l = o[0],
                        c = o[4],
                        u = o[8],
                        h = o[1],
                        d = o[5],
                        p = o[9],
                        f = o[2],
                        m = o[6],
                        g = o[10];
                    if (Math.abs(c - h) < a && Math.abs(u - f) < a && Math.abs(p - m) < a) {
                        if (Math.abs(c + h) < s && Math.abs(u + f) < s && Math.abs(p + m) < s && Math.abs(l + d + g - 3) < s) return this.set(1, 0, 0, 0), this;
                        t = Math.PI;
                        const e = (l + 1) / 2,
                            o = (d + 1) / 2,
                            v = (g + 1) / 2,
                            y = (c + h) / 4,
                            x = (u + f) / 4,
                            b = (p + m) / 4;
                        return e > o && e > v ? e < a ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(e), i = y / n, r = x / n) : o > v ? o < a ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(o), n = y / i, r = b / i) : v < a ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(v), n = x / r, i = b / r), this.set(n, i, r, t), this
                    }
                    let v = Math.sqrt((m - p) * (m - p) + (u - f) * (u - f) + (h - c) * (h - c));
                    return Math.abs(v) < .001 && (v = 1), this.x = (m - p) / v, this.y = (u - f) / v, this.z = (h - c) / v, this.w = Math.acos((l + d + g - 1) / 2), this
                }
                min(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
                }
                max(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
                }
                clamp(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
                }
                clampScalar(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
                }
                clampLength(e, t) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                }
                dot(e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(e) {
                    return this.normalize().multiplyScalar(e)
                }
                lerp(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
                }
                lerpVectors(e, t, n) {
                    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this
                }
                equals(e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
                }
                fromArray(e, t = 0) {
                    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
                }
                fromBufferAttribute(e, t, n) {
                    return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
                }*[Symbol.iterator]() {
                    yield this.x, yield this.y, yield this.z, yield this.w
                }
            }
            Le.prototype.isVector4 = true;
            class Re extends ie {
                constructor(e, t, n = {}) {
                    super(), this.width = e, this.height = t, this.depth = 1, this.scissor = new Le(0, 0, e, t), this.scissorTest = false, this.viewport = new Le(0, 0, e, t), this.texture = new Se(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = true, this.texture.image = {
                        width: e,
                        height: t,
                        depth: 1
                    }, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : g, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
                }
                setTexture(e) {
                    e.image = {
                        width: this.width,
                        height: this.height,
                        depth: this.depth
                    }, this.texture = e
                }
                setSize(e, t, n = 1) {
                    this.width === e && this.height === t && this.depth === n || (this.width = e, this.height = t, this.depth = n, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.image = {
                        ...this.texture.image
                    }, this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            Re.prototype.isWebGLRenderTarget = true;
            class Pe extends Re {
                constructor(e, t, n) {
                    super(e, t);
                    const i = this.texture;
                    this.texture = [];
                    for (let e = 0; e < n; e++) this.texture[e] = i.clone()
                }
                setSize(e, t, n = 1) {
                    if (this.width !== e || this.height !== t || this.depth !== n) {
                        this.width = e, this.height = t, this.depth = n;
                        for (let i = 0, r = this.texture.length; i < r; i++) this.texture[i].image.width = e, this.texture[i].image.height = t, this.texture[i].image.depth = n;
                        this.dispose()
                    }
                    return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this
                }
                copy(e) {
                    this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this.texture.length = 0;
                    for (let t = 0, n = e.texture.length; t < n; t++) this.texture[t] = e.texture[t].clone();
                    return this
                }
            }
            Pe.prototype.isWebGLMultipleRenderTargets = true;
            class Ce extends Re {
                constructor(e, t, n = {}) {
                    super(e, t, n), this.samples = 4, this.ignoreDepthForMultisampleCopy = void 0 === n.ignoreDepth || n.ignoreDepth, this.useRenderToTexture = void 0 !== n.useRenderToTexture && n.useRenderToTexture, this.useRenderbuffer = !1 === this.useRenderToTexture
                }
                copy(e) {
                    return super.copy.call(this, e), this.samples = e.samples, this.useRenderToTexture = e.useRenderToTexture, this.useRenderbuffer = e.useRenderbuffer, this
                }
            }
            Ce.prototype.isWebGLMultisampleRenderTarget = true;
            class Ie {
                constructor(e = 0, t = 0, n = 0, i = 1) {
                    this._x = e, this._y = t, this._z = n, this._w = i
                }
                static slerp(e, t, n, i) {
                    return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n.slerpQuaternions(e, t, i)
                }
                static slerpFlat(e, t, n, i, r, a, s) {
                    let o = n[i + 0],
                        l = n[i + 1],
                        c = n[i + 2],
                        u = n[i + 3];
                    const h = r[a + 0],
                        d = r[a + 1],
                        p = r[a + 2],
                        f = r[a + 3];
                    if (0 === s) return e[t + 0] = o, e[t + 1] = l, e[t + 2] = c, void(e[t + 3] = u);
                    if (1 === s) return e[t + 0] = h, e[t + 1] = d, e[t + 2] = p, void(e[t + 3] = f);
                    if (u !== f || o !== h || l !== d || c !== p) {
                        let e = 1 - s;
                        const t = o * h + l * d + c * p + u * f,
                            n = t >= 0 ? 1 : -1,
                            i = 1 - t * t;
                        if (i > Number.EPSILON) {
                            const r = Math.sqrt(i),
                                a = Math.atan2(r, t * n);
                            e = Math.sin(e * a) / r, s = Math.sin(s * a) / r
                        }
                        const r = s * n;
                        if (o = o * e + h * r, l = l * e + d * r, c = c * e + p * r, u = u * e + f * r, e === 1 - s) {
                            const e = 1 / Math.sqrt(o * o + l * l + c * c + u * u);
                            o *= e, l *= e, c *= e, u *= e
                        }
                    }
                    e[t] = o, e[t + 1] = l, e[t + 2] = c, e[t + 3] = u
                }
                static multiplyQuaternionsFlat(e, t, n, i, r, a) {
                    const s = n[i],
                        o = n[i + 1],
                        l = n[i + 2],
                        c = n[i + 3],
                        u = r[a],
                        h = r[a + 1],
                        d = r[a + 2],
                        p = r[a + 3];
                    return e[t] = s * p + c * u + o * d - l * h, e[t + 1] = o * p + c * h + l * u - s * d, e[t + 2] = l * p + c * d + s * h - o * u, e[t + 3] = c * p - s * u - o * h - l * d, e
                }
                get x() {
                    return this._x
                }
                set x(e) {
                    this._x = e, this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(e) {
                    this._y = e, this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(e) {
                    this._z = e, this._onChangeCallback()
                }
                get w() {
                    return this._w
                }
                set w(e) {
                    this._w = e, this._onChangeCallback()
                }
                set(e, t, n, i) {
                    return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._w)
                }
                copy(e) {
                    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
                }
                setFromEuler(e, t) {
                    if (!e || !e.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                    const n = e._x,
                        i = e._y,
                        r = e._z,
                        a = e._order,
                        s = Math.cos,
                        o = Math.sin,
                        l = s(n / 2),
                        c = s(i / 2),
                        u = s(r / 2),
                        h = o(n / 2),
                        d = o(i / 2),
                        p = o(r / 2);
                    switch (a) {
                    case "XYZ":
                        this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p;
                        break;
                    case "YXZ":
                        this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p;
                        break;
                    case "ZXY":
                        this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p;
                        break;
                    case "ZYX":
                        this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p;
                        break;
                    case "YZX":
                        this._x = h * c * u + l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u - h * d * p;
                        break;
                    case "XZY":
                        this._x = h * c * u - l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u + h * d * p;
                        break;
                    default:
                        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a)
                    }
                    return !1 !== t && this._onChangeCallback(), this
                }
                setFromAxisAngle(e, t) {
                    const n = t / 2,
                        i = Math.sin(n);
                    return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
                }
                setFromRotationMatrix(e) {
                    const t = e.elements,
                        n = t[0],
                        i = t[4],
                        r = t[8],
                        a = t[1],
                        s = t[5],
                        o = t[9],
                        l = t[2],
                        c = t[6],
                        u = t[10],
                        h = n + s + u;
                    if (h > 0) {
                        const e = .5 / Math.sqrt(h + 1);
                        this._w = .25 / e, this._x = (c - o) * e, this._y = (r - l) * e, this._z = (a - i) * e
                    } else if (n > s && n > u) {
                        const e = 2 * Math.sqrt(1 + n - s - u);
                        this._w = (c - o) / e, this._x = .25 * e, this._y = (i + a) / e, this._z = (r + l) / e
                    } else if (s > u) {
                        const e = 2 * Math.sqrt(1 + s - n - u);
                        this._w = (r - l) / e, this._x = (i + a) / e, this._y = .25 * e, this._z = (o + c) / e
                    } else {
                        const e = 2 * Math.sqrt(1 + u - n - s);
                        this._w = (a - i) / e, this._x = (r + l) / e, this._y = (o + c) / e, this._z = .25 * e
                    }
                    return this._onChangeCallback(), this
                }
                setFromUnitVectors(e, t) {
                    let n = e.dot(t) + 1;
                    return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize()
                }
                angleTo(e) {
                    return 2 * Math.acos(Math.abs(ce(this.dot(e), -1, 1)))
                }
                rotateTowards(e, t) {
                    const n = this.angleTo(e);
                    if (0 === n) return this;
                    const i = Math.min(1, t / n);
                    return this.slerp(e, i), this
                }
                identity() {
                    return this.set(0, 0, 0, 1)
                }
                invert() {
                    return this.conjugate()
                }
                conjugate() {
                    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
                }
                dot(e) {
                    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
                }
                lengthSq() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                }
                length() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                }
                normalize() {
                    let e = this.length();
                    return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
                }
                multiply(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
                }
                premultiply(e) {
                    return this.multiplyQuaternions(e, this)
                }
                multiplyQuaternions(e, t) {
                    const n = e._x,
                        i = e._y,
                        r = e._z,
                        a = e._w,
                        s = t._x,
                        o = t._y,
                        l = t._z,
                        c = t._w;
                    return this._x = n * c + a * s + i * l - r * o, this._y = i * c + a * o + r * s - n * l, this._z = r * c + a * l + n * o - i * s, this._w = a * c - n * s - i * o - r * l, this._onChangeCallback(), this
                }
                slerp(e, t) {
                    if (0 === t) return this;
                    if (1 === t) return this.copy(e);
                    const n = this._x,
                        i = this._y,
                        r = this._z,
                        a = this._w;
                    let s = a * e._w + n * e._x + i * e._y + r * e._z;
                    if (s < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, s = -s) : this.copy(e), s >= 1) return this._w = a, this._x = n, this._y = i, this._z = r, this;
                    const o = 1 - s * s;
                    if (o <= Number.EPSILON) {
                        const e = 1 - t;
                        return this._w = e * a + t * this._w, this._x = e * n + t * this._x, this._y = e * i + t * this._y, this._z = e * r + t * this._z, this.normalize(), this._onChangeCallback(), this
                    }
                    const l = Math.sqrt(o),
                        c = Math.atan2(l, s),
                        u = Math.sin((1 - t) * c) / l,
                        h = Math.sin(t * c) / l;
                    return this._w = a * u + this._w * h, this._x = n * u + this._x * h, this._y = i * u + this._y * h, this._z = r * u + this._z * h, this._onChangeCallback(), this
                }
                slerpQuaternions(e, t, n) {
                    this.copy(e).slerp(t, n)
                }
                random() {
                    const e = Math.random(),
                        t = Math.sqrt(1 - e),
                        n = Math.sqrt(e),
                        i = 2 * Math.PI * Math.random(),
                        r = 2 * Math.PI * Math.random();
                    return this.set(t * Math.cos(i), n * Math.sin(r), n * Math.cos(r), t * Math.sin(i))
                }
                equals(e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
                }
                fromArray(e, t = 0) {
                    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
                }
                fromBufferAttribute(e, t) {
                    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this
                }
                _onChange(e) {
                    return this._onChangeCallback = e, this
                }
                _onChangeCallback() {}
            }
            Ie.prototype.isQuaternion = true;
            class Fe {
                constructor(e = 0, t = 0, n = 0) {
                    this.x = e, this.y = t, this.z = n
                }
                set(e, t, n) {
                    return void 0 === n && (n = this.z), this.x = e, this.y = t, this.z = n, this
                }
                setScalar(e) {
                    return this.x = e, this.y = e, this.z = e, this
                }
                setX(e) {
                    return this.x = e, this
                }
                setY(e) {
                    return this.y = e, this
                }
                setZ(e) {
                    return this.z = e, this
                }
                setComponent(e, t) {
                    switch (e) {
                    case 0:
                        this.x = t;
                        break;
                    case 1:
                        this.y = t;
                        break;
                    case 2:
                        this.z = t;
                        break;
                    default:
                        throw new Error("index is out of range: " + e)
                    }
                    return this
                }
                getComponent(e) {
                    switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw new Error("index is out of range: " + e)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z)
                }
                copy(e) {
                    return this.x = e.x, this.y = e.y, this.z = e.z, this
                }
                add(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
                }
                addScalar(e) {
                    return this.x += e, this.y += e, this.z += e, this
                }
                addVectors(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
                }
                addScaledVector(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
                }
                sub(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
                }
                subScalar(e) {
                    return this.x -= e, this.y -= e, this.z -= e, this
                }
                subVectors(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
                }
                multiply(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
                }
                multiplyScalar(e) {
                    return this.x *= e, this.y *= e, this.z *= e, this
                }
                multiplyVectors(e, t) {
                    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
                }
                applyEuler(e) {
                    return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Ne.setFromEuler(e))
                }
                applyAxisAngle(e, t) {
                    return this.applyQuaternion(Ne.setFromAxisAngle(e, t))
                }
                applyMatrix3(e) {
                    const t = this.x,
                        n = this.y,
                        i = this.z,
                        r = e.elements;
                    return this.x = r[0] * t + r[3] * n + r[6] * i, this.y = r[1] * t + r[4] * n + r[7] * i, this.z = r[2] * t + r[5] * n + r[8] * i, this
                }
                applyNormalMatrix(e) {
                    return this.applyMatrix3(e).normalize()
                }
                applyMatrix4(e) {
                    const t = this.x,
                        n = this.y,
                        i = this.z,
                        r = e.elements,
                        a = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
                    return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * a, this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * a, this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * a, this
                }
                applyQuaternion(e) {
                    const t = this.x,
                        n = this.y,
                        i = this.z,
                        r = e.x,
                        a = e.y,
                        s = e.z,
                        o = e.w,
                        l = o * t + a * i - s * n,
                        c = o * n + s * t - r * i,
                        u = o * i + r * n - a * t,
                        h = -r * t - a * n - s * i;
                    return this.x = l * o + h * -r + c * -s - u * -a, this.y = c * o + h * -a + u * -r - l * -s, this.z = u * o + h * -s + l * -a - c * -r, this
                }
                project(e) {
                    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
                }
                unproject(e) {
                    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
                }
                transformDirection(e) {
                    const t = this.x,
                        n = this.y,
                        i = this.z,
                        r = e.elements;
                    return this.x = r[0] * t + r[4] * n + r[8] * i, this.y = r[1] * t + r[5] * n + r[9] * i, this.z = r[2] * t + r[6] * n + r[10] * i, this.normalize()
                }
                divide(e) {
                    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
                }
                divideScalar(e) {
                    return this.multiplyScalar(1 / e)
                }
                min(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
                }
                max(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
                }
                clamp(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
                }
                clampScalar(e, t) {
                    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
                }
                clampLength(e, t) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                }
                dot(e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(e) {
                    return this.normalize().multiplyScalar(e)
                }
                lerp(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
                }
                lerpVectors(e, t, n) {
                    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this
                }
                cross(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e)
                }
                crossVectors(e, t) {
                    const n = e.x,
                        i = e.y,
                        r = e.z,
                        a = t.x,
                        s = t.y,
                        o = t.z;
                    return this.x = i * o - r * s, this.y = r * a - n * o, this.z = n * s - i * a, this
                }
                projectOnVector(e) {
                    const t = e.lengthSq();
                    if (0 === t) return this.set(0, 0, 0);
                    const n = e.dot(this) / t;
                    return this.copy(e).multiplyScalar(n)
                }
                projectOnPlane(e) {
                    return De.copy(this).projectOnVector(e), this.sub(De)
                }
                reflect(e) {
                    return this.sub(De.copy(e).multiplyScalar(2 * this.dot(e)))
                }
                angleTo(e) {
                    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
                    if (0 === t) return Math.PI / 2;
                    const n = this.dot(e) / t;
                    return Math.acos(ce(n, -1, 1))
                }
                distanceTo(e) {
                    return Math.sqrt(this.distanceToSquared(e))
                }
                distanceToSquared(e) {
                    const t = this.x - e.x,
                        n = this.y - e.y,
                        i = this.z - e.z;
                    return t * t + n * n + i * i
                }
                manhattanDistanceTo(e) {
                    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
                }
                setFromSpherical(e) {
                    return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
                }
                setFromSphericalCoords(e, t, n) {
                    const i = Math.sin(t) * e;
                    return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this
                }
                setFromCylindrical(e) {
                    return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
                }
                setFromCylindricalCoords(e, t, n) {
                    return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this
                }
                setFromMatrixPosition(e) {
                    const t = e.elements;
                    return this.x = t[12], this.y = t[13], this.z = t[14], this
                }
                setFromMatrixScale(e) {
                    const t = this.setFromMatrixColumn(e, 0).length(),
                        n = this.setFromMatrixColumn(e, 1).length(),
                        i = this.setFromMatrixColumn(e, 2).length();
                    return this.x = t, this.y = n, this.z = i, this
                }
                setFromMatrixColumn(e, t) {
                    return this.fromArray(e.elements, 4 * t)
                }
                setFromMatrix3Column(e, t) {
                    return this.fromArray(e.elements, 3 * t)
                }
                equals(e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z
                }
                fromArray(e, t = 0) {
                    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
                }
                fromBufferAttribute(e, t, n) {
                    return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
                }
                randomDirection() {
                    const e = 2 * (Math.random() - .5),
                        t = Math.random() * Math.PI * 2,
                        n = Math.sqrt(1 - e ** 2);
                    return this.x = n * Math.cos(t), this.y = n * Math.sin(t), this.z = e, this
                }*[Symbol.iterator]() {
                    yield this.x, yield this.y, yield this.z
                }
            }
            Fe.prototype.isVector3 = true;
            const De = new Fe,
                Ne = new Ie;
            class Oe {
                constructor(e = new Fe(1 / 0, 1 / 0, 1 / 0), t = new Fe(-1 / 0, -1 / 0, -1 / 0)) {
                    this.min = e, this.max = t
                }
                set(e, t) {
                    return this.min.copy(e), this.max.copy(t), this
                }
                setFromArray(e) {
                    let t = 1 / 0,
                        n = 1 / 0,
                        i = 1 / 0,
                        r = -1 / 0,
                        a = -1 / 0,
                        s = -1 / 0;
                    for (let o = 0, l = e.length; o < l; o += 3) {
                        const l = e[o],
                            c = e[o + 1],
                            u = e[o + 2];
                        l < t && (t = l), c < n && (n = c), u < i && (i = u), l > r && (r = l), c > a && (a = c), u > s && (s = u)
                    }
                    return this.min.set(t, n, i), this.max.set(r, a, s), this
                }
                setFromBufferAttribute(e) {
                    let t = 1 / 0,
                        n = 1 / 0,
                        i = 1 / 0,
                        r = -1 / 0,
                        a = -1 / 0,
                        s = -1 / 0;
                    for (let o = 0, l = e.count; o < l; o++) {
                        const l = e.getX(o),
                            c = e.getY(o),
                            u = e.getZ(o);
                        l < t && (t = l), c < n && (n = c), u < i && (i = u), l > r && (r = l), c > a && (a = c), u > s && (s = u)
                    }
                    return this.min.set(t, n, i), this.max.set(r, a, s), this
                }
                setFromPoints(e) {
                    this.makeEmpty();
                    for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                    return this
                }
                setFromCenterAndSize(e, t) {
                    const n = Ue.copy(t).multiplyScalar(.5);
                    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
                }
                setFromObject(e) {
                    return this.makeEmpty(), this.expandByObject(e)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.min.copy(e.min), this.max.copy(e.max), this
                }
                makeEmpty() {
                    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                }
                isEmpty() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                }
                getCenter(e) {
                    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                }
                getSize(e) {
                    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
                }
                expandByPoint(e) {
                    return this.min.min(e), this.max.max(e), this
                }
                expandByVector(e) {
                    return this.min.sub(e), this.max.add(e), this
                }
                expandByScalar(e) {
                    return this.min.addScalar(-e), this.max.addScalar(e), this
                }
                expandByObject(e) {
                    e.updateWorldMatrix(false, false);
                    const t = e.geometry;
                    void 0 !== t && (null === t.boundingBox && t.computeBoundingBox(), Be.copy(t.boundingBox), Be.applyMatrix4(e.matrixWorld), this.union(Be));
                    const n = e.children;
                    for (let e = 0, t = n.length; e < t; e++) this.expandByObject(n[e]);
                    return this
                }
                containsPoint(e) {
                    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
                }
                containsBox(e) {
                    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
                }
                getParameter(e, t) {
                    return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
                }
                intersectsBox(e) {
                    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
                }
                intersectsSphere(e) {
                    return this.clampPoint(e.center, Ue), Ue.distanceToSquared(e.center) <= e.radius * e.radius
                }
                intersectsPlane(e) {
                    let t, n;
                    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant
                }
                intersectsTriangle(e) {
                    if (this.isEmpty()) return false;
                    this.getCenter(Xe), Ye.subVectors(this.max, Xe), ze.subVectors(e.a, Xe), ke.subVectors(e.b, Xe), Ge.subVectors(e.c, Xe), Ve.subVectors(ke, ze), je.subVectors(Ge, ke), We.subVectors(ze, Ge);
                    let t = [0, -Ve.z, Ve.y, 0, -je.z, je.y, 0, -We.z, We.y, Ve.z, 0, -Ve.x, je.z, 0, -je.x, We.z, 0, -We.x, -Ve.y, Ve.x, 0, -je.y, je.x, 0, -We.y, We.x, 0];
                    return !!Je(t, ze, ke, Ge, Ye) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Je(t, ze, ke, Ge, Ye) && (qe.crossVectors(Ve, je), t = [qe.x, qe.y, qe.z], Je(t, ze, ke, Ge, Ye)))
                }
                clampPoint(e, t) {
                    return t.copy(e).clamp(this.min, this.max)
                }
                distanceToPoint(e) {
                    return Ue.copy(e).clamp(this.min, this.max).sub(e).length()
                }
                getBoundingSphere(e) {
                    return this.getCenter(e.center), e.radius = .5 * this.getSize(Ue).length(), e
                }
                intersect(e) {
                    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
                }
                union(e) {
                    return this.min.min(e.min), this.max.max(e.max), this
                }
                applyMatrix4(e) {
                    return this.isEmpty() || (He[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), He[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), He[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), He[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), He[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), He[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), He[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), He[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(He)), this
                }
                translate(e) {
                    return this.min.add(e), this.max.add(e), this
                }
                equals(e) {
                    return e.min.equals(this.min) && e.max.equals(this.max)
                }
            }
            Oe.prototype.isBox3 = true;
            const He = [new Fe, new Fe, new Fe, new Fe, new Fe, new Fe, new Fe, new Fe],
                Ue = new Fe,
                Be = new Oe,
                ze = new Fe,
                ke = new Fe,
                Ge = new Fe,
                Ve = new Fe,
                je = new Fe,
                We = new Fe,
                Xe = new Fe,
                Ye = new Fe,
                qe = new Fe,
                Qe = new Fe;
            function Je(e, t, n, i, r) {
                for (let a = 0, s = e.length - 3; a <= s; a += 3) {
                    Qe.fromArray(e, a);
                    const s = r.x * Math.abs(Qe.x) + r.y * Math.abs(Qe.y) + r.z * Math.abs(Qe.z),
                        o = t.dot(Qe),
                        l = n.dot(Qe),
                        c = i.dot(Qe);
                    if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > s) return false
                }
                return true
            }
            const Ze = new Oe,
                Ke = new Fe,
                $e = new Fe,
                et = new Fe;
            class tt {
                constructor(e = new Fe, t = -1) {
                    this.center = e, this.radius = t
                }
                set(e, t) {
                    return this.center.copy(e), this.radius = t, this
                }
                setFromPoints(e, t) {
                    const n = this.center;
                    void 0 !== t ? n.copy(t) : Ze.setFromPoints(e).getCenter(n);
                    let i = 0;
                    for (let t = 0, r = e.length; t < r; t++) i = Math.max(i, n.distanceToSquared(e[t]));
                    return this.radius = Math.sqrt(i), this
                }
                copy(e) {
                    return this.center.copy(e.center), this.radius = e.radius, this
                }
                isEmpty() {
                    return this.radius < 0
                }
                makeEmpty() {
                    return this.center.set(0, 0, 0), this.radius = -1, this
                }
                containsPoint(e) {
                    return e.distanceToSquared(this.center) <= this.radius * this.radius
                }
                distanceToPoint(e) {
                    return e.distanceTo(this.center) - this.radius
                }
                intersectsSphere(e) {
                    const t = this.radius + e.radius;
                    return e.center.distanceToSquared(this.center) <= t * t
                }
                intersectsBox(e) {
                    return e.intersectsSphere(this)
                }
                intersectsPlane(e) {
                    return Math.abs(e.distanceToPoint(this.center)) <= this.radius
                }
                clampPoint(e, t) {
                    const n = this.center.distanceToSquared(e);
                    return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
                }
                getBoundingBox(e) {
                    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
                }
                applyMatrix4(e) {
                    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
                }
                translate(e) {
                    return this.center.add(e), this
                }
                expandByPoint(e) {
                    et.subVectors(e, this.center);
                    const t = et.lengthSq();
                    if (t > this.radius * this.radius) {
                        const e = Math.sqrt(t),
                            n = .5 * (e - this.radius);
                        this.center.add(et.multiplyScalar(n / e)), this.radius += n
                    }
                    return this
                }
                union(e) {
                    return $e.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius), this.expandByPoint(Ke.copy(e.center).add($e)), this.expandByPoint(Ke.copy(e.center).sub($e)), this
                }
                equals(e) {
                    return e.center.equals(this.center) && e.radius === this.radius
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            const nt = new Fe,
                it = new Fe,
                rt = new Fe,
                at = new Fe,
                st = new Fe,
                ot = new Fe,
                lt = new Fe;
            class ct {
                constructor(e = new Fe, t = new Fe(0, 0, -1)) {
                    this.origin = e, this.direction = t
                }
                set(e, t) {
                    return this.origin.copy(e), this.direction.copy(t), this
                }
                copy(e) {
                    return this.origin.copy(e.origin), this.direction.copy(e.direction), this
                }
                at(e, t) {
                    return t.copy(this.direction).multiplyScalar(e).add(this.origin)
                }
                lookAt(e) {
                    return this.direction.copy(e).sub(this.origin).normalize(), this
                }
                recast(e) {
                    return this.origin.copy(this.at(e, nt)), this
                }
                closestPointToPoint(e, t) {
                    t.subVectors(e, this.origin);
                    const n = t.dot(this.direction);
                    return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin)
                }
                distanceToPoint(e) {
                    return Math.sqrt(this.distanceSqToPoint(e))
                }
                distanceSqToPoint(e) {
                    const t = nt.subVectors(e, this.origin).dot(this.direction);
                    return t < 0 ? this.origin.distanceToSquared(e) : (nt.copy(this.direction).multiplyScalar(t).add(this.origin), nt.distanceToSquared(e))
                }
                distanceSqToSegment(e, t, n, i) {
                    it.copy(e).add(t).multiplyScalar(.5), rt.copy(t).sub(e).normalize(), at.copy(this.origin).sub(it);
                    const r = .5 * e.distanceTo(t),
                        a = -this.direction.dot(rt),
                        s = at.dot(this.direction),
                        o = -at.dot(rt),
                        l = at.lengthSq(),
                        c = Math.abs(1 - a * a);
                    let u, h, d, p;
                    if (c > 0)
                        if (u = a * o - s, h = a * s - o, p = r * c, u >= 0)
                            if (h >= -p)
                                if (h <= p) {
                                    const e = 1 / c;
                                    u *= e, h *= e, d = u * (u + a * h + 2 * s) + h * (a * u + h + 2 * o) + l
                                } else h = r, u = Math.max(0, -(a * h + s)), d = -u * u + h * (h + 2 * o) + l;
                    else h = -r, u = Math.max(0, -(a * h + s)), d = -u * u + h * (h + 2 * o) + l;
                    else h <= -p ? (u = Math.max(0, -(-a * r + s)), h = u > 0 ? -r : Math.min(Math.max(-r, -o), r), d = -u * u + h * (h + 2 * o) + l) : h <= p ? (u = 0, h = Math.min(Math.max(-r, -o), r), d = h * (h + 2 * o) + l) : (u = Math.max(0, -(a * r + s)), h = u > 0 ? r : Math.min(Math.max(-r, -o), r), d = -u * u + h * (h + 2 * o) + l);
                    else h = a > 0 ? -r : r, u = Math.max(0, -(a * h + s)), d = -u * u + h * (h + 2 * o) + l;
                    return n && n.copy(this.direction).multiplyScalar(u).add(this.origin), i && i.copy(rt).multiplyScalar(h).add(it), d
                }
                intersectSphere(e, t) {
                    nt.subVectors(e.center, this.origin);
                    const n = nt.dot(this.direction),
                        i = nt.dot(nt) - n * n,
                        r = e.radius * e.radius;
                    if (i > r) return null;
                    const a = Math.sqrt(r - i),
                        s = n - a,
                        o = n + a;
                    return s < 0 && o < 0 ? null : s < 0 ? this.at(o, t) : this.at(s, t)
                }
                intersectsSphere(e) {
                    return this.distanceSqToPoint(e.center) <= e.radius * e.radius
                }
                distanceToPlane(e) {
                    const t = e.normal.dot(this.direction);
                    if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
                    const n = -(this.origin.dot(e.normal) + e.constant) / t;
                    return n >= 0 ? n : null
                }
                intersectPlane(e, t) {
                    const n = this.distanceToPlane(e);
                    return null === n ? null : this.at(n, t)
                }
                intersectsPlane(e) {
                    const t = e.distanceToPoint(this.origin);
                    return 0 === t || e.normal.dot(this.direction) * t < 0
                }
                intersectBox(e, t) {
                    let n, i, r, a, s, o;
                    const l = 1 / this.direction.x,
                        c = 1 / this.direction.y,
                        u = 1 / this.direction.z,
                        h = this.origin;
                    return l >= 0 ? (n = (e.min.x - h.x) * l, i = (e.max.x - h.x) * l) : (n = (e.max.x - h.x) * l, i = (e.min.x - h.x) * l), c >= 0 ? (r = (e.min.y - h.y) * c, a = (e.max.y - h.y) * c) : (r = (e.max.y - h.y) * c, a = (e.min.y - h.y) * c), n > a || r > i ? null : ((r > n || n != n) && (n = r), (a < i || i != i) && (i = a), u >= 0 ? (s = (e.min.z - h.z) * u, o = (e.max.z - h.z) * u) : (s = (e.max.z - h.z) * u, o = (e.min.z - h.z) * u), n > o || s > i ? null : ((s > n || n != n) && (n = s), (o < i || i != i) && (i = o), i < 0 ? null : this.at(n >= 0 ? n : i, t)))
                }
                intersectsBox(e) {
                    return null !== this.intersectBox(e, nt)
                }
                intersectTriangle(e, t, n, i, r) {
                    st.subVectors(t, e), ot.subVectors(n, e), lt.crossVectors(st, ot);
                    let a, s = this.direction.dot(lt);
                    if (s > 0) {
                        if (i) return null;
                        a = 1
                    } else {
                        if (!(s < 0)) return null;
                        a = -1, s = -s
                    }
                    at.subVectors(this.origin, e);
                    const o = a * this.direction.dot(ot.crossVectors(at, ot));
                    if (o < 0) return null;
                    const l = a * this.direction.dot(st.cross(at));
                    if (l < 0) return null;
                    if (o + l > s) return null;
                    const c = -a * at.dot(lt);
                    return c < 0 ? null : this.at(c / s, r)
                }
                applyMatrix4(e) {
                    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
                }
                equals(e) {
                    return e.origin.equals(this.origin) && e.direction.equals(this.direction)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            class ut {
                constructor() {
                    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
                }
                set(e, t, n, i, r, a, s, o, l, c, u, h, d, p, f, m) {
                    const g = this.elements;
                    return g[0] = e, g[4] = t, g[8] = n, g[12] = i, g[1] = r, g[5] = a, g[9] = s, g[13] = o, g[2] = l, g[6] = c, g[10] = u, g[14] = h, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
                clone() {
                    return (new ut).fromArray(this.elements)
                }
                copy(e) {
                    const t = this.elements,
                        n = e.elements;
                    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
                }
                copyPosition(e) {
                    const t = this.elements,
                        n = e.elements;
                    return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
                }
                setFromMatrix3(e) {
                    const t = e.elements;
                    return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this
                }
                extractBasis(e, t, n) {
                    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
                }
                makeBasis(e, t, n) {
                    return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
                }
                extractRotation(e) {
                    const t = this.elements,
                        n = e.elements,
                        i = 1 / ht.setFromMatrixColumn(e, 0).length(),
                        r = 1 / ht.setFromMatrixColumn(e, 1).length(),
                        a = 1 / ht.setFromMatrixColumn(e, 2).length();
                    return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = 0, t[8] = n[8] * a, t[9] = n[9] * a, t[10] = n[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                }
                makeRotationFromEuler(e) {
                    e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                    const t = this.elements,
                        n = e.x,
                        i = e.y,
                        r = e.z,
                        a = Math.cos(n),
                        s = Math.sin(n),
                        o = Math.cos(i),
                        l = Math.sin(i),
                        c = Math.cos(r),
                        u = Math.sin(r);
                    if ("XYZ" === e.order) {
                        const e = a * c,
                            n = a * u,
                            i = s * c,
                            r = s * u;
                        t[0] = o * c, t[4] = -o * u, t[8] = l, t[1] = n + i * l, t[5] = e - r * l, t[9] = -s * o, t[2] = r - e * l, t[6] = i + n * l, t[10] = a * o
                    } else if ("YXZ" === e.order) {
                        const e = o * c,
                            n = o * u,
                            i = l * c,
                            r = l * u;
                        t[0] = e + r * s, t[4] = i * s - n, t[8] = a * l, t[1] = a * u, t[5] = a * c, t[9] = -s, t[2] = n * s - i, t[6] = r + e * s, t[10] = a * o
                    } else if ("ZXY" === e.order) {
                        const e = o * c,
                            n = o * u,
                            i = l * c,
                            r = l * u;
                        t[0] = e - r * s, t[4] = -a * u, t[8] = i + n * s, t[1] = n + i * s, t[5] = a * c, t[9] = r - e * s, t[2] = -a * l, t[6] = s, t[10] = a * o
                    } else if ("ZYX" === e.order) {
                        const e = a * c,
                            n = a * u,
                            i = s * c,
                            r = s * u;
                        t[0] = o * c, t[4] = i * l - n, t[8] = e * l + r, t[1] = o * u, t[5] = r * l + e, t[9] = n * l - i, t[2] = -l, t[6] = s * o, t[10] = a * o
                    } else if ("YZX" === e.order) {
                        const e = a * o,
                            n = a * l,
                            i = s * o,
                            r = s * l;
                        t[0] = o * c, t[4] = r - e * u, t[8] = i * u + n, t[1] = u, t[5] = a * c, t[9] = -s * c, t[2] = -l * c, t[6] = n * u + i, t[10] = e - r * u
                    } else if ("XZY" === e.order) {
                        const e = a * o,
                            n = a * l,
                            i = s * o,
                            r = s * l;
                        t[0] = o * c, t[4] = -u, t[8] = l * c, t[1] = e * u + r, t[5] = a * c, t[9] = n * u - i, t[2] = i * u - n, t[6] = s * c, t[10] = r * u + e
                    }
                    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                }
                makeRotationFromQuaternion(e) {
                    return this.compose(pt, e, ft)
                }
                lookAt(e, t, n) {
                    const i = this.elements;
                    return vt.subVectors(e, t), 0 === vt.lengthSq() && (vt.z = 1), vt.normalize(), mt.crossVectors(n, vt), 0 === mt.lengthSq() && (1 === Math.abs(n.z) ? vt.x += 1e-4 : vt.z += 1e-4, vt.normalize(), mt.crossVectors(n, vt)), mt.normalize(), gt.crossVectors(vt, mt), i[0] = mt.x, i[4] = gt.x, i[8] = vt.x, i[1] = mt.y, i[5] = gt.y, i[9] = vt.y, i[2] = mt.z, i[6] = gt.z, i[10] = vt.z, this
                }
                multiply(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
                }
                premultiply(e) {
                    return this.multiplyMatrices(e, this)
                }
                multiplyMatrices(e, t) {
                    const n = e.elements,
                        i = t.elements,
                        r = this.elements,
                        a = n[0],
                        s = n[4],
                        o = n[8],
                        l = n[12],
                        c = n[1],
                        u = n[5],
                        h = n[9],
                        d = n[13],
                        p = n[2],
                        f = n[6],
                        m = n[10],
                        g = n[14],
                        v = n[3],
                        y = n[7],
                        x = n[11],
                        b = n[15],
                        _ = i[0],
                        w = i[4],
                        E = i[8],
                        M = i[12],
                        T = i[1],
                        S = i[5],
                        A = i[9],
                        L = i[13],
                        R = i[2],
                        P = i[6],
                        C = i[10],
                        I = i[14],
                        F = i[3],
                        D = i[7],
                        N = i[11],
                        O = i[15];
                    return r[0] = a * _ + s * T + o * R + l * F, r[4] = a * w + s * S + o * P + l * D, r[8] = a * E + s * A + o * C + l * N, r[12] = a * M + s * L + o * I + l * O, r[1] = c * _ + u * T + h * R + d * F, r[5] = c * w + u * S + h * P + d * D, r[9] = c * E + u * A + h * C + d * N, r[13] = c * M + u * L + h * I + d * O, r[2] = p * _ + f * T + m * R + g * F, r[6] = p * w + f * S + m * P + g * D, r[10] = p * E + f * A + m * C + g * N, r[14] = p * M + f * L + m * I + g * O, r[3] = v * _ + y * T + x * R + b * F, r[7] = v * w + y * S + x * P + b * D, r[11] = v * E + y * A + x * C + b * N, r[15] = v * M + y * L + x * I + b * O, this
                }
                multiplyScalar(e) {
                    const t = this.elements;
                    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
                }
                determinant() {
                    const e = this.elements,
                        t = e[0],
                        n = e[4],
                        i = e[8],
                        r = e[12],
                        a = e[1],
                        s = e[5],
                        o = e[9],
                        l = e[13],
                        c = e[2],
                        u = e[6],
                        h = e[10],
                        d = e[14];
                    return e[3] * (+r * o * u - i * l * u - r * s * h + n * l * h + i * s * d - n * o * d) + e[7] * (+t * o * d - t * l * h + r * a * h - i * a * d + i * l * c - r * o * c) + e[11] * (+t * l * u - t * s * d - r * a * u + n * a * d + r * s * c - n * l * c) + e[15] * (-i * s * c - t * o * u + t * s * h + i * a * u - n * a * h + n * o * c)
                }
                transpose() {
                    const e = this.elements;
                    let t;
                    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
                }
                setPosition(e, t, n) {
                    const i = this.elements;
                    return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this
                }
                invert() {
                    const e = this.elements,
                        t = e[0],
                        n = e[1],
                        i = e[2],
                        r = e[3],
                        a = e[4],
                        s = e[5],
                        o = e[6],
                        l = e[7],
                        c = e[8],
                        u = e[9],
                        h = e[10],
                        d = e[11],
                        p = e[12],
                        f = e[13],
                        m = e[14],
                        g = e[15],
                        v = u * m * l - f * h * l + f * o * d - s * m * d - u * o * g + s * h * g,
                        y = p * h * l - c * m * l - p * o * d + a * m * d + c * o * g - a * h * g,
                        x = c * f * l - p * u * l + p * s * d - a * f * d - c * s * g + a * u * g,
                        b = p * u * o - c * f * o - p * s * h + a * f * h + c * s * m - a * u * m,
                        _ = t * v + n * y + i * x + r * b;
                    if (0 === _) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                    const w = 1 / _;
                    return e[0] = v * w, e[1] = (f * h * r - u * m * r - f * i * d + n * m * d + u * i * g - n * h * g) * w, e[2] = (s * m * r - f * o * r + f * i * l - n * m * l - s * i * g + n * o * g) * w, e[3] = (u * o * r - s * h * r - u * i * l + n * h * l + s * i * d - n * o * d) * w, e[4] = y * w, e[5] = (c * m * r - p * h * r + p * i * d - t * m * d - c * i * g + t * h * g) * w, e[6] = (p * o * r - a * m * r - p * i * l + t * m * l + a * i * g - t * o * g) * w, e[7] = (a * h * r - c * o * r + c * i * l - t * h * l - a * i * d + t * o * d) * w, e[8] = x * w, e[9] = (p * u * r - c * f * r - p * n * d + t * f * d + c * n * g - t * u * g) * w, e[10] = (a * f * r - p * s * r + p * n * l - t * f * l - a * n * g + t * s * g) * w, e[11] = (c * s * r - a * u * r - c * n * l + t * u * l + a * n * d - t * s * d) * w, e[12] = b * w, e[13] = (c * f * i - p * u * i + p * n * h - t * f * h - c * n * m + t * u * m) * w, e[14] = (p * s * i - a * f * i - p * n * o + t * f * o + a * n * m - t * s * m) * w, e[15] = (a * u * i - c * s * i + c * n * o - t * u * o - a * n * h + t * s * h) * w, this
                }
                scale(e) {
                    const t = this.elements,
                        n = e.x,
                        i = e.y,
                        r = e.z;
                    return t[0] *= n, t[4] *= i, t[8] *= r, t[1] *= n, t[5] *= i, t[9] *= r, t[2] *= n, t[6] *= i, t[10] *= r, t[3] *= n, t[7] *= i, t[11] *= r, this
                }
                getMaxScaleOnAxis() {
                    const e = this.elements,
                        t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                        n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                        i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                    return Math.sqrt(Math.max(t, n, i))
                }
                makeTranslation(e, t, n) {
                    return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
                }
                makeRotationX(e) {
                    const t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
                }
                makeRotationY(e) {
                    const t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
                }
                makeRotationZ(e) {
                    const t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
                makeRotationAxis(e, t) {
                    const n = Math.cos(t),
                        i = Math.sin(t),
                        r = 1 - n,
                        a = e.x,
                        s = e.y,
                        o = e.z,
                        l = r * a,
                        c = r * s;
                    return this.set(l * a + n, l * s - i * o, l * o + i * s, 0, l * s + i * o, c * s + n, c * o - i * a, 0, l * o - i * s, c * o + i * a, r * o * o + n, 0, 0, 0, 0, 1), this
                }
                makeScale(e, t, n) {
                    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
                }
                makeShear(e, t, n, i, r, a) {
                    return this.set(1, n, r, 0, e, 1, a, 0, t, i, 1, 0, 0, 0, 0, 1), this
                }
                compose(e, t, n) {
                    const i = this.elements,
                        r = t._x,
                        a = t._y,
                        s = t._z,
                        o = t._w,
                        l = r + r,
                        c = a + a,
                        u = s + s,
                        h = r * l,
                        d = r * c,
                        p = r * u,
                        f = a * c,
                        m = a * u,
                        g = s * u,
                        v = o * l,
                        y = o * c,
                        x = o * u,
                        b = n.x,
                        _ = n.y,
                        w = n.z;
                    return i[0] = (1 - (f + g)) * b, i[1] = (d + x) * b, i[2] = (p - y) * b, i[3] = 0, i[4] = (d - x) * _, i[5] = (1 - (h + g)) * _, i[6] = (m + v) * _, i[7] = 0, i[8] = (p + y) * w, i[9] = (m - v) * w, i[10] = (1 - (h + f)) * w, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this
                }
                decompose(e, t, n) {
                    const i = this.elements;
                    let r = ht.set(i[0], i[1], i[2]).length();
                    const a = ht.set(i[4], i[5], i[6]).length(),
                        s = ht.set(i[8], i[9], i[10]).length();
                    this.determinant() < 0 && (r = -r), e.x = i[12], e.y = i[13], e.z = i[14], dt.copy(this);
                    const o = 1 / r,
                        l = 1 / a,
                        c = 1 / s;
                    return dt.elements[0] *= o, dt.elements[1] *= o, dt.elements[2] *= o, dt.elements[4] *= l, dt.elements[5] *= l, dt.elements[6] *= l, dt.elements[8] *= c, dt.elements[9] *= c, dt.elements[10] *= c, t.setFromRotationMatrix(dt), n.x = r, n.y = a, n.z = s, this
                }
                makePerspective(e, t, n, i, r, a) {
                    void 0 === a && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                    const s = this.elements,
                        o = 2 * r / (t - e),
                        l = 2 * r / (n - i),
                        c = (t + e) / (t - e),
                        u = (n + i) / (n - i),
                        h = -(a + r) / (a - r),
                        d = -2 * a * r / (a - r);
                    return s[0] = o, s[4] = 0, s[8] = c, s[12] = 0, s[1] = 0, s[5] = l, s[9] = u, s[13] = 0, s[2] = 0, s[6] = 0, s[10] = h, s[14] = d, s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this
                }
                makeOrthographic(e, t, n, i, r, a) {
                    const s = this.elements,
                        o = 1 / (t - e),
                        l = 1 / (n - i),
                        c = 1 / (a - r),
                        u = (t + e) * o,
                        h = (n + i) * l,
                        d = (a + r) * c;
                    return s[0] = 2 * o, s[4] = 0, s[8] = 0, s[12] = -u, s[1] = 0, s[5] = 2 * l, s[9] = 0, s[13] = -h, s[2] = 0, s[6] = 0, s[10] = -2 * c, s[14] = -d, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this
                }
                equals(e) {
                    const t = this.elements,
                        n = e.elements;
                    for (let e = 0; e < 16; e++)
                        if (t[e] !== n[e]) return false;
                    return true
                }
                fromArray(e, t = 0) {
                    for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
                    return this
                }
                toArray(e = [], t = 0) {
                    const n = this.elements;
                    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
                }
            }
            ut.prototype.isMatrix4 = true;
            const ht = new Fe,
                dt = new ut,
                pt = new Fe(0, 0, 0),
                ft = new Fe(1, 1, 1),
                mt = new Fe,
                gt = new Fe,
                vt = new Fe,
                yt = new ut,
                xt = new Ie;
            class bt {
                constructor(e = 0, t = 0, n = 0, i = bt.DefaultOrder) {
                    this._x = e, this._y = t, this._z = n, this._order = i
                }
                get x() {
                    return this._x
                }
                set x(e) {
                    this._x = e, this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(e) {
                    this._y = e, this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(e) {
                    this._z = e, this._onChangeCallback()
                }
                get order() {
                    return this._order
                }
                set order(e) {
                    this._order = e, this._onChangeCallback()
                }
                set(e, t, n, i = this._order) {
                    return this._x = e, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._order)
                }
                copy(e) {
                    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
                }
                setFromRotationMatrix(e, t = this._order, n = true) {
                    const i = e.elements,
                        r = i[0],
                        a = i[4],
                        s = i[8],
                        o = i[1],
                        l = i[5],
                        c = i[9],
                        u = i[2],
                        h = i[6],
                        d = i[10];
                    switch (t) {
                    case "XYZ":
                        this._y = Math.asin(ce(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-a, r)) : (this._x = Math.atan2(h, l), this._z = 0);
                        break;
                    case "YXZ":
                        this._x = Math.asin(-ce(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(s, d), this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-u, r), this._z = 0);
                        break;
                    case "ZXY":
                        this._x = Math.asin(ce(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(-u, d), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(o, r));
                        break;
                    case "ZYX":
                        this._y = Math.asin(-ce(u, -1, 1)), Math.abs(u) < .9999999 ? (this._x = Math.atan2(h, d), this._z = Math.atan2(o, r)) : (this._x = 0, this._z = Math.atan2(-a, l));
                        break;
                    case "YZX":
                        this._z = Math.asin(ce(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-u, r)) : (this._x = 0, this._y = Math.atan2(s, d));
                        break;
                    case "XZY":
                        this._z = Math.asin(-ce(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(h, l), this._y = Math.atan2(s, r)) : (this._x = Math.atan2(-c, d), this._y = 0);
                        break;
                    default:
                        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
                    }
                    return this._order = t, !0 === n && this._onChangeCallback(), this
                }
                setFromQuaternion(e, t, n) {
                    return yt.makeRotationFromQuaternion(e), this.setFromRotationMatrix(yt, t, n)
                }
                setFromVector3(e, t = this._order) {
                    return this.set(e.x, e.y, e.z, t)
                }
                reorder(e) {
                    return xt.setFromEuler(this), this.setFromQuaternion(xt, e)
                }
                equals(e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
                }
                fromArray(e) {
                    return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
                }
                toVector3(e) {
                    return e ? e.set(this._x, this._y, this._z) : new Fe(this._x, this._y, this._z)
                }
                _onChange(e) {
                    return this._onChangeCallback = e, this
                }
                _onChangeCallback() {}
            }
            bt.prototype.isEuler = true, bt.DefaultOrder = "XYZ", bt.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
            class _t {
                constructor() {
                    this.mask = 1
                }
                set(e) {
                    this.mask = (1 << e | 0) >>> 0
                }
                enable(e) {
                    this.mask |= 1 << e | 0
                }
                enableAll() {
                    this.mask = -1
                }
                toggle(e) {
                    this.mask ^= 1 << e | 0
                }
                disable(e) {
                    this.mask &= ~(1 << e | 0)
                }
                disableAll() {
                    this.mask = 0
                }
                test(e) {
                    return 0 != (this.mask & e.mask)
                }
                isEnabled(e) {
                    return 0 != (this.mask & (1 << e | 0))
                }
            }
            let wt = 0;
            const Et = new Fe,
                Mt = new Ie,
                Tt = new ut,
                St = new Fe,
                At = new Fe,
                Lt = new Fe,
                Rt = new Ie,
                Pt = new Fe(1, 0, 0),
                Ct = new Fe(0, 1, 0),
                It = new Fe(0, 0, 1),
                Ft = {
                    type: "added"
                },
                Dt = {
                    type: "removed"
                };
            class Nt extends ie {
                constructor() {
                    super(), Object.defineProperty(this, "id", {
                        value: wt++
                    }), this.uuid = le(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Nt.DefaultUp.clone();
                    const e = new Fe,
                        t = new bt,
                        n = new Ie,
                        i = new Fe(1, 1, 1);
                    t._onChange((function () {
                        n.setFromEuler(t, false)
                    })), n._onChange((function () {
                        t.setFromQuaternion(n, void 0, false)
                    })), Object.defineProperties(this, {
                        position: {
                            configurable: true,
                            enumerable: true,
                            value: e
                        },
                        rotation: {
                            configurable: true,
                            enumerable: true,
                            value: t
                        },
                        quaternion: {
                            configurable: true,
                            enumerable: true,
                            value: n
                        },
                        scale: {
                            configurable: true,
                            enumerable: true,
                            value: i
                        },
                        modelViewMatrix: {
                            value: new ut
                        },
                        normalMatrix: {
                            value: new ve
                        }
                    }), this.matrix = new ut, this.matrixWorld = new ut, this.matrixAutoUpdate = Nt.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = false, this.layers = new _t, this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {}
                }
                onBeforeRender() {}
                onAfterRender() {}
                applyMatrix4(e) {
                    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
                }
                applyQuaternion(e) {
                    return this.quaternion.premultiply(e), this
                }
                setRotationFromAxisAngle(e, t) {
                    this.quaternion.setFromAxisAngle(e, t)
                }
                setRotationFromEuler(e) {
                    this.quaternion.setFromEuler(e, true)
                }
                setRotationFromMatrix(e) {
                    this.quaternion.setFromRotationMatrix(e)
                }
                setRotationFromQuaternion(e) {
                    this.quaternion.copy(e)
                }
                rotateOnAxis(e, t) {
                    return Mt.setFromAxisAngle(e, t), this.quaternion.multiply(Mt), this
                }
                rotateOnWorldAxis(e, t) {
                    return Mt.setFromAxisAngle(e, t), this.quaternion.premultiply(Mt), this
                }
                rotateX(e) {
                    return this.rotateOnAxis(Pt, e)
                }
                rotateY(e) {
                    return this.rotateOnAxis(Ct, e)
                }
                rotateZ(e) {
                    return this.rotateOnAxis(It, e)
                }
                translateOnAxis(e, t) {
                    return Et.copy(e).applyQuaternion(this.quaternion), this.position.add(Et.multiplyScalar(t)), this
                }
                translateX(e) {
                    return this.translateOnAxis(Pt, e)
                }
                translateY(e) {
                    return this.translateOnAxis(Ct, e)
                }
                translateZ(e) {
                    return this.translateOnAxis(It, e)
                }
                localToWorld(e) {
                    return e.applyMatrix4(this.matrixWorld)
                }
                worldToLocal(e) {
                    return e.applyMatrix4(Tt.copy(this.matrixWorld).invert())
                }
                lookAt(e, t, n) {
                    e.isVector3 ? St.copy(e) : St.set(e, t, n);
                    const i = this.parent;
                    this.updateWorldMatrix(true, false), At.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Tt.lookAt(At, St, this.up) : Tt.lookAt(St, At, this.up), this.quaternion.setFromRotationMatrix(Tt), i && (Tt.extractRotation(i.matrixWorld), Mt.setFromRotationMatrix(Tt), this.quaternion.premultiply(Mt.invert()))
                }
                add(e) {
                    if (arguments.length > 1) {
                        for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
                        return this
                    }
                    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(Ft)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
                }
                remove(e) {
                    if (arguments.length > 1) {
                        for (let e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                        return this
                    }
                    const t = this.children.indexOf(e);
                    return -1 !== t && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(Dt)), this
                }
                removeFromParent() {
                    const e = this.parent;
                    return null !== e && e.remove(this), this
                }
                clear() {
                    for (let e = 0; e < this.children.length; e++) {
                        const t = this.children[e];
                        t.parent = null, t.dispatchEvent(Dt)
                    }
                    return this.children.length = 0, this
                }
                attach(e) {
                    return this.updateWorldMatrix(true, false), Tt.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(true, false), Tt.multiply(e.parent.matrixWorld)), e.applyMatrix4(Tt), this.add(e), e.updateWorldMatrix(false, true), this
                }
                getObjectById(e) {
                    return this.getObjectByProperty("id", e)
                }
                getObjectByName(e) {
                    return this.getObjectByProperty("name", e)
                }
                getObjectByProperty(e, t) {
                    if (this[e] === t) return this;
                    for (let n = 0, i = this.children.length; n < i; n++) {
                        const i = this.children[n].getObjectByProperty(e, t);
                        if (void 0 !== i) return i
                    }
                }
                getWorldPosition(e) {
                    return this.updateWorldMatrix(true, false), e.setFromMatrixPosition(this.matrixWorld)
                }
                getWorldQuaternion(e) {
                    return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(At, e, Lt), e
                }
                getWorldScale(e) {
                    return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(At, Rt, e), e
                }
                getWorldDirection(e) {
                    this.updateWorldMatrix(true, false);
                    const t = this.matrixWorld.elements;
                    return e.set(t[8], t[9], t[10]).normalize()
                }
                raycast() {}
                traverse(e) {
                    e(this);
                    const t = this.children;
                    for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e)
                }
                traverseVisible(e) {
                    if (!1 === this.visible) return;
                    e(this);
                    const t = this.children;
                    for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e)
                }
                traverseAncestors(e) {
                    const t = this.parent;
                    null !== t && (e(t), t.traverseAncestors(e))
                }
                updateMatrix() {
                    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true
                }
                updateMatrixWorld(e) {
                    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = false, e = true);
                    const t = this.children;
                    for (let n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e)
                }
                updateWorldMatrix(e, t) {
                    const n = this.parent;
                    if (!0 === e && null !== n && n.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t) {
                        const e = this.children;
                        for (let t = 0, n = e.length; t < n; t++) e[t].updateWorldMatrix(false, true)
                    }
                }
                toJSON(e) {
                    const t = void 0 === e || "string" == typeof e,
                        n = {};
                    t && (e = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {},
                        skeletons: {},
                        animations: {}
                    }, n.metadata = {
                        version: 4.5,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    const i = {};
                    function r(t, n) {
                        return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid
                    }
                    if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = true), !0 === this.receiveShadow && (i.receiveShadow = true), !1 === this.visible && (i.visible = false), !1 === this.frustumCulled && (i.frustumCulled = false), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = false), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && (i.environment = this.environment.toJSON(e).uuid);
                    else if (this.isMesh || this.isLine || this.isPoints) {
                        i.geometry = r(e.geometries, this.geometry);
                        const t = this.geometry.parameters;
                        if (void 0 !== t && void 0 !== t.shapes) {
                            const n = t.shapes;
                            if (Array.isArray(n))
                                for (let t = 0, i = n.length; t < i; t++) {
                                    const i = n[t];
                                    r(e.shapes, i)
                                } else r(e.shapes, n)
                        }
                    }
                    if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                        if (Array.isArray(this.material)) {
                            const t = [];
                            for (let n = 0, i = this.material.length; n < i; n++) t.push(r(e.materials, this.material[n]));
                            i.material = t
                        } else i.material = r(e.materials, this.material);
                    if (this.children.length > 0) {
                        i.children = [];
                        for (let t = 0; t < this.children.length; t++) i.children.push(this.children[t].toJSON(e).object)
                    }
                    if (this.animations.length > 0) {
                        i.animations = [];
                        for (let t = 0; t < this.animations.length; t++) {
                            const n = this.animations[t];
                            i.animations.push(r(e.animations, n))
                        }
                    }
                    if (t) {
                        const t = a(e.geometries),
                            i = a(e.materials),
                            r = a(e.textures),
                            s = a(e.images),
                            o = a(e.shapes),
                            l = a(e.skeletons),
                            c = a(e.animations);
                        t.length > 0 && (n.geometries = t), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), s.length > 0 && (n.images = s), o.length > 0 && (n.shapes = o), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c)
                    }
                    return n.object = i, n;
                    function a(e) {
                        const t = [];
                        for (const n in e) {
                            const i = e[n];
                            delete i.metadata, t.push(i)
                        }
                        return t
                    }
                }
                clone(e) {
                    return (new this.constructor).copy(this, e)
                }
                copy(e, t = true) {
                    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
                        for (let t = 0; t < e.children.length; t++) {
                            const n = e.children[t];
                            this.add(n.clone())
                        }
                    return this
                }
            }
            Nt.DefaultUp = new Fe(0, 1, 0), Nt.DefaultMatrixAutoUpdate = true, Nt.prototype.isObject3D = true;
            const Ot = new Fe,
                Ht = new Fe,
                Ut = new Fe,
                Bt = new Fe,
                zt = new Fe,
                kt = new Fe,
                Gt = new Fe,
                Vt = new Fe,
                jt = new Fe,
                Wt = new Fe;
            class Xt {
                constructor(e = new Fe, t = new Fe, n = new Fe) {
                    this.a = e, this.b = t, this.c = n
                }
                static getNormal(e, t, n, i) {
                    i.subVectors(n, t), Ot.subVectors(e, t), i.cross(Ot);
                    const r = i.lengthSq();
                    return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
                }
                static getBarycoord(e, t, n, i, r) {
                    Ot.subVectors(i, t), Ht.subVectors(n, t), Ut.subVectors(e, t);
                    const a = Ot.dot(Ot),
                        s = Ot.dot(Ht),
                        o = Ot.dot(Ut),
                        l = Ht.dot(Ht),
                        c = Ht.dot(Ut),
                        u = a * l - s * s;
                    if (0 === u) return r.set(-2, -1, -1);
                    const h = 1 / u,
                        d = (l * o - s * c) * h,
                        p = (a * c - s * o) * h;
                    return r.set(1 - d - p, p, d)
                }
                static containsPoint(e, t, n, i) {
                    return this.getBarycoord(e, t, n, i, Bt), Bt.x >= 0 && Bt.y >= 0 && Bt.x + Bt.y <= 1
                }
                static getUV(e, t, n, i, r, a, s, o) {
                    return this.getBarycoord(e, t, n, i, Bt), o.set(0, 0), o.addScaledVector(r, Bt.x), o.addScaledVector(a, Bt.y), o.addScaledVector(s, Bt.z), o
                }
                static isFrontFacing(e, t, n, i) {
                    return Ot.subVectors(n, t), Ht.subVectors(e, t), Ot.cross(Ht).dot(i) < 0
                }
                set(e, t, n) {
                    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
                }
                setFromPointsAndIndices(e, t, n, i) {
                    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this
                }
                setFromAttributeAndIndices(e, t, n, i) {
                    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, i), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
                }
                getArea() {
                    return Ot.subVectors(this.c, this.b), Ht.subVectors(this.a, this.b), .5 * Ot.cross(Ht).length()
                }
                getMidpoint(e) {
                    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                }
                getNormal(e) {
                    return Xt.getNormal(this.a, this.b, this.c, e)
                }
                getPlane(e) {
                    return e.setFromCoplanarPoints(this.a, this.b, this.c)
                }
                getBarycoord(e, t) {
                    return Xt.getBarycoord(e, this.a, this.b, this.c, t)
                }
                getUV(e, t, n, i, r) {
                    return Xt.getUV(e, this.a, this.b, this.c, t, n, i, r)
                }
                containsPoint(e) {
                    return Xt.containsPoint(e, this.a, this.b, this.c)
                }
                isFrontFacing(e) {
                    return Xt.isFrontFacing(this.a, this.b, this.c, e)
                }
                intersectsBox(e) {
                    return e.intersectsTriangle(this)
                }
                closestPointToPoint(e, t) {
                    const n = this.a,
                        i = this.b,
                        r = this.c;
                    let a, s;
                    zt.subVectors(i, n), kt.subVectors(r, n), Vt.subVectors(e, n);
                    const o = zt.dot(Vt),
                        l = kt.dot(Vt);
                    if (o <= 0 && l <= 0) return t.copy(n);
                    jt.subVectors(e, i);
                    const c = zt.dot(jt),
                        u = kt.dot(jt);
                    if (c >= 0 && u <= c) return t.copy(i);
                    const h = o * u - c * l;
                    if (h <= 0 && o >= 0 && c <= 0) return a = o / (o - c), t.copy(n).addScaledVector(zt, a);
                    Wt.subVectors(e, r);
                    const d = zt.dot(Wt),
                        p = kt.dot(Wt);
                    if (p >= 0 && d <= p) return t.copy(r);
                    const f = d * l - o * p;
                    if (f <= 0 && l >= 0 && p <= 0) return s = l / (l - p), t.copy(n).addScaledVector(kt, s);
                    const m = c * p - d * u;
                    if (m <= 0 && u - c >= 0 && d - p >= 0) return Gt.subVectors(r, i), s = (u - c) / (u - c + (d - p)), t.copy(i).addScaledVector(Gt, s);
                    const g = 1 / (m + f + h);
                    return a = f * g, s = h * g, t.copy(n).addScaledVector(zt, a).addScaledVector(kt, s)
                }
                equals(e) {
                    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
                }
            }
            let Yt = 0;
            class qt extends ie {
                constructor() {
                    super(), Object.defineProperty(this, "id", {
                        value: Yt++
                    }), this.uuid = le(), this.name = "", this.type = "Material", this.fog = true, this.blending = 1, this.side = 0, this.vertexColors = false, this.opacity = 1, this.format = S, this.transparent = false, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = n, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = $, this.stencilZFail = $, this.stencilZPass = $, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0, this._alphaTest = 0
                }
                get alphaTest() {
                    return this._alphaTest
                }
                set alphaTest(e) {
                    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e
                }
                onBuild() {}
                onBeforeRender() {}
                onBeforeCompile() {}
                customProgramCacheKey() {
                    return this.onBeforeCompile.toString()
                }
                setValues(e) {
                    if (void 0 !== e)
                        for (const t in e) {
                            const n = e[t];
                            if (void 0 === n) {
                                console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                                continue
                            }
                            if ("shading" === t) {
                                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n;
                                continue
                            }
                            const i = this[t];
                            void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.")
                        }
                }
                toJSON(e) {
                    const t = void 0 === e || "string" == typeof e;
                    t && (e = {
                        textures: {},
                        images: {}
                    });
                    const n = {
                        metadata: {
                            version: 4.5,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };
                    function i(e) {
                        const t = [];
                        for (const n in e) {
                            const i = e[n];
                            delete i.metadata, t.push(i)
                        }
                        return t
                    }
                    if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), 0 !== this.side && (n.side = this.side), this.vertexColors && (n.vertexColors = true), this.opacity < 1 && (n.opacity = this.opacity), this.format !== S && (n.format = this.format), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = true), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = true), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = false), !1 === this.toneMapped && (n.toneMapped = false), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), t) {
                        const t = i(e.textures),
                            r = i(e.images);
                        t.length > 0 && (n.textures = t), r.length > 0 && (n.images = r)
                    }
                    return n
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    this.name = e.name, this.fog = e.fog, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.format = e.format, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
                    const t = e.clippingPlanes;
                    let n = null;
                    if (null !== t) {
                        const e = t.length;
                        n = new Array(e);
                        for (let i = 0; i !== e; ++i) n[i] = t[i].clone()
                    }
                    return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
            }
            qt.prototype.isMaterial = true;
            const Qt = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                },
                Jt = {
                    h: 0,
                    s: 0,
                    l: 0
                },
                Zt = {
                    h: 0,
                    s: 0,
                    l: 0
                };
            function Kt(e, t, n) {
                return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
            }
            function $t(e) {
                return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
            }
            function en(e) {
                return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
            }
            class tn {
                constructor(e, t, n) {
                    return void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n)
                }
                set(e) {
                    return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
                }
                setScalar(e) {
                    return this.r = e, this.g = e, this.b = e, this
                }
                setHex(e) {
                    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this
                }
                setRGB(e, t, n) {
                    return this.r = e, this.g = t, this.b = n, this
                }
                setHSL(e, t, n) {
                    if (e = ue(e, 1), t = ce(t, 0, 1), n = ce(n, 0, 1), 0 === t) this.r = this.g = this.b = n;
                    else {
                        const i = n <= .5 ? n * (1 + t) : n + t - n * t,
                            r = 2 * n - i;
                        this.r = Kt(r, i, e + 1 / 3), this.g = Kt(r, i, e), this.b = Kt(r, i, e - 1 / 3)
                    }
                    return this
                }
                setStyle(e) {
                    function t(t) {
                        void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
                    }
                    let n;
                    if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
                        let e;
                        const i = n[1],
                            r = n[2];
                        switch (i) {
                        case "rgb":
                        case "rgba":
                            if (e = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(255, parseInt(e[1], 10)) / 255, this.g = Math.min(255, parseInt(e[2], 10)) / 255, this.b = Math.min(255, parseInt(e[3], 10)) / 255, t(e[4]), this;
                            if (e = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(100, parseInt(e[1], 10)) / 100, this.g = Math.min(100, parseInt(e[2], 10)) / 100, this.b = Math.min(100, parseInt(e[3], 10)) / 100, t(e[4]), this;
                            break;
                        case "hsl":
                        case "hsla":
                            if (e = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) {
                                const n = parseFloat(e[1]) / 360,
                                    i = parseInt(e[2], 10) / 100,
                                    r = parseInt(e[3], 10) / 100;
                                return t(e[4]), this.setHSL(n, i, r)
                            }
                        }
                    } else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                        const e = n[1],
                            t = e.length;
                        if (3 === t) return this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255, this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255, this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255, this;
                        if (6 === t) return this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255, this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255, this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255, this
                    }
                    return e && e.length > 0 ? this.setColorName(e) : this
                }
                setColorName(e) {
                    const t = Qt[e.toLowerCase()];
                    return void 0 !== t ? this.setHex(t) : console.warn("THREE.Color: Unknown color " + e), this
                }
                clone() {
                    return new this.constructor(this.r, this.g, this.b)
                }
                copy(e) {
                    return this.r = e.r, this.g = e.g, this.b = e.b, this
                }
                copyGammaToLinear(e, t = 2) {
                    return this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this
                }
                copyLinearToGamma(e, t = 2) {
                    const n = t > 0 ? 1 / t : 1;
                    return this.r = Math.pow(e.r, n), this.g = Math.pow(e.g, n), this.b = Math.pow(e.b, n), this
                }
                convertGammaToLinear(e) {
                    return this.copyGammaToLinear(this, e), this
                }
                convertLinearToGamma(e) {
                    return this.copyLinearToGamma(this, e), this
                }
                copySRGBToLinear(e) {
                    return this.r = $t(e.r), this.g = $t(e.g), this.b = $t(e.b), this
                }
                copyLinearToSRGB(e) {
                    return this.r = en(e.r), this.g = en(e.g), this.b = en(e.b), this
                }
                convertSRGBToLinear() {
                    return this.copySRGBToLinear(this), this
                }
                convertLinearToSRGB() {
                    return this.copyLinearToSRGB(this), this
                }
                getHex() {
                    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
                }
                getHexString() {
                    return ("000000" + this.getHex().toString(16)).slice(-6)
                }
                getHSL(e) {
                    const t = this.r,
                        n = this.g,
                        i = this.b,
                        r = Math.max(t, n, i),
                        a = Math.min(t, n, i);
                    let s, o;
                    const l = (a + r) / 2;
                    if (a === r) s = 0, o = 0;
                    else {
                        const e = r - a;
                        switch (o = l <= .5 ? e / (r + a) : e / (2 - r - a), r) {
                        case t:
                            s = (n - i) / e + (n < i ? 6 : 0);
                            break;
                        case n:
                            s = (i - t) / e + 2;
                            break;
                        case i:
                            s = (t - n) / e + 4
                        }
                        s /= 6
                    }
                    return e.h = s, e.s = o, e.l = l, e
                }
                getStyle() {
                    return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                }
                offsetHSL(e, t, n) {
                    return this.getHSL(Jt), Jt.h += e, Jt.s += t, Jt.l += n, this.setHSL(Jt.h, Jt.s, Jt.l), this
                }
                add(e) {
                    return this.r += e.r, this.g += e.g, this.b += e.b, this
                }
                addColors(e, t) {
                    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
                }
                addScalar(e) {
                    return this.r += e, this.g += e, this.b += e, this
                }
                sub(e) {
                    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
                }
                multiply(e) {
                    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
                }
                multiplyScalar(e) {
                    return this.r *= e, this.g *= e, this.b *= e, this
                }
                lerp(e, t) {
                    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
                }
                lerpColors(e, t, n) {
                    return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this
                }
                lerpHSL(e, t) {
                    this.getHSL(Jt), e.getHSL(Zt);
                    const n = he(Jt.h, Zt.h, t),
                        i = he(Jt.s, Zt.s, t),
                        r = he(Jt.l, Zt.l, t);
                    return this.setHSL(n, i, r), this
                }
                equals(e) {
                    return e.r === this.r && e.g === this.g && e.b === this.b
                }
                fromArray(e, t = 0) {
                    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
                }
                toArray(e = [], t = 0) {
                    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
                }
                fromBufferAttribute(e, t) {
                    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), !0 === e.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
                }
                toJSON() {
                    return this.getHex()
                }
            }
            tn.NAMES = Qt, tn.prototype.isColor = true, tn.prototype.r = 1, tn.prototype.g = 1, tn.prototype.b = 1;
            class nn extends qt {
                constructor(e) {
                    super(), this.type = "MeshBasicMaterial", this.color = new tn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this
                }
            }
            nn.prototype.isMeshBasicMaterial = true;
            const rn = new Fe,
                an = new ge;
            class sn {
                constructor(e, t, n) {
                    if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === n, this.usage = ee, this.updateRange = {
                        offset: 0,
                        count: -1
                    }, this.version = 0
                }
                onUploadCallback() {}
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
                setUsage(e) {
                    return this.usage = e, this
                }
                copy(e) {
                    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this
                }
                copyAt(e, t, n) {
                    e *= this.itemSize, n *= t.itemSize;
                    for (let i = 0, r = this.itemSize; i < r; i++) this.array[e + i] = t.array[n + i];
                    return this
                }
                copyArray(e) {
                    return this.array.set(e), this
                }
                copyColorsArray(e) {
                    const t = this.array;
                    let n = 0;
                    for (let i = 0, r = e.length; i < r; i++) {
                        let r = e[i];
                        void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), r = new tn), t[n++] = r.r, t[n++] = r.g, t[n++] = r.b
                    }
                    return this
                }
                copyVector2sArray(e) {
                    const t = this.array;
                    let n = 0;
                    for (let i = 0, r = e.length; i < r; i++) {
                        let r = e[i];
                        void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), r = new ge), t[n++] = r.x, t[n++] = r.y
                    }
                    return this
                }
                copyVector3sArray(e) {
                    const t = this.array;
                    let n = 0;
                    for (let i = 0, r = e.length; i < r; i++) {
                        let r = e[i];
                        void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), r = new Fe), t[n++] = r.x, t[n++] = r.y, t[n++] = r.z
                    }
                    return this
                }
                copyVector4sArray(e) {
                    const t = this.array;
                    let n = 0;
                    for (let i = 0, r = e.length; i < r; i++) {
                        let r = e[i];
                        void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), r = new Le), t[n++] = r.x, t[n++] = r.y, t[n++] = r.z, t[n++] = r.w
                    }
                    return this
                }
                applyMatrix3(e) {
                    if (2 === this.itemSize)
                        for (let t = 0, n = this.count; t < n; t++) an.fromBufferAttribute(this, t), an.applyMatrix3(e), this.setXY(t, an.x, an.y);
                    else if (3 === this.itemSize)
                        for (let t = 0, n = this.count; t < n; t++) rn.fromBufferAttribute(this, t), rn.applyMatrix3(e), this.setXYZ(t, rn.x, rn.y, rn.z);
                    return this
                }
                applyMatrix4(e) {
                    for (let t = 0, n = this.count; t < n; t++) rn.x = this.getX(t), rn.y = this.getY(t), rn.z = this.getZ(t), rn.applyMatrix4(e), this.setXYZ(t, rn.x, rn.y, rn.z);
                    return this
                }
                applyNormalMatrix(e) {
                    for (let t = 0, n = this.count; t < n; t++) rn.x = this.getX(t), rn.y = this.getY(t), rn.z = this.getZ(t), rn.applyNormalMatrix(e), this.setXYZ(t, rn.x, rn.y, rn.z);
                    return this
                }
                transformDirection(e) {
                    for (let t = 0, n = this.count; t < n; t++) rn.x = this.getX(t), rn.y = this.getY(t), rn.z = this.getZ(t), rn.transformDirection(e), this.setXYZ(t, rn.x, rn.y, rn.z);
                    return this
                }
                set(e, t = 0) {
                    return this.array.set(e, t), this
                }
                getX(e) {
                    return this.array[e * this.itemSize]
                }
                setX(e, t) {
                    return this.array[e * this.itemSize] = t, this
                }
                getY(e) {
                    return this.array[e * this.itemSize + 1]
                }
                setY(e, t) {
                    return this.array[e * this.itemSize + 1] = t, this
                }
                getZ(e) {
                    return this.array[e * this.itemSize + 2]
                }
                setZ(e, t) {
                    return this.array[e * this.itemSize + 2] = t, this
                }
                getW(e) {
                    return this.array[e * this.itemSize + 3]
                }
                setW(e, t) {
                    return this.array[e * this.itemSize + 3] = t, this
                }
                setXY(e, t, n) {
                    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this
                }
                setXYZ(e, t, n, i) {
                    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this
                }
                setXYZW(e, t, n, i, r) {
                    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = r, this
                }
                onUpload(e) {
                    return this.onUploadCallback = e, this
                }
                clone() {
                    return new this.constructor(this.array, this.itemSize).copy(this)
                }
                toJSON() {
                    const e = {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: Array.prototype.slice.call(this.array),
                        normalized: this.normalized
                    };
                    return "" !== this.name && (e.name = this.name), this.usage !== ee && (e.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (e.updateRange = this.updateRange), e
                }
            }
            sn.prototype.isBufferAttribute = true;
            class on extends sn {
                constructor(e, t, n) {
                    super(new Int8Array(e), t, n)
                }
            }
            class ln extends sn {
                constructor(e, t, n) {
                    super(new Uint8Array(e), t, n)
                }
            }
            class cn extends sn {
                constructor(e, t, n) {
                    super(new Uint8ClampedArray(e), t, n)
                }
            }
            class un extends sn {
                constructor(e, t, n) {
                    super(new Int16Array(e), t, n)
                }
            }
            class hn extends sn {
                constructor(e, t, n) {
                    super(new Uint16Array(e), t, n)
                }
            }
            class dn extends sn {
                constructor(e, t, n) {
                    super(new Int32Array(e), t, n)
                }
            }
            class pn extends sn {
                constructor(e, t, n) {
                    super(new Uint32Array(e), t, n)
                }
            }
            class fn extends sn {
                constructor(e, t, n) {
                    super(new Uint16Array(e), t, n)
                }
            }
            fn.prototype.isFloat16BufferAttribute = true;
            class mn extends sn {
                constructor(e, t, n) {
                    super(new Float32Array(e), t, n)
                }
            }
            class gn extends sn {
                constructor(e, t, n) {
                    super(new Float64Array(e), t, n)
                }
            }
            let vn = 0;
            const yn = new ut,
                xn = new Nt,
                bn = new Fe,
                _n = new Oe,
                wn = new Oe,
                En = new Fe;
            class Mn extends ie {
                constructor() {
                    super(), Object.defineProperty(this, "id", {
                        value: vn++
                    }), this.uuid = le(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                        start: 0,
                        count: 1 / 0
                    }, this.userData = {}
                }
                getIndex() {
                    return this.index
                }
                setIndex(e) {
                    return Array.isArray(e) ? this.index = new(ye(e) > 65535 ? pn : hn)(e, 1) : this.index = e, this
                }
                getAttribute(e) {
                    return this.attributes[e]
                }
                setAttribute(e, t) {
                    return this.attributes[e] = t, this
                }
                deleteAttribute(e) {
                    return delete this.attributes[e], this
                }
                hasAttribute(e) {
                    return void 0 !== this.attributes[e]
                }
                addGroup(e, t, n = 0) {
                    this.groups.push({
                        start: e,
                        count: t,
                        materialIndex: n
                    })
                }
                clearGroups() {
                    this.groups = []
                }
                setDrawRange(e, t) {
                    this.drawRange.start = e, this.drawRange.count = t
                }
                applyMatrix4(e) {
                    const t = this.attributes.position;
                    void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = true);
                    const n = this.attributes.normal;
                    if (void 0 !== n) {
                        const t = (new ve).getNormalMatrix(e);
                        n.applyNormalMatrix(t), n.needsUpdate = true
                    }
                    const i = this.attributes.tangent;
                    return void 0 !== i && (i.transformDirection(e), i.needsUpdate = true), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                }
                applyQuaternion(e) {
                    return yn.makeRotationFromQuaternion(e), this.applyMatrix4(yn), this
                }
                rotateX(e) {
                    return yn.makeRotationX(e), this.applyMatrix4(yn), this
                }
                rotateY(e) {
                    return yn.makeRotationY(e), this.applyMatrix4(yn), this
                }
                rotateZ(e) {
                    return yn.makeRotationZ(e), this.applyMatrix4(yn), this
                }
                translate(e, t, n) {
                    return yn.makeTranslation(e, t, n), this.applyMatrix4(yn), this
                }
                scale(e, t, n) {
                    return yn.makeScale(e, t, n), this.applyMatrix4(yn), this
                }
                lookAt(e) {
                    return xn.lookAt(e), xn.updateMatrix(), this.applyMatrix4(xn.matrix), this
                }
                center() {
                    return this.computeBoundingBox(), this.boundingBox.getCenter(bn).negate(), this.translate(bn.x, bn.y, bn.z), this
                }
                setFromPoints(e) {
                    const t = [];
                    for (let n = 0, i = e.length; n < i; n++) {
                        const i = e[n];
                        t.push(i.x, i.y, i.z || 0)
                    }
                    return this.setAttribute("position", new mn(t, 3)), this
                }
                computeBoundingBox() {
                    null === this.boundingBox && (this.boundingBox = new Oe);
                    const e = this.attributes.position,
                        t = this.morphAttributes.position;
                    if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new Fe(-1 / 0, -1 / 0, -1 / 0), new Fe(1 / 0, 1 / 0, 1 / 0));
                    if (void 0 !== e) {
                        if (this.boundingBox.setFromBufferAttribute(e), t)
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e];
                                _n.setFromBufferAttribute(n), this.morphTargetsRelative ? (En.addVectors(this.boundingBox.min, _n.min), this.boundingBox.expandByPoint(En), En.addVectors(this.boundingBox.max, _n.max), this.boundingBox.expandByPoint(En)) : (this.boundingBox.expandByPoint(_n.min), this.boundingBox.expandByPoint(_n.max))
                            }
                    } else this.boundingBox.makeEmpty();
                    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                }
                computeBoundingSphere() {
                    null === this.boundingSphere && (this.boundingSphere = new tt);
                    const e = this.attributes.position,
                        t = this.morphAttributes.position;
                    if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new Fe, 1 / 0);
                    if (e) {
                        const n = this.boundingSphere.center;
                        if (_n.setFromBufferAttribute(e), t)
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e];
                                wn.setFromBufferAttribute(n), this.morphTargetsRelative ? (En.addVectors(_n.min, wn.min), _n.expandByPoint(En), En.addVectors(_n.max, wn.max), _n.expandByPoint(En)) : (_n.expandByPoint(wn.min), _n.expandByPoint(wn.max))
                            }
                        _n.getCenter(n);
                        let i = 0;
                        for (let t = 0, r = e.count; t < r; t++) En.fromBufferAttribute(e, t), i = Math.max(i, n.distanceToSquared(En));
                        if (t)
                            for (let r = 0, a = t.length; r < a; r++) {
                                const a = t[r],
                                    s = this.morphTargetsRelative;
                                for (let t = 0, r = a.count; t < r; t++) En.fromBufferAttribute(a, t), s && (bn.fromBufferAttribute(e, t), En.add(bn)), i = Math.max(i, n.distanceToSquared(En))
                            }
                        this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                    }
                }
                computeTangents() {
                    const e = this.index,
                        t = this.attributes;
                    if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                    const n = e.array,
                        i = t.position.array,
                        r = t.normal.array,
                        a = t.uv.array,
                        s = i.length / 3;
                    void 0 === t.tangent && this.setAttribute("tangent", new sn(new Float32Array(4 * s), 4));
                    const o = t.tangent.array,
                        l = [],
                        c = [];
                    for (let e = 0; e < s; e++) l[e] = new Fe, c[e] = new Fe;
                    const u = new Fe,
                        h = new Fe,
                        d = new Fe,
                        p = new ge,
                        f = new ge,
                        m = new ge,
                        g = new Fe,
                        v = new Fe;
                    function y(e, t, n) {
                        u.fromArray(i, 3 * e), h.fromArray(i, 3 * t), d.fromArray(i, 3 * n), p.fromArray(a, 2 * e), f.fromArray(a, 2 * t), m.fromArray(a, 2 * n), h.sub(u), d.sub(u), f.sub(p), m.sub(p);
                        const r = 1 / (f.x * m.y - m.x * f.y);
                        isFinite(r) && (g.copy(h).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(r), v.copy(d).multiplyScalar(f.x).addScaledVector(h, -m.x).multiplyScalar(r), l[e].add(g), l[t].add(g), l[n].add(g), c[e].add(v), c[t].add(v), c[n].add(v))
                    }
                    let x = this.groups;
                    0 === x.length && (x = [{
                        start: 0,
                        count: n.length
                    }]);
                    for (let e = 0, t = x.length; e < t; ++e) {
                        const t = x[e],
                            i = t.start;
                        for (let e = i, r = i + t.count; e < r; e += 3) y(n[e + 0], n[e + 1], n[e + 2])
                    }
                    const b = new Fe,
                        _ = new Fe,
                        w = new Fe,
                        E = new Fe;
                    function M(e) {
                        w.fromArray(r, 3 * e), E.copy(w);
                        const t = l[e];
                        b.copy(t), b.sub(w.multiplyScalar(w.dot(t))).normalize(), _.crossVectors(E, t);
                        const n = _.dot(c[e]) < 0 ? -1 : 1;
                        o[4 * e] = b.x, o[4 * e + 1] = b.y, o[4 * e + 2] = b.z, o[4 * e + 3] = n
                    }
                    for (let e = 0, t = x.length; e < t; ++e) {
                        const t = x[e],
                            i = t.start;
                        for (let e = i, r = i + t.count; e < r; e += 3) M(n[e + 0]), M(n[e + 1]), M(n[e + 2])
                    }
                }
                computeVertexNormals() {
                    const e = this.index,
                        t = this.getAttribute("position");
                    if (void 0 !== t) {
                        let n = this.getAttribute("normal");
                        if (void 0 === n) n = new sn(new Float32Array(3 * t.count), 3), this.setAttribute("normal", n);
                        else
                            for (let e = 0, t = n.count; e < t; e++) n.setXYZ(e, 0, 0, 0);
                        const i = new Fe,
                            r = new Fe,
                            a = new Fe,
                            s = new Fe,
                            o = new Fe,
                            l = new Fe,
                            c = new Fe,
                            u = new Fe;
                        if (e)
                            for (let h = 0, d = e.count; h < d; h += 3) {
                                const d = e.getX(h + 0),
                                    p = e.getX(h + 1),
                                    f = e.getX(h + 2);
                                i.fromBufferAttribute(t, d), r.fromBufferAttribute(t, p), a.fromBufferAttribute(t, f), c.subVectors(a, r), u.subVectors(i, r), c.cross(u), s.fromBufferAttribute(n, d), o.fromBufferAttribute(n, p), l.fromBufferAttribute(n, f), s.add(c), o.add(c), l.add(c), n.setXYZ(d, s.x, s.y, s.z), n.setXYZ(p, o.x, o.y, o.z), n.setXYZ(f, l.x, l.y, l.z)
                            } else
                                for (let e = 0, s = t.count; e < s; e += 3) i.fromBufferAttribute(t, e + 0), r.fromBufferAttribute(t, e + 1), a.fromBufferAttribute(t, e + 2), c.subVectors(a, r), u.subVectors(i, r), c.cross(u), n.setXYZ(e + 0, c.x, c.y, c.z), n.setXYZ(e + 1, c.x, c.y, c.z), n.setXYZ(e + 2, c.x, c.y, c.z);
                        this.normalizeNormals(), n.needsUpdate = true
                    }
                }
                merge(e, t) {
                    if (!e || !e.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e);
                    void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                    const n = this.attributes;
                    for (const i in n) {
                        if (void 0 === e.attributes[i]) continue;
                        const r = n[i].array,
                            a = e.attributes[i],
                            s = a.array,
                            o = a.itemSize * t,
                            l = Math.min(s.length, r.length - o);
                        for (let e = 0, t = o; e < l; e++, t++) r[t] = s[e]
                    }
                    return this
                }
                normalizeNormals() {
                    const e = this.attributes.normal;
                    for (let t = 0, n = e.count; t < n; t++) En.fromBufferAttribute(e, t), En.normalize(), e.setXYZ(t, En.x, En.y, En.z)
                }
                toNonIndexed() {
                    function e(e, t) {
                        const n = e.array,
                            i = e.itemSize,
                            r = e.normalized,
                            a = new n.constructor(t.length * i);
                        let s = 0,
                            o = 0;
                        for (let r = 0, l = t.length; r < l; r++) {
                            s = e.isInterleavedBufferAttribute ? t[r] * e.data.stride + e.offset : t[r] * i;
                            for (let e = 0; e < i; e++) a[o++] = n[s++]
                        }
                        return new sn(a, i, r)
                    }
                    if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                    const t = new Mn,
                        n = this.index.array,
                        i = this.attributes;
                    for (const r in i) {
                        const a = e(i[r], n);
                        t.setAttribute(r, a)
                    }
                    const r = this.morphAttributes;
                    for (const i in r) {
                        const a = [],
                            s = r[i];
                        for (let t = 0, i = s.length; t < i; t++) {
                            const i = e(s[t], n);
                            a.push(i)
                        }
                        t.morphAttributes[i] = a
                    }
                    t.morphTargetsRelative = this.morphTargetsRelative;
                    const a = this.groups;
                    for (let e = 0, n = a.length; e < n; e++) {
                        const n = a[e];
                        t.addGroup(n.start, n.count, n.materialIndex)
                    }
                    return t
                }
                toJSON() {
                    const e = {
                        metadata: {
                            version: 4.5,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) {
                        const t = this.parameters;
                        for (const n in t) void 0 !== t[n] && (e[n] = t[n]);
                        return e
                    }
                    e.data = {
                        attributes: {}
                    };
                    const t = this.index;
                    null !== t && (e.data.index = {
                        type: t.array.constructor.name,
                        array: Array.prototype.slice.call(t.array)
                    });
                    const n = this.attributes;
                    for (const t in n) {
                        const i = n[t];
                        e.data.attributes[t] = i.toJSON(e.data)
                    }
                    const i = {};
                    let r = false;
                    for (const t in this.morphAttributes) {
                        const n = this.morphAttributes[t],
                            a = [];
                        for (let t = 0, i = n.length; t < i; t++) {
                            const i = n[t];
                            a.push(i.toJSON(e.data))
                        }
                        a.length > 0 && (i[t] = a, r = true)
                    }
                    r && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
                    const a = this.groups;
                    a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
                    const s = this.boundingSphere;
                    return null !== s && (e.data.boundingSphere = {
                        center: s.center.toArray(),
                        radius: s.radius
                    }), e
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                    const t = {};
                    this.name = e.name;
                    const n = e.index;
                    null !== n && this.setIndex(n.clone(t));
                    const i = e.attributes;
                    for (const e in i) {
                        const n = i[e];
                        this.setAttribute(e, n.clone(t))
                    }
                    const r = e.morphAttributes;
                    for (const e in r) {
                        const n = [],
                            i = r[e];
                        for (let e = 0, r = i.length; e < r; e++) n.push(i[e].clone(t));
                        this.morphAttributes[e] = n
                    }
                    this.morphTargetsRelative = e.morphTargetsRelative;
                    const a = e.groups;
                    for (let e = 0, t = a.length; e < t; e++) {
                        const t = a[e];
                        this.addGroup(t.start, t.count, t.materialIndex)
                    }
                    const s = e.boundingBox;
                    null !== s && (this.boundingBox = s.clone());
                    const o = e.boundingSphere;
                    return null !== o && (this.boundingSphere = o.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, void 0 !== e.parameters && (this.parameters = Object.assign({}, e.parameters)), this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            Mn.prototype.isBufferGeometry = true;
            const Tn = new ut,
                Sn = new ct,
                An = new tt,
                Ln = new Fe,
                Rn = new Fe,
                Pn = new Fe,
                Cn = new Fe,
                In = new Fe,
                Fn = new Fe,
                Dn = new Fe,
                Nn = new Fe,
                On = new Fe,
                Hn = new ge,
                Un = new ge,
                Bn = new ge,
                zn = new Fe,
                kn = new Fe;
            class Gn extends Nt {
                constructor(e = new Mn, t = new nn) {
                    super(), this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets()
                }
                copy(e) {
                    return super.copy(e), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this
                }
                updateMorphTargets() {
                    const e = this.geometry;
                    if (e.isBufferGeometry) {
                        const t = e.morphAttributes,
                            n = Object.keys(t);
                        if (n.length > 0) {
                            const e = t[n[0]];
                            if (void 0 !== e) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (let t = 0, n = e.length; t < n; t++) {
                                    const n = e[t].name || String(t);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
                                }
                            }
                        }
                    } else {
                        const t = e.morphTargets;
                        void 0 !== t && t.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                }
                raycast(e, t) {
                    const n = this.geometry,
                        i = this.material,
                        r = this.matrixWorld;
                    if (void 0 === i) return;
                    if (null === n.boundingSphere && n.computeBoundingSphere(), An.copy(n.boundingSphere), An.applyMatrix4(r), !1 === e.ray.intersectsSphere(An)) return;
                    if (Tn.copy(r).invert(), Sn.copy(e.ray).applyMatrix4(Tn), null !== n.boundingBox && !1 === Sn.intersectsBox(n.boundingBox)) return;
                    let a;
                    if (n.isBufferGeometry) {
                        const r = n.index,
                            s = n.attributes.position,
                            o = n.morphAttributes.position,
                            l = n.morphTargetsRelative,
                            c = n.attributes.uv,
                            u = n.attributes.uv2,
                            h = n.groups,
                            d = n.drawRange;
                        if (null !== r)
                            if (Array.isArray(i))
                                for (let n = 0, p = h.length; n < p; n++) {
                                    const p = h[n],
                                        f = i[p.materialIndex];
                                    for (let n = Math.max(p.start, d.start), i = Math.min(r.count, Math.min(p.start + p.count, d.start + d.count)); n < i; n += 3) {
                                        const i = r.getX(n),
                                            h = r.getX(n + 1),
                                            d = r.getX(n + 2);
                                        a = Vn(this, f, e, Sn, s, o, l, c, u, i, h, d), a && (a.faceIndex = Math.floor(n / 3), a.face.materialIndex = p.materialIndex, t.push(a))
                                    }
                                } else
                                    for (let n = Math.max(0, d.start), h = Math.min(r.count, d.start + d.count); n < h; n += 3) {
                                        const h = r.getX(n),
                                            d = r.getX(n + 1),
                                            p = r.getX(n + 2);
                                        a = Vn(this, i, e, Sn, s, o, l, c, u, h, d, p), a && (a.faceIndex = Math.floor(n / 3), t.push(a))
                                    } else if (void 0 !== s)
                                        if (Array.isArray(i))
                                            for (let n = 0, r = h.length; n < r; n++) {
                                                const r = h[n],
                                                    p = i[r.materialIndex];
                                                for (let n = Math.max(r.start, d.start), i = Math.min(s.count, Math.min(r.start + r.count, d.start + d.count)); n < i; n += 3) a = Vn(this, p, e, Sn, s, o, l, c, u, n, n + 1, n + 2), a && (a.faceIndex = Math.floor(n / 3), a.face.materialIndex = r.materialIndex, t.push(a))
                                            } else
                                                for (let n = Math.max(0, d.start), r = Math.min(s.count, d.start + d.count); n < r; n += 3) a = Vn(this, i, e, Sn, s, o, l, c, u, n, n + 1, n + 2), a && (a.faceIndex = Math.floor(n / 3), t.push(a))
                    } else n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }
            function Vn(e, t, n, i, r, a, s, o, l, c, u, h) {
                Ln.fromBufferAttribute(r, c), Rn.fromBufferAttribute(r, u), Pn.fromBufferAttribute(r, h);
                const d = e.morphTargetInfluences;
                if (a && d) {
                    Dn.set(0, 0, 0), Nn.set(0, 0, 0), On.set(0, 0, 0);
                    for (let e = 0, t = a.length; e < t; e++) {
                        const t = d[e],
                            n = a[e];
                        0 !== t && (Cn.fromBufferAttribute(n, c), In.fromBufferAttribute(n, u), Fn.fromBufferAttribute(n, h), s ? (Dn.addScaledVector(Cn, t), Nn.addScaledVector(In, t), On.addScaledVector(Fn, t)) : (Dn.addScaledVector(Cn.sub(Ln), t), Nn.addScaledVector(In.sub(Rn), t), On.addScaledVector(Fn.sub(Pn), t)))
                    }
                    Ln.add(Dn), Rn.add(Nn), Pn.add(On)
                }
                e.isSkinnedMesh && (e.boneTransform(c, Ln), e.boneTransform(u, Rn), e.boneTransform(h, Pn));
                const p = function (e, t, n, i, r, a, s, o) {
                    let l;
                    if (l = 1 === t.side ? i.intersectTriangle(s, a, r, true, o) : i.intersectTriangle(r, a, s, 2 !== t.side, o), null === l) return null;
                    kn.copy(o), kn.applyMatrix4(e.matrixWorld);
                    const c = n.ray.origin.distanceTo(kn);
                    return c < n.near || c > n.far ? null : {
                        distance: c,
                        point: kn.clone(),
                        object: e
                    }
                }(e, t, n, i, Ln, Rn, Pn, zn);
                if (p) {
                    o && (Hn.fromBufferAttribute(o, c), Un.fromBufferAttribute(o, u), Bn.fromBufferAttribute(o, h), p.uv = Xt.getUV(zn, Ln, Rn, Pn, Hn, Un, Bn, new ge)), l && (Hn.fromBufferAttribute(l, c), Un.fromBufferAttribute(l, u), Bn.fromBufferAttribute(l, h), p.uv2 = Xt.getUV(zn, Ln, Rn, Pn, Hn, Un, Bn, new ge));
                    const e = {
                        a: c,
                        b: u,
                        c: h,
                        normal: new Fe,
                        materialIndex: 0
                    };
                    Xt.getNormal(Ln, Rn, Pn, e.normal), p.face = e
                }
                return p
            }
            Gn.prototype.isMesh = true;
            class jn extends Mn {
                constructor(e = 1, t = 1, n = 1, i = 1, r = 1, a = 1) {
                    super(), this.type = "BoxGeometry", this.parameters = {
                        width: e,
                        height: t,
                        depth: n,
                        widthSegments: i,
                        heightSegments: r,
                        depthSegments: a
                    };
                    const s = this;
                    i = Math.floor(i), r = Math.floor(r), a = Math.floor(a);
                    const o = [],
                        l = [],
                        c = [],
                        u = [];
                    let h = 0,
                        d = 0;
                    function p(e, t, n, i, r, a, p, f, m, g, v) {
                        const y = a / m,
                            x = p / g,
                            b = a / 2,
                            _ = p / 2,
                            w = f / 2,
                            E = m + 1,
                            M = g + 1;
                        let T = 0,
                            S = 0;
                        const A = new Fe;
                        for (let a = 0; a < M; a++) {
                            const s = a * x - _;
                            for (let o = 0; o < E; o++) {
                                const h = o * y - b;
                                A[e] = h * i, A[t] = s * r, A[n] = w, l.push(A.x, A.y, A.z), A[e] = 0, A[t] = 0, A[n] = f > 0 ? 1 : -1, c.push(A.x, A.y, A.z), u.push(o / m), u.push(1 - a / g), T += 1
                            }
                        }
                        for (let e = 0; e < g; e++)
                            for (let t = 0; t < m; t++) {
                                const n = h + t + E * e,
                                    i = h + t + E * (e + 1),
                                    r = h + (t + 1) + E * (e + 1),
                                    a = h + (t + 1) + E * e;
                                o.push(n, i, a), o.push(i, r, a), S += 6
                            }
                        s.addGroup(d, S, v), d += S, h += T
                    }
                    p("z", "y", "x", -1, -1, n, t, e, a, r, 0), p("z", "y", "x", 1, -1, n, t, -e, a, r, 1), p("x", "z", "y", 1, 1, e, n, t, i, a, 2), p("x", "z", "y", 1, -1, e, n, -t, i, a, 3), p("x", "y", "z", 1, -1, e, t, n, i, r, 4), p("x", "y", "z", -1, -1, e, t, -n, i, r, 5), this.setIndex(o), this.setAttribute("position", new mn(l, 3)), this.setAttribute("normal", new mn(c, 3)), this.setAttribute("uv", new mn(u, 2))
                }
                static fromJSON(e) {
                    return new jn(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
                }
            }
            function Wn(e) {
                const t = {};
                for (const n in e) {
                    t[n] = {};
                    for (const i in e[n]) {
                        const r = e[n][i];
                        r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? t[n][i] = r.clone() : Array.isArray(r) ? t[n][i] = r.slice() : t[n][i] = r
                    }
                }
                return t
            }
            function Xn(e) {
                const t = {};
                for (let n = 0; n < e.length; n++) {
                    const i = Wn(e[n]);
                    for (const e in i) t[e] = i[e]
                }
                return t
            }
            const Yn = {
                clone: Wn,
                merge: Xn
            };
            class qn extends qt {
                constructor(e) {
                    super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.extensions = {
                        derivatives: false,
                        fragDepth: false,
                        drawBuffers: false,
                        shaderTextureLOD: false
                    }, this.defaultAttributeValues = {
                        color: [1, 1, 1],
                        uv: [0, 0],
                        uv2: [0, 0]
                    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e))
                }
                copy(e) {
                    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Wn(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    t.glslVersion = this.glslVersion, t.uniforms = {};
                    for (const n in this.uniforms) {
                        const i = this.uniforms[n].value;
                        i && i.isTexture ? t.uniforms[n] = {
                            type: "t",
                            value: i.toJSON(e).uuid
                        } : i && i.isColor ? t.uniforms[n] = {
                            type: "c",
                            value: i.getHex()
                        } : i && i.isVector2 ? t.uniforms[n] = {
                            type: "v2",
                            value: i.toArray()
                        } : i && i.isVector3 ? t.uniforms[n] = {
                            type: "v3",
                            value: i.toArray()
                        } : i && i.isVector4 ? t.uniforms[n] = {
                            type: "v4",
                            value: i.toArray()
                        } : i && i.isMatrix3 ? t.uniforms[n] = {
                            type: "m3",
                            value: i.toArray()
                        } : i && i.isMatrix4 ? t.uniforms[n] = {
                            type: "m4",
                            value: i.toArray()
                        } : t.uniforms[n] = {
                            value: i
                        }
                    }
                    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
                    const n = {};
                    for (const e in this.extensions) !0 === this.extensions[e] && (n[e] = true);
                    return Object.keys(n).length > 0 && (t.extensions = n), t
                }
            }
            qn.prototype.isShaderMaterial = true;
            class Qn extends Nt {
                constructor() {
                    super(), this.type = "Camera", this.matrixWorldInverse = new ut, this.projectionMatrix = new ut, this.projectionMatrixInverse = new ut
                }
                copy(e, t) {
                    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this
                }
                getWorldDirection(e) {
                    this.updateWorldMatrix(true, false);
                    const t = this.matrixWorld.elements;
                    return e.set(-t[8], -t[9], -t[10]).normalize()
                }
                updateMatrixWorld(e) {
                    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                }
                updateWorldMatrix(e, t) {
                    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            Qn.prototype.isCamera = true;
            class Jn extends Qn {
                constructor(e = 50, t = 1, n = .1, i = 2e3) {
                    super(), this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
                }
                copy(e, t) {
                    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
                }
                setFocalLength(e) {
                    const t = .5 * this.getFilmHeight() / e;
                    this.fov = 2 * oe * Math.atan(t), this.updateProjectionMatrix()
                }
                getFocalLength() {
                    const e = Math.tan(.5 * se * this.fov);
                    return .5 * this.getFilmHeight() / e
                }
                getEffectiveFOV() {
                    return 2 * oe * Math.atan(Math.tan(.5 * se * this.fov) / this.zoom)
                }
                getFilmWidth() {
                    return this.filmGauge * Math.min(this.aspect, 1)
                }
                getFilmHeight() {
                    return this.filmGauge / Math.max(this.aspect, 1)
                }
                setViewOffset(e, t, n, i, r, a) {
                    this.aspect = e / t, null === this.view && (this.view = {
                        enabled: true,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = true, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
                }
                clearViewOffset() {
                    null !== this.view && (this.view.enabled = false), this.updateProjectionMatrix()
                }
                updateProjectionMatrix() {
                    const e = this.near;
                    let t = e * Math.tan(.5 * se * this.fov) / this.zoom,
                        n = 2 * t,
                        i = this.aspect * n,
                        r = -.5 * i;
                    const a = this.view;
                    if (null !== this.view && this.view.enabled) {
                        const e = a.fullWidth,
                            s = a.fullHeight;
                        r += a.offsetX * i / e, t -= a.offsetY * n / s, i *= a.width / e, n *= a.height / s
                    }
                    const s = this.filmOffset;
                    0 !== s && (r += e * s / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
                }
            }
            Jn.prototype.isPerspectiveCamera = true;
            const Zn = 90;
            class Kn extends Nt {
                constructor(e, t, n) {
                    if (super(), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
                    this.renderTarget = n;
                    const i = new Jn(Zn, 1, e, t);
                    i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new Fe(1, 0, 0)), this.add(i);
                    const r = new Jn(Zn, 1, e, t);
                    r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new Fe(-1, 0, 0)), this.add(r);
                    const a = new Jn(Zn, 1, e, t);
                    a.layers = this.layers, a.up.set(0, 0, 1), a.lookAt(new Fe(0, 1, 0)), this.add(a);
                    const s = new Jn(Zn, 1, e, t);
                    s.layers = this.layers, s.up.set(0, 0, -1), s.lookAt(new Fe(0, -1, 0)), this.add(s);
                    const o = new Jn(Zn, 1, e, t);
                    o.layers = this.layers, o.up.set(0, -1, 0), o.lookAt(new Fe(0, 0, 1)), this.add(o);
                    const l = new Jn(Zn, 1, e, t);
                    l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new Fe(0, 0, -1)), this.add(l)
                }
                update(e, t) {
                    null === this.parent && this.updateMatrixWorld();
                    const n = this.renderTarget,
                        [i, r, a, s, o, l] = this.children,
                        c = e.xr.enabled,
                        u = e.getRenderTarget();
                    e.xr.enabled = false;
                    const h = n.texture.generateMipmaps;
                    n.texture.generateMipmaps = false, e.setRenderTarget(n, 0), e.render(t, i), e.setRenderTarget(n, 1), e.render(t, r), e.setRenderTarget(n, 2), e.render(t, a), e.setRenderTarget(n, 3), e.render(t, s), e.setRenderTarget(n, 4), e.render(t, o), n.texture.generateMipmaps = h, e.setRenderTarget(n, 5), e.render(t, l), e.setRenderTarget(u), e.xr.enabled = c
                }
            }
            class $n extends Se {
                constructor(e, t, n, i, a, s, o, l, c, u) {
                    super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : r, n, i, a, s, o, l, c, u), this.flipY = false
                }
                get images() {
                    return this.image
                }
                set images(e) {
                    this.image = e
                }
            }
            $n.prototype.isCubeTexture = true;
            class ei extends Re {
                constructor(e, t, n) {
                    Number.isInteger(t) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), t = n), super(e, e, t), t = t || {}, this.texture = new $n(void 0, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = true, this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps, this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : g, this.texture._needsFlipEnvMap = false
                }
                fromEquirectangularTexture(e, t) {
                    this.texture.type = t.type, this.texture.format = S, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
                    const n = {
                            tEquirect: {
                                value: null
                            }
                        },
                        i = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                        r = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
                        a = new jn(5, 5, 5),
                        s = new qn({
                            name: "CubemapFromEquirect",
                            uniforms: Wn(n),
                            vertexShader: i,
                            fragmentShader: r,
                            side: 1,
                            blending: 0
                        });
                    s.uniforms.tEquirect.value = t;
                    const o = new Gn(a, s),
                        l = t.minFilter;
                    return t.minFilter === y && (t.minFilter = g), new Kn(1, 10, this).update(e, o), t.minFilter = l, o.geometry.dispose(), o.material.dispose(), this
                }
                clear(e, t, n, i) {
                    const r = e.getRenderTarget();
                    for (let r = 0; r < 6; r++) e.setRenderTarget(this, r), e.clear(t, n, i);
                    e.setRenderTarget(r)
                }
            }
            ei.prototype.isWebGLCubeRenderTarget = true;
            const ti = new Fe,
                ni = new Fe,
                ii = new ve;
            class ri {
                constructor(e = new Fe(1, 0, 0), t = 0) {
                    this.normal = e, this.constant = t
                }
                set(e, t) {
                    return this.normal.copy(e), this.constant = t, this
                }
                setComponents(e, t, n, i) {
                    return this.normal.set(e, t, n), this.constant = i, this
                }
                setFromNormalAndCoplanarPoint(e, t) {
                    return this.normal.copy(e), this.constant = -t.dot(this.normal), this
                }
                setFromCoplanarPoints(e, t, n) {
                    const i = ti.subVectors(n, t).cross(ni.subVectors(e, t)).normalize();
                    return this.setFromNormalAndCoplanarPoint(i, e), this
                }
                copy(e) {
                    return this.normal.copy(e.normal), this.constant = e.constant, this
                }
                normalize() {
                    const e = 1 / this.normal.length();
                    return this.normal.multiplyScalar(e), this.constant *= e, this
                }
                negate() {
                    return this.constant *= -1, this.normal.negate(), this
                }
                distanceToPoint(e) {
                    return this.normal.dot(e) + this.constant
                }
                distanceToSphere(e) {
                    return this.distanceToPoint(e.center) - e.radius
                }
                projectPoint(e, t) {
                    return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
                }
                intersectLine(e, t) {
                    const n = e.delta(ti),
                        i = this.normal.dot(n);
                    if (0 === i) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
                    const r = -(e.start.dot(this.normal) + this.constant) / i;
                    return r < 0 || r > 1 ? null : t.copy(n).multiplyScalar(r).add(e.start)
                }
                intersectsLine(e) {
                    const t = this.distanceToPoint(e.start),
                        n = this.distanceToPoint(e.end);
                    return t < 0 && n > 0 || n < 0 && t > 0
                }
                intersectsBox(e) {
                    return e.intersectsPlane(this)
                }
                intersectsSphere(e) {
                    return e.intersectsPlane(this)
                }
                coplanarPoint(e) {
                    return e.copy(this.normal).multiplyScalar(-this.constant)
                }
                applyMatrix4(e, t) {
                    const n = t || ii.getNormalMatrix(e),
                        i = this.coplanarPoint(ti).applyMatrix4(e),
                        r = this.normal.applyMatrix3(n).normalize();
                    return this.constant = -i.dot(r), this
                }
                translate(e) {
                    return this.constant -= e.dot(this.normal), this
                }
                equals(e) {
                    return e.normal.equals(this.normal) && e.constant === this.constant
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            ri.prototype.isPlane = true;
            const ai = new tt,
                si = new Fe;
            class oi {
                constructor(e = new ri, t = new ri, n = new ri, i = new ri, r = new ri, a = new ri) {
                    this.planes = [e, t, n, i, r, a]
                }
                set(e, t, n, i, r, a) {
                    const s = this.planes;
                    return s[0].copy(e), s[1].copy(t), s[2].copy(n), s[3].copy(i), s[4].copy(r), s[5].copy(a), this
                }
                copy(e) {
                    const t = this.planes;
                    for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
                    return this
                }
                setFromProjectionMatrix(e) {
                    const t = this.planes,
                        n = e.elements,
                        i = n[0],
                        r = n[1],
                        a = n[2],
                        s = n[3],
                        o = n[4],
                        l = n[5],
                        c = n[6],
                        u = n[7],
                        h = n[8],
                        d = n[9],
                        p = n[10],
                        f = n[11],
                        m = n[12],
                        g = n[13],
                        v = n[14],
                        y = n[15];
                    return t[0].setComponents(s - i, u - o, f - h, y - m).normalize(), t[1].setComponents(s + i, u + o, f + h, y + m).normalize(), t[2].setComponents(s + r, u + l, f + d, y + g).normalize(), t[3].setComponents(s - r, u - l, f - d, y - g).normalize(), t[4].setComponents(s - a, u - c, f - p, y - v).normalize(), t[5].setComponents(s + a, u + c, f + p, y + v).normalize(), this
                }
                intersectsObject(e) {
                    const t = e.geometry;
                    return null === t.boundingSphere && t.computeBoundingSphere(), ai.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(ai)
                }
                intersectsSprite(e) {
                    return ai.center.set(0, 0, 0), ai.radius = .7071067811865476, ai.applyMatrix4(e.matrixWorld), this.intersectsSphere(ai)
                }
                intersectsSphere(e) {
                    const t = this.planes,
                        n = e.center,
                        i = -e.radius;
                    for (let e = 0; e < 6; e++)
                        if (t[e].distanceToPoint(n) < i) return false;
                    return true
                }
                intersectsBox(e) {
                    const t = this.planes;
                    for (let n = 0; n < 6; n++) {
                        const i = t[n];
                        if (si.x = i.normal.x > 0 ? e.max.x : e.min.x, si.y = i.normal.y > 0 ? e.max.y : e.min.y, si.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(si) < 0) return false
                    }
                    return true
                }
                containsPoint(e) {
                    const t = this.planes;
                    for (let n = 0; n < 6; n++)
                        if (t[n].distanceToPoint(e) < 0) return false;
                    return true
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            function li() {
                let e = null,
                    t = false,
                    n = null,
                    i = null;
                function r(t, a) {
                    n(t, a), i = e.requestAnimationFrame(r)
                }
                return {
                    start: function () {
                        !0 !== t && null !== n && (i = e.requestAnimationFrame(r), t = true)
                    },
                    stop: function () {
                        e.cancelAnimationFrame(i), t = false
                    },
                    setAnimationLoop: function (e) {
                        n = e
                    },
                    setContext: function (t) {
                        e = t
                    }
                }
            }
            function ci(e, t) {
                const n = t.isWebGL2,
                    i = new WeakMap;
                return {
                    get: function (e) {
                        return e.isInterleavedBufferAttribute && (e = e.data), i.get(e)
                    },
                    remove: function (t) {
                        t.isInterleavedBufferAttribute && (t = t.data);
                        const n = i.get(t);
                        n && (e.deleteBuffer(n.buffer), i.delete(t))
                    },
                    update: function (t, r) {
                        if (t.isGLBufferAttribute) {
                            const e = i.get(t);
                            return void((!e || e.version < t.version) && i.set(t, {
                                buffer: t.buffer,
                                type: t.type,
                                bytesPerElement: t.elementSize,
                                version: t.version
                            }))
                        }
                        t.isInterleavedBufferAttribute && (t = t.data);
                        const a = i.get(t);
                        void 0 === a ? i.set(t, function (t, i) {
                            const r = t.array,
                                a = t.usage,
                                s = e.createBuffer();
                            e.bindBuffer(i, s), e.bufferData(i, r, a), t.onUploadCallback();
                            let o = 5126;
                            return r instanceof Float32Array ? o = 5126 : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? t.isFloat16BufferAttribute ? n ? o = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : o = 5123 : r instanceof Int16Array ? o = 5122 : r instanceof Uint32Array ? o = 5125 : r instanceof Int32Array ? o = 5124 : r instanceof Int8Array ? o = 5120 : (r instanceof Uint8Array || r instanceof Uint8ClampedArray) && (o = 5121), {
                                buffer: s,
                                type: o,
                                bytesPerElement: r.BYTES_PER_ELEMENT,
                                version: t.version
                            }
                        }(t, r)) : a.version < t.version && (function (t, i, r) {
                            const a = i.array,
                                s = i.updateRange;
                            e.bindBuffer(r, t), -1 === s.count ? e.bufferSubData(r, 0, a) : (n ? e.bufferSubData(r, s.offset * a.BYTES_PER_ELEMENT, a, s.offset, s.count) : e.bufferSubData(r, s.offset * a.BYTES_PER_ELEMENT, a.subarray(s.offset, s.offset + s.count)), s.count = -1)
                        }(a.buffer, t, r), a.version = t.version)
                    }
                }
            }
            class ui extends Mn {
                constructor(e = 1, t = 1, n = 1, i = 1) {
                    super(), this.type = "PlaneGeometry", this.parameters = {
                        width: e,
                        height: t,
                        widthSegments: n,
                        heightSegments: i
                    };
                    const r = e / 2,
                        a = t / 2,
                        s = Math.floor(n),
                        o = Math.floor(i),
                        l = s + 1,
                        c = o + 1,
                        u = e / s,
                        h = t / o,
                        d = [],
                        p = [],
                        f = [],
                        m = [];
                    for (let e = 0; e < c; e++) {
                        const t = e * h - a;
                        for (let n = 0; n < l; n++) {
                            const i = n * u - r;
                            p.push(i, -t, 0), f.push(0, 0, 1), m.push(n / s), m.push(1 - e / o)
                        }
                    }
                    for (let e = 0; e < o; e++)
                        for (let t = 0; t < s; t++) {
                            const n = t + l * e,
                                i = t + l * (e + 1),
                                r = t + 1 + l * (e + 1),
                                a = t + 1 + l * e;
                            d.push(n, i, a), d.push(i, r, a)
                        }
                    this.setIndex(d), this.setAttribute("position", new mn(p, 3)), this.setAttribute("normal", new mn(f, 3)), this.setAttribute("uv", new mn(m, 2))
                }
                static fromJSON(e) {
                    return new ui(e.width, e.height, e.widthSegments, e.heightSegments)
                }
            }
            const hi = {
                    alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                    alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                    alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
                    alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
                    aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
                    aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                    begin_vertex: "vec3 transformed = vec3( position );",
                    beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                    bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",
                    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                    clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                    clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                    clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                    clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                    color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
                    color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
                    color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                    color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
                    common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
                    cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                    defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                    displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                    displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
                    emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                    emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                    encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                    encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}",
                    envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                    envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                    envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                    envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                    envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
                    envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                    fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
                    fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
                    fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                    fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                    gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
                    lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
                    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                    lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
                    lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
                    lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                    lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
                    lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                    lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
                    lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",
                    lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(\t\t0, 1,\t\t0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                    lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                    lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
                    lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
                    logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                    logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                    logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                    logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                    map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
                    map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                    map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                    map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                    metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                    metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
                    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
                    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\t#ifndef USE_MORPHNORMALS\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\t\t\t#else\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\t\t\t#endif\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
                    normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
                    normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
                    normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                    normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                    normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
                    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
                    clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
                    clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
                    clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
                    output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
                    packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                    premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                    project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                    dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                    dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                    roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                    roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                    shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t\tf.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t\tf.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                    shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                    shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
                    shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                    skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                    skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
                    skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                    skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                    tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                    tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(\t1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,\t1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,\t1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                    transmission_fragment: "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",
                    transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( float roughness, float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
                    uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
                    uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
                    uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                    uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                    uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
                    uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
                    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                    background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                    background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                    cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                    depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
                    distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                    distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                    equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                    equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                    linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                    meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                    meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                    meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
                    meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
                    meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                    points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                    shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                    sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"
                },
                di = {
                    common: {
                        diffuse: {
                            value: new tn(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new ve
                        },
                        uv2Transform: {
                            value: new ve
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaTest: {
                            value: 0
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        ior: {
                            value: 1.5
                        },
                        refractionRatio: {
                            value: .98
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalScale: {
                            value: new ge(1, 1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new tn(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        lightProbe: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {}
                            }
                        },
                        directionalLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {}
                            }
                        },
                        spotLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotShadowMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {}
                            }
                        },
                        pointLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        },
                        ltc_1: {
                            value: null
                        },
                        ltc_2: {
                            value: null
                        }
                    },
                    points: {
                        diffuse: {
                            value: new tn(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaTest: {
                            value: 0
                        },
                        uvTransform: {
                            value: new ve
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new tn(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        center: {
                            value: new ge(.5, .5)
                        },
                        rotation: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaTest: {
                            value: 0
                        },
                        uvTransform: {
                            value: new ve
                        }
                    }
                },
                pi = {
                    basic: {
                        uniforms: Xn([di.common, di.specularmap, di.envmap, di.aomap, di.lightmap, di.fog]),
                        vertexShader: hi.meshbasic_vert,
                        fragmentShader: hi.meshbasic_frag
                    },
                    lambert: {
                        uniforms: Xn([di.common, di.specularmap, di.envmap, di.aomap, di.lightmap, di.emissivemap, di.fog, di.lights, {
                            emissive: {
                                value: new tn(0)
                            }
                        }]),
                        vertexShader: hi.meshlambert_vert,
                        fragmentShader: hi.meshlambert_frag
                    },
                    phong: {
                        uniforms: Xn([di.common, di.specularmap, di.envmap, di.aomap, di.lightmap, di.emissivemap, di.bumpmap, di.normalmap, di.displacementmap, di.fog, di.lights, {
                            emissive: {
                                value: new tn(0)
                            },
                            specular: {
                                value: new tn(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: hi.meshphong_vert,
                        fragmentShader: hi.meshphong_frag
                    },
                    standard: {
                        uniforms: Xn([di.common, di.envmap, di.aomap, di.lightmap, di.emissivemap, di.bumpmap, di.normalmap, di.displacementmap, di.roughnessmap, di.metalnessmap, di.fog, di.lights, {
                            emissive: {
                                value: new tn(0)
                            },
                            roughness: {
                                value: 1
                            },
                            metalness: {
                                value: 0
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: hi.meshphysical_vert,
                        fragmentShader: hi.meshphysical_frag
                    },
                    toon: {
                        uniforms: Xn([di.common, di.aomap, di.lightmap, di.emissivemap, di.bumpmap, di.normalmap, di.displacementmap, di.gradientmap, di.fog, di.lights, {
                            emissive: {
                                value: new tn(0)
                            }
                        }]),
                        vertexShader: hi.meshtoon_vert,
                        fragmentShader: hi.meshtoon_frag
                    },
                    matcap: {
                        uniforms: Xn([di.common, di.bumpmap, di.normalmap, di.displacementmap, di.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: hi.meshmatcap_vert,
                        fragmentShader: hi.meshmatcap_frag
                    },
                    points: {
                        uniforms: Xn([di.points, di.fog]),
                        vertexShader: hi.points_vert,
                        fragmentShader: hi.points_frag
                    },
                    dashed: {
                        uniforms: Xn([di.common, di.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: hi.linedashed_vert,
                        fragmentShader: hi.linedashed_frag
                    },
                    depth: {
                        uniforms: Xn([di.common, di.displacementmap]),
                        vertexShader: hi.depth_vert,
                        fragmentShader: hi.depth_frag
                    },
                    normal: {
                        uniforms: Xn([di.common, di.bumpmap, di.normalmap, di.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: hi.meshnormal_vert,
                        fragmentShader: hi.meshnormal_frag
                    },
                    sprite: {
                        uniforms: Xn([di.sprite, di.fog]),
                        vertexShader: hi.sprite_vert,
                        fragmentShader: hi.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new ve
                            },
                            t2D: {
                                value: null
                            }
                        },
                        vertexShader: hi.background_vert,
                        fragmentShader: hi.background_frag
                    },
                    cube: {
                        uniforms: Xn([di.envmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: hi.cube_vert,
                        fragmentShader: hi.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: hi.equirect_vert,
                        fragmentShader: hi.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: Xn([di.common, di.displacementmap, {
                            referencePosition: {
                                value: new Fe
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: hi.distanceRGBA_vert,
                        fragmentShader: hi.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: Xn([di.lights, di.fog, {
                            color: {
                                value: new tn(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: hi.shadow_vert,
                        fragmentShader: hi.shadow_frag
                    }
                };
            function fi(e, t, n, i, r) {
                const a = new tn(0);
                let s, o, c = 0,
                    u = null,
                    h = 0,
                    d = null;
                function p(e, t) {
                    n.buffers.color.setClear(e.r, e.g, e.b, t, r)
                }
                return {
                    getClearColor: function () {
                        return a
                    },
                    setClearColor: function (e, t = 1) {
                        a.set(e), c = t, p(a, c)
                    },
                    getClearAlpha: function () {
                        return c
                    },
                    setClearAlpha: function (e) {
                        c = e, p(a, c)
                    },
                    render: function (n, r) {
                        let f = false,
                            m = !0 === r.isScene ? r.background : null;
                        m && m.isTexture && (m = t.get(m));
                        const g = e.xr,
                            v = g.getSession && g.getSession();
                        v && "additive" === v.environmentBlendMode && (m = null), null === m ? p(a, c) : m && m.isColor && (p(m, 1), f = true), (e.autoClear || f) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), m && (m.isCubeTexture || m.mapping === l) ? (void 0 === o && (o = new Gn(new jn(1, 1, 1), new qn({
                            name: "BackgroundCubeMaterial",
                            uniforms: Wn(pi.cube.uniforms),
                            vertexShader: pi.cube.vertexShader,
                            fragmentShader: pi.cube.fragmentShader,
                            side: 1,
                            depthTest: false,
                            depthWrite: false,
                            fog: false
                        })), o.geometry.deleteAttribute("normal"), o.geometry.deleteAttribute("uv"), o.onBeforeRender = function (e, t, n) {
                            this.matrixWorld.copyPosition(n.matrixWorld)
                        }, Object.defineProperty(o.material, "envMap", {
                            get: function () {
                                return this.uniforms.envMap.value
                            }
                        }), i.update(o)), o.material.uniforms.envMap.value = m, o.material.uniforms.flipEnvMap.value = m.isCubeTexture && !1 === m.isRenderTargetTexture ? -1 : 1, u === m && h === m.version && d === e.toneMapping || (o.material.needsUpdate = true, u = m, h = m.version, d = e.toneMapping), n.unshift(o, o.geometry, o.material, 0, 0, null)) : m && m.isTexture && (void 0 === s && (s = new Gn(new ui(2, 2), new qn({
                            name: "BackgroundMaterial",
                            uniforms: Wn(pi.background.uniforms),
                            vertexShader: pi.background.vertexShader,
                            fragmentShader: pi.background.fragmentShader,
                            side: 0,
                            depthTest: false,
                            depthWrite: false,
                            fog: false
                        })), s.geometry.deleteAttribute("normal"), Object.defineProperty(s.material, "map", {
                            get: function () {
                                return this.uniforms.t2D.value
                            }
                        }), i.update(s)), s.material.uniforms.t2D.value = m, !0 === m.matrixAutoUpdate && m.updateMatrix(), s.material.uniforms.uvTransform.value.copy(m.matrix), u === m && h === m.version && d === e.toneMapping || (s.material.needsUpdate = true, u = m, h = m.version, d = e.toneMapping), n.unshift(s, s.geometry, s.material, 0, 0, null))
                    }
                }
            }
            function mi(e, t, n, i) {
                const r = e.getParameter(34921),
                    a = i.isWebGL2 ? null : t.get("OES_vertex_array_object"),
                    s = i.isWebGL2 || null !== a,
                    o = {},
                    l = d(null);
                let c = l;
                function u(t) {
                    return i.isWebGL2 ? e.bindVertexArray(t) : a.bindVertexArrayOES(t)
                }
                function h(t) {
                    return i.isWebGL2 ? e.deleteVertexArray(t) : a.deleteVertexArrayOES(t)
                }
                function d(e) {
                    const t = [],
                        n = [],
                        i = [];
                    for (let e = 0; e < r; e++) t[e] = 0, n[e] = 0, i[e] = 0;
                    return {
                        geometry: null,
                        program: null,
                        wireframe: false,
                        newAttributes: t,
                        enabledAttributes: n,
                        attributeDivisors: i,
                        object: e,
                        attributes: {},
                        index: null
                    }
                }
                function p() {
                    const e = c.newAttributes;
                    for (let t = 0, n = e.length; t < n; t++) e[t] = 0
                }
                function f(e) {
                    m(e, 0)
                }
                function m(n, r) {
                    const a = c.newAttributes,
                        s = c.enabledAttributes,
                        o = c.attributeDivisors;
                    a[n] = 1, 0 === s[n] && (e.enableVertexAttribArray(n), s[n] = 1), o[n] !== r && ((i.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), o[n] = r)
                }
                function g() {
                    const t = c.newAttributes,
                        n = c.enabledAttributes;
                    for (let i = 0, r = n.length; i < r; i++) n[i] !== t[i] && (e.disableVertexAttribArray(i), n[i] = 0)
                }
                function v(t, n, r, a, s, o) {
                    !0 !== i.isWebGL2 || 5124 !== r && 5125 !== r ? e.vertexAttribPointer(t, n, r, a, s, o) : e.vertexAttribIPointer(t, n, r, s, o)
                }
                function y() {
                    x(), c !== l && (c = l, u(c.object))
                }
                function x() {
                    l.geometry = null, l.program = null, l.wireframe = false
                }
                return {
                    setup: function (r, l, h, y, x) {
                        let b = false;
                        if (s) {
                            const t = function (t, n, r) {
                                const s = !0 === r.wireframe;
                                let l = o[t.id];
                                void 0 === l && (l = {}, o[t.id] = l);
                                let c = l[n.id];
                                void 0 === c && (c = {}, l[n.id] = c);
                                let u = c[s];
                                return void 0 === u && (u = d(i.isWebGL2 ? e.createVertexArray() : a.createVertexArrayOES()), c[s] = u), u
                            }(y, h, l);
                            c !== t && (c = t, u(c.object)), b = function (e, t) {
                                const n = c.attributes,
                                    i = e.attributes;
                                let r = 0;
                                for (const e in i) {
                                    const t = n[e],
                                        a = i[e];
                                    if (void 0 === t) return true;
                                    if (t.attribute !== a) return true;
                                    if (t.data !== a.data) return true;
                                    r++
                                }
                                return c.attributesNum !== r || c.index !== t
                            }(y, x), b && function (e, t) {
                                const n = {},
                                    i = e.attributes;
                                let r = 0;
                                for (const e in i) {
                                    const t = i[e],
                                        a = {};
                                    a.attribute = t, t.data && (a.data = t.data), n[e] = a, r++
                                }
                                c.attributes = n, c.attributesNum = r, c.index = t
                            }(y, x)
                        } else {
                            const e = !0 === l.wireframe;
                            c.geometry === y.id && c.program === h.id && c.wireframe === e || (c.geometry = y.id, c.program = h.id, c.wireframe = e, b = true)
                        }!0 === r.isInstancedMesh && (b = true), null !== x && n.update(x, 34963), b && (function (r, a, s, o) {
                            if (!1 === i.isWebGL2 && (r.isInstancedMesh || o.isInstancedBufferGeometry) && null === t.get("ANGLE_instanced_arrays")) return;
                            p();
                            const l = o.attributes,
                                c = s.getAttributes(),
                                u = a.defaultAttributeValues;
                            for (const t in c) {
                                const i = c[t];
                                if (i.location >= 0) {
                                    let a = l[t];
                                    if (void 0 === a && ("instanceMatrix" === t && r.instanceMatrix && (a = r.instanceMatrix), "instanceColor" === t && r.instanceColor && (a = r.instanceColor)), void 0 !== a) {
                                        const t = a.normalized,
                                            s = a.itemSize,
                                            l = n.get(a);
                                        if (void 0 === l) continue;
                                        const c = l.buffer,
                                            u = l.type,
                                            h = l.bytesPerElement;
                                        if (a.isInterleavedBufferAttribute) {
                                            const n = a.data,
                                                l = n.stride,
                                                d = a.offset;
                                            if (n && n.isInstancedInterleavedBuffer) {
                                                for (let e = 0; e < i.locationSize; e++) m(i.location + e, n.meshPerAttribute);
                                                !0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = n.meshPerAttribute * n.count)
                                            } else
                                                for (let e = 0; e < i.locationSize; e++) f(i.location + e);
                                            e.bindBuffer(34962, c);
                                            for (let e = 0; e < i.locationSize; e++) v(i.location + e, s / i.locationSize, u, t, l * h, (d + s / i.locationSize * e) * h)
                                        } else {
                                            if (a.isInstancedBufferAttribute) {
                                                for (let e = 0; e < i.locationSize; e++) m(i.location + e, a.meshPerAttribute);
                                                !0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = a.meshPerAttribute * a.count)
                                            } else
                                                for (let e = 0; e < i.locationSize; e++) f(i.location + e);
                                            e.bindBuffer(34962, c);
                                            for (let e = 0; e < i.locationSize; e++) v(i.location + e, s / i.locationSize, u, t, s * h, s / i.locationSize * e * h)
                                        }
                                    } else if (void 0 !== u) {
                                        const n = u[t];
                                        if (void 0 !== n) switch (n.length) {
                                        case 2:
                                            e.vertexAttrib2fv(i.location, n);
                                            break;
                                        case 3:
                                            e.vertexAttrib3fv(i.location, n);
                                            break;
                                        case 4:
                                            e.vertexAttrib4fv(i.location, n);
                                            break;
                                        default:
                                            e.vertexAttrib1fv(i.location, n)
                                        }
                                    }
                                }
                            }
                            g()
                        }(r, l, h, y), null !== x && e.bindBuffer(34963, n.get(x).buffer))
                    },
                    reset: y,
                    resetDefaultState: x,
                    dispose: function () {
                        y();
                        for (const e in o) {
                            const t = o[e];
                            for (const e in t) {
                                const n = t[e];
                                for (const e in n) h(n[e].object), delete n[e];
                                delete t[e]
                            }
                            delete o[e]
                        }
                    },
                    releaseStatesOfGeometry: function (e) {
                        if (void 0 === o[e.id]) return;
                        const t = o[e.id];
                        for (const e in t) {
                            const n = t[e];
                            for (const e in n) h(n[e].object), delete n[e];
                            delete t[e]
                        }
                        delete o[e.id]
                    },
                    releaseStatesOfProgram: function (e) {
                        for (const t in o) {
                            const n = o[t];
                            if (void 0 === n[e.id]) continue;
                            const i = n[e.id];
                            for (const e in i) h(i[e].object), delete i[e];
                            delete n[e.id]
                        }
                    },
                    initAttributes: p,
                    enableAttribute: f,
                    disableUnusedAttributes: g
                }
            }
            function gi(e, t, n, i) {
                const r = i.isWebGL2;
                let a;
                this.setMode = function (e) {
                    a = e
                }, this.render = function (t, i) {
                    e.drawArrays(a, t, i), n.update(i, a, 1)
                }, this.renderInstances = function (i, s, o) {
                    if (0 === o) return;
                    let l, c;
                    if (r) l = e, c = "drawArraysInstanced";
                    else if (l = t.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    l[c](a, i, s, o), n.update(s, a, o)
                }
            }
            function vi(e, t, n) {
                let i;
                function r(t) {
                    if ("highp" === t) {
                        if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                        t = "mediump"
                    }
                    return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
                }
                const a = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext;
                let s = void 0 !== n.precision ? n.precision : "highp";
                const o = r(s);
                o !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", o, "instead."), s = o);
                const l = a || t.has("WEBGL_draw_buffers"),
                    c = !0 === n.logarithmicDepthBuffer,
                    u = e.getParameter(34930),
                    h = e.getParameter(35660),
                    d = e.getParameter(3379),
                    p = e.getParameter(34076),
                    f = e.getParameter(34921),
                    m = e.getParameter(36347),
                    g = e.getParameter(36348),
                    v = e.getParameter(36349),
                    y = h > 0,
                    x = a || t.has("OES_texture_float");
                return {
                    isWebGL2: a,
                    drawBuffers: l,
                    getMaxAnisotropy: function () {
                        if (void 0 !== i) return i;
                        if (!0 === t.has("EXT_texture_filter_anisotropic")) {
                            const n = t.get("EXT_texture_filter_anisotropic");
                            i = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                        } else i = 0;
                        return i
                    },
                    getMaxPrecision: r,
                    precision: s,
                    logarithmicDepthBuffer: c,
                    maxTextures: u,
                    maxVertexTextures: h,
                    maxTextureSize: d,
                    maxCubemapSize: p,
                    maxAttributes: f,
                    maxVertexUniforms: m,
                    maxVaryings: g,
                    maxFragmentUniforms: v,
                    vertexTextures: y,
                    floatFragmentTextures: x,
                    floatVertexTextures: y && x,
                    maxSamples: a ? e.getParameter(36183) : 0
                }
            }
            function yi(e) {
                const t = this;
                let n = null,
                    i = 0,
                    r = false,
                    a = false;
                const s = new ri,
                    o = new ve,
                    l = {
                        value: null,
                        needsUpdate: false
                    };
                function c() {
                    l.value !== n && (l.value = n, l.needsUpdate = i > 0), t.numPlanes = i, t.numIntersection = 0
                }
                function u(e, n, i, r) {
                    const a = null !== e ? e.length : 0;
                    let c = null;
                    if (0 !== a) {
                        if (c = l.value, !0 !== r || null === c) {
                            const t = i + 4 * a,
                                r = n.matrixWorldInverse;
                            o.getNormalMatrix(r), (null === c || c.length < t) && (c = new Float32Array(t));
                            for (let t = 0, n = i; t !== a; ++t, n += 4) s.copy(e[t]).applyMatrix4(r, o), s.normal.toArray(c, n), c[n + 3] = s.constant
                        }
                        l.value = c, l.needsUpdate = true
                    }
                    return t.numPlanes = a, t.numIntersection = 0, c
                }
                this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (e, t, a) {
                    const s = 0 !== e.length || t || 0 !== i || r;
                    return r = t, n = u(e, a, 0), i = e.length, s
                }, this.beginShadows = function () {
                    a = true, u(null)
                }, this.endShadows = function () {
                    a = false, c()
                }, this.setState = function (t, s, o) {
                    const h = t.clippingPlanes,
                        d = t.clipIntersection,
                        p = t.clipShadows,
                        f = e.get(t);
                    if (!r || null === h || 0 === h.length || a && !p) a ? u(null) : c();
                    else {
                        const e = a ? 0 : i,
                            t = 4 * e;
                        let r = f.clippingState || null;
                        l.value = r, r = u(h, s, t, o);
                        for (let e = 0; e !== t; ++e) r[e] = n[e];
                        f.clippingState = r, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += e
                    }
                }
            }
            function xi(e) {
                let t = new WeakMap;
                function n(e, t) {
                    return t === s ? e.mapping = r : t === o && (e.mapping = a), e
                }
                function i(e) {
                    const n = e.target;
                    n.removeEventListener("dispose", i);
                    const r = t.get(n);
                    void 0 !== r && (t.delete(n), r.dispose())
                }
                return {
                    get: function (r) {
                        if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
                            const a = r.mapping;
                            if (a === s || a === o) {
                                if (t.has(r)) return n(t.get(r).texture, r.mapping); {
                                    const a = r.image;
                                    if (a && a.height > 0) {
                                        const s = e.getRenderTarget(),
                                            o = new ei(a.height / 2);
                                        return o.fromEquirectangularTexture(e, r), t.set(r, o), e.setRenderTarget(s), r.addEventListener("dispose", i), n(o.texture, r.mapping)
                                    }
                                    return null
                                }
                            }
                        }
                        return r
                    },
                    dispose: function () {
                        t = new WeakMap
                    }
                }
            }
            pi.physical = {
                uniforms: Xn([pi.standard.uniforms, {
                    clearcoat: {
                        value: 0
                    },
                    clearcoatMap: {
                        value: null
                    },
                    clearcoatRoughness: {
                        value: 0
                    },
                    clearcoatRoughnessMap: {
                        value: null
                    },
                    clearcoatNormalScale: {
                        value: new ge(1, 1)
                    },
                    clearcoatNormalMap: {
                        value: null
                    },
                    sheen: {
                        value: 0
                    },
                    sheenColor: {
                        value: new tn(0)
                    },
                    sheenColorMap: {
                        value: null
                    },
                    sheenRoughness: {
                        value: 0
                    },
                    sheenRoughnessMap: {
                        value: null
                    },
                    transmission: {
                        value: 0
                    },
                    transmissionMap: {
                        value: null
                    },
                    transmissionSamplerSize: {
                        value: new ge
                    },
                    transmissionSamplerMap: {
                        value: null
                    },
                    thickness: {
                        value: 0
                    },
                    thicknessMap: {
                        value: null
                    },
                    attenuationDistance: {
                        value: 0
                    },
                    attenuationColor: {
                        value: new tn(0)
                    },
                    specularIntensity: {
                        value: 0
                    },
                    specularIntensityMap: {
                        value: null
                    },
                    specularColor: {
                        value: new tn(1, 1, 1)
                    },
                    specularColorMap: {
                        value: null
                    }
                }]),
                vertexShader: hi.meshphysical_vert,
                fragmentShader: hi.meshphysical_frag
            };
            class bi extends Qn {
                constructor(e = -1, t = 1, n = 1, i = -1, r = .1, a = 2e3) {
                    super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = r, this.far = a, this.updateProjectionMatrix()
                }
                copy(e, t) {
                    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
                }
                setViewOffset(e, t, n, i, r, a) {
                    null === this.view && (this.view = {
                        enabled: true,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = true, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
                }
                clearViewOffset() {
                    null !== this.view && (this.view.enabled = false), this.updateProjectionMatrix()
                }
                updateProjectionMatrix() {
                    const e = (this.right - this.left) / (2 * this.zoom),
                        t = (this.top - this.bottom) / (2 * this.zoom),
                        n = (this.right + this.left) / 2,
                        i = (this.top + this.bottom) / 2;
                    let r = n - e,
                        a = n + e,
                        s = i + t,
                        o = i - t;
                    if (null !== this.view && this.view.enabled) {
                        const e = (this.right - this.left) / this.view.fullWidth / this.zoom,
                            t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                        r += e * this.view.offsetX, a = r + e * this.view.width, s -= t * this.view.offsetY, o = s - t * this.view.height
                    }
                    this.projectionMatrix.makeOrthographic(r, a, s, o, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
                }
            }
            bi.prototype.isOrthographicCamera = true;
            class _i extends qn {
                constructor(e) {
                    super(e), this.type = "RawShaderMaterial"
                }
            }
            _i.prototype.isRawShaderMaterial = true;
            const wi = Math.pow(2, 8),
                Ei = [.125, .215, .35, .446, .526, .582],
                Mi = 5 + Ei.length,
                Ti = {
                    [X]: 0,
                    [Y]: 1,
                    [Q]: 2,
                    [J]: 3,
                    [Z]: 4,
                    [K]: 5,
                    [q]: 6
                },
                Si = new bi,
                {
                    _lodPlanes: Ai,
                    _sizeLods: Li,
                    _sigmas: Ri
                } = function () {
                    const e = [],
                        t = [],
                        n = [];
                    let i = 8;
                    for (let r = 0; r < Mi; r++) {
                        const a = Math.pow(2, i);
                        t.push(a);
                        let s = 1 / a;
                        r > 4 ? s = Ei[r - 8 + 4 - 1] : 0 == r && (s = 0), n.push(s);
                        const o = 1 / (a - 1),
                            l = -o / 2,
                            c = 1 + o / 2,
                            u = [l, l, c, l, c, c, l, l, c, c, l, c],
                            h = 6,
                            d = 6,
                            p = 3,
                            f = 2,
                            m = 1,
                            g = new Float32Array(p * d * h),
                            v = new Float32Array(f * d * h),
                            y = new Float32Array(m * d * h);
                        for (let e = 0; e < h; e++) {
                            const t = e % 3 * 2 / 3 - 1,
                                n = e > 2 ? 0 : -1,
                                i = [t, n, 0, t + 2 / 3, n, 0, t + 2 / 3, n + 1, 0, t, n, 0, t + 2 / 3, n + 1, 0, t, n + 1, 0];
                            g.set(i, p * d * e), v.set(u, f * d * e);
                            const r = [e, e, e, e, e, e];
                            y.set(r, m * d * e)
                        }
                        const x = new Mn;
                        x.setAttribute("position", new sn(g, p)), x.setAttribute("uv", new sn(v, f)), x.setAttribute("faceIndex", new sn(y, m)), e.push(x), i > 4 && i--
                    }
                    return {
                        _lodPlanes: e,
                        _sizeLods: t,
                        _sigmas: n
                    }
                }(),
                Pi = new tn;
            let Ci = null;
            const Ii = (1 + Math.sqrt(5)) / 2,
                Fi = 1 / Ii,
                Di = [new Fe(1, 1, 1), new Fe(-1, 1, 1), new Fe(1, 1, -1), new Fe(-1, 1, -1), new Fe(0, Ii, Fi), new Fe(0, Ii, -Fi), new Fe(Fi, 0, Ii), new Fe(-Fi, 0, Ii), new Fe(Ii, Fi, 0), new Fe(-Ii, Fi, 0)];
            class Ni {
                constructor(e) {
                    this._renderer = e, this._pingPongRenderTarget = null, this._blurMaterial = function (e) {
                        const t = new Float32Array(20),
                            n = new Fe(0, 1, 0);
                        return new _i({
                            name: "SphericalGaussianBlur",
                            defines: {
                                n: 20
                            },
                            uniforms: {
                                envMap: {
                                    value: null
                                },
                                samples: {
                                    value: 1
                                },
                                weights: {
                                    value: t
                                },
                                latitudinal: {
                                    value: false
                                },
                                dTheta: {
                                    value: 0
                                },
                                mipInt: {
                                    value: 0
                                },
                                poleAxis: {
                                    value: n
                                },
                                inputEncoding: {
                                    value: Ti[3e3]
                                },
                                outputEncoding: {
                                    value: Ti[3e3]
                                }
                            },
                            vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                            fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
                            blending: 0,
                            depthTest: false,
                            depthWrite: false
                        })
                    }(), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial)
                }
                fromScene(e, t = 0, n = .1, i = 100) {
                    Ci = this._renderer.getRenderTarget();
                    const r = this._allocateTargets();
                    return this._sceneToCubeUV(e, n, i, r), t > 0 && this._blur(r, 0, 0, t), this._applyPMREM(r), this._cleanup(r), r
                }
                fromEquirectangular(e) {
                    return this._fromTexture(e)
                }
                fromCubemap(e) {
                    return this._fromTexture(e)
                }
                compileCubemapShader() {
                    null === this._cubemapShader && (this._cubemapShader = zi(), this._compileMaterial(this._cubemapShader))
                }
                compileEquirectangularShader() {
                    null === this._equirectShader && (this._equirectShader = Bi(), this._compileMaterial(this._equirectShader))
                }
                dispose() {
                    this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();
                    for (let e = 0; e < Ai.length; e++) Ai[e].dispose()
                }
                _cleanup(e) {
                    this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(Ci), e.scissorTest = false, Ui(e, 0, 0, e.width, e.height)
                }
                _fromTexture(e) {
                    Ci = this._renderer.getRenderTarget();
                    const t = this._allocateTargets(e);
                    return this._textureToCubeUV(e, t), this._applyPMREM(t), this._cleanup(t), t
                }
                _allocateTargets(e) {
                    const t = {
                            magFilter: p,
                            minFilter: p,
                            generateMipmaps: false,
                            type: x,
                            format: 1023,
                            encoding: Oi(e) ? e.encoding : Q,
                            depthBuffer: false
                        },
                        n = Hi(t);
                    return n.depthBuffer = !e, this._pingPongRenderTarget = Hi(t), n
                }
                _compileMaterial(e) {
                    const t = new Gn(Ai[0], e);
                    this._renderer.compile(t, Si)
                }
                _sceneToCubeUV(e, t, n, i) {
                    const r = new Jn(90, 1, t, n),
                        a = [1, -1, 1, 1, 1, 1],
                        s = [1, 1, 1, -1, -1, -1],
                        o = this._renderer,
                        l = o.autoClear,
                        c = o.outputEncoding,
                        u = o.toneMapping;
                    o.getClearColor(Pi), o.toneMapping = 0, o.outputEncoding = X, o.autoClear = false;
                    const h = new nn({
                            name: "PMREM.Background",
                            side: 1,
                            depthWrite: false,
                            depthTest: false
                        }),
                        d = new Gn(new jn, h);
                    let p = false;
                    const f = e.background;
                    f ? f.isColor && (h.color.copy(f), e.background = null, p = true) : (h.color.copy(Pi), p = true);
                    for (let t = 0; t < 6; t++) {
                        const n = t % 3;
                        0 == n ? (r.up.set(0, a[t], 0), r.lookAt(s[t], 0, 0)) : 1 == n ? (r.up.set(0, 0, a[t]), r.lookAt(0, s[t], 0)) : (r.up.set(0, a[t], 0), r.lookAt(0, 0, s[t])), Ui(i, n * wi, t > 2 ? wi : 0, wi, wi), o.setRenderTarget(i), p && o.render(d, r), o.render(e, r)
                    }
                    d.geometry.dispose(), d.material.dispose(), o.toneMapping = u, o.outputEncoding = c, o.autoClear = l, e.background = f
                }
                _setEncoding(e, t) {
                    e.value = Ti[t.encoding]
                }
                _textureToCubeUV(e, t) {
                    const n = this._renderer,
                        i = e.mapping === r || e.mapping === a;
                    i ? null == this._cubemapShader && (this._cubemapShader = zi()) : null == this._equirectShader && (this._equirectShader = Bi());
                    const s = i ? this._cubemapShader : this._equirectShader,
                        o = new Gn(Ai[0], s),
                        l = s.uniforms;
                    l.envMap.value = e, i || l.texelSize.value.set(1 / e.image.width, 1 / e.image.height), this._setEncoding(l.inputEncoding, e), this._setEncoding(l.outputEncoding, t.texture), Ui(t, 0, 0, 3 * wi, 2 * wi), n.setRenderTarget(t), n.render(o, Si)
                }
                _applyPMREM(e) {
                    const t = this._renderer,
                        n = t.autoClear;
                    t.autoClear = false;
                    for (let t = 1; t < Mi; t++) {
                        const n = Math.sqrt(Ri[t] * Ri[t] - Ri[t - 1] * Ri[t - 1]),
                            i = Di[(t - 1) % Di.length];
                        this._blur(e, t - 1, t, n, i)
                    }
                    t.autoClear = n
                }
                _blur(e, t, n, i, r) {
                    const a = this._pingPongRenderTarget;
                    this._halfBlur(e, a, t, n, i, "latitudinal", r), this._halfBlur(a, e, n, n, i, "longitudinal", r)
                }
                _halfBlur(e, t, n, i, r, a, s) {
                    const o = this._renderer,
                        l = this._blurMaterial;
                    "latitudinal" !== a && "longitudinal" !== a && console.error("blur direction must be either latitudinal or longitudinal!");
                    const c = new Gn(Ai[i], l),
                        u = l.uniforms,
                        h = Li[n] - 1,
                        d = isFinite(r) ? Math.PI / (2 * h) : 2 * Math.PI / 39,
                        p = r / d,
                        f = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
                    f > 20 && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);
                    const m = [];
                    let g = 0;
                    for (let e = 0; e < 20; ++e) {
                        const t = e / p,
                            n = Math.exp(-t * t / 2);
                        m.push(n), 0 == e ? g += n : e < f && (g += 2 * n)
                    }
                    for (let e = 0; e < m.length; e++) m[e] = m[e] / g;
                    u.envMap.value = e.texture, u.samples.value = f, u.weights.value = m, u.latitudinal.value = "latitudinal" === a, s && (u.poleAxis.value = s), u.dTheta.value = d, u.mipInt.value = 8 - n, this._setEncoding(u.inputEncoding, e.texture), this._setEncoding(u.outputEncoding, e.texture);
                    const v = Li[i];
                    Ui(t, 3 * Math.max(0, wi - 2 * v), (0 === i ? 0 : 2 * wi) + 2 * v * (i > 4 ? i - 8 + 4 : 0), 3 * v, 2 * v), o.setRenderTarget(t), o.render(c, Si)
                }
            }
            function Oi(e) {
                return void 0 !== e && e.type === x && (e.encoding === X || e.encoding === Y || e.encoding === q)
            }
            function Hi(e) {
                const t = new Re(3 * wi, 3 * wi, e);
                return t.texture.mapping = l, t.texture.name = "PMREM.cubeUv", t.scissorTest = true, t
            }
            function Ui(e, t, n, i, r) {
                e.viewport.set(t, n, i, r), e.scissor.set(t, n, i, r)
            }
            function Bi() {
                const e = new ge(1, 1);
                return new _i({
                    name: "EquirectangularToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        texelSize: {
                            value: e
                        },
                        inputEncoding: {
                            value: Ti[3e3]
                        },
                        outputEncoding: {
                            value: Ti[3e3]
                        }
                    },
                    vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                    fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
                    blending: 0,
                    depthTest: false,
                    depthWrite: false
                })
            }
            function zi() {
                return new _i({
                    name: "CubemapToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        inputEncoding: {
                            value: Ti[3e3]
                        },
                        outputEncoding: {
                            value: Ti[3e3]
                        }
                    },
                    vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                    fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
                    blending: 0,
                    depthTest: false,
                    depthWrite: false
                })
            }
            function ki(e) {
                let t = new WeakMap,
                    n = null;
                function i(e) {
                    const n = e.target;
                    n.removeEventListener("dispose", i);
                    const r = t.get(n);
                    void 0 !== r && (t.delete(n), r.dispose())
                }
                return {
                    get: function (l) {
                        if (l && l.isTexture && !1 === l.isRenderTargetTexture) {
                            const c = l.mapping,
                                u = c === s || c === o,
                                h = c === r || c === a;
                            if (u || h) {
                                if (t.has(l)) return t.get(l).texture; {
                                    const r = l.image;
                                    if (u && r && r.height > 0 || h && r && function (e) {
                                            let t = 0;
                                            for (let n = 0; n < 6; n++) void 0 !== e[n] && t++;
                                            return 6 === t
                                        }(r)) {
                                        const r = e.getRenderTarget();
                                        null === n && (n = new Ni(e));
                                        const a = u ? n.fromEquirectangular(l) : n.fromCubemap(l);
                                        return t.set(l, a), e.setRenderTarget(r), l.addEventListener("dispose", i), a.texture
                                    }
                                    return null
                                }
                            }
                        }
                        return l
                    },
                    dispose: function () {
                        t = new WeakMap, null !== n && (n.dispose(), n = null)
                    }
                }
            }
            function Gi(e) {
                const t = {};
                function n(n) {
                    if (void 0 !== t[n]) return t[n];
                    let i;
                    switch (n) {
                    case "WEBGL_depth_texture":
                        i = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case "EXT_texture_filter_anisotropic":
                        i = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case "WEBGL_compressed_texture_s3tc":
                        i = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case "WEBGL_compressed_texture_pvrtc":
                        i = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    default:
                        i = e.getExtension(n)
                    }
                    return t[n] = i, i
                }
                return {
                    has: function (e) {
                        return null !== n(e)
                    },
                    init: function (e) {
                        e.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture")
                    },
                    get: function (e) {
                        const t = n(e);
                        return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."), t
                    }
                }
            }
            function Vi(e, t, n, i) {
                const r = {},
                    a = new WeakMap;
                function s(e) {
                    const o = e.target;
                    null !== o.index && t.remove(o.index);
                    for (const e in o.attributes) t.remove(o.attributes[e]);
                    o.removeEventListener("dispose", s), delete r[o.id];
                    const l = a.get(o);
                    l && (t.remove(l), a.delete(o)), i.releaseStatesOfGeometry(o), !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount, n.memory.geometries--
                }
                function o(e) {
                    const n = [],
                        i = e.index,
                        r = e.attributes.position;
                    let s = 0;
                    if (null !== i) {
                        const e = i.array;
                        s = i.version;
                        for (let t = 0, i = e.length; t < i; t += 3) {
                            const i = e[t + 0],
                                r = e[t + 1],
                                a = e[t + 2];
                            n.push(i, r, r, a, a, i)
                        }
                    } else {
                        const e = r.array;
                        s = r.version;
                        for (let t = 0, i = e.length / 3 - 1; t < i; t += 3) {
                            const e = t + 0,
                                i = t + 1,
                                r = t + 2;
                            n.push(e, i, i, r, r, e)
                        }
                    }
                    const o = new(ye(n) > 65535 ? pn : hn)(n, 1);
                    o.version = s;
                    const l = a.get(e);
                    l && t.remove(l), a.set(e, o)
                }
                return {
                    get: function (e, t) {
                        return !0 === r[t.id] || (t.addEventListener("dispose", s), r[t.id] = true, n.memory.geometries++), t
                    },
                    update: function (e) {
                        const n = e.attributes;
                        for (const e in n) t.update(n[e], 34962);
                        const i = e.morphAttributes;
                        for (const e in i) {
                            const n = i[e];
                            for (let e = 0, i = n.length; e < i; e++) t.update(n[e], 34962)
                        }
                    },
                    getWireframeAttribute: function (e) {
                        const t = a.get(e);
                        if (t) {
                            const n = e.index;
                            null !== n && t.version < n.version && o(e)
                        } else o(e);
                        return a.get(e)
                    }
                }
            }
            function ji(e, t, n, i) {
                const r = i.isWebGL2;
                let a, s, o;
                this.setMode = function (e) {
                    a = e
                }, this.setIndex = function (e) {
                    s = e.type, o = e.bytesPerElement
                }, this.render = function (t, i) {
                    e.drawElements(a, i, s, t * o), n.update(i, a, 1)
                }, this.renderInstances = function (i, l, c) {
                    if (0 === c) return;
                    let u, h;
                    if (r) u = e, h = "drawElementsInstanced";
                    else if (u = t.get("ANGLE_instanced_arrays"), h = "drawElementsInstancedANGLE", null === u) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    u[h](a, l, s, i * o, c), n.update(l, a, c)
                }
            }
            function Wi(e) {
                const t = {
                    frame: 0,
                    calls: 0,
                    triangles: 0,
                    points: 0,
                    lines: 0
                };
                return {
                    memory: {
                        geometries: 0,
                        textures: 0
                    },
                    render: t,
                    programs: null,
                    autoReset: true,
                    reset: function () {
                        t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
                    },
                    update: function (e, n, i) {
                        switch (t.calls++, n) {
                        case 4:
                            t.triangles += i * (e / 3);
                            break;
                        case 1:
                            t.lines += i * (e / 2);
                            break;
                        case 3:
                            t.lines += i * (e - 1);
                            break;
                        case 2:
                            t.lines += i * e;
                            break;
                        case 0:
                            t.points += i * e;
                            break;
                        default:
                            console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                        }
                    }
                }
            }
            class Xi extends Se {
                constructor(e = null, t = 1, n = 1, i = 1) {
                    super(null), this.image = {
                        data: e,
                        width: t,
                        height: n,
                        depth: i
                    }, this.magFilter = p, this.minFilter = p, this.wrapR = h, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.needsUpdate = true
                }
            }
            function Yi(e, t) {
                return e[0] - t[0]
            }
            function qi(e, t) {
                return Math.abs(t[1]) - Math.abs(e[1])
            }
            function Qi(e, t) {
                let n = 1;
                const i = t.isInterleavedBufferAttribute ? t.data.array : t.array;
                i instanceof Int8Array ? n = 127 : i instanceof Int16Array ? n = 32767 : i instanceof Int32Array ? n = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", i), e.divideScalar(n)
            }
            function Ji(e, t, n) {
                const i = {},
                    r = new Float32Array(8),
                    a = new WeakMap,
                    s = new Fe,
                    o = [];
                for (let e = 0; e < 8; e++) o[e] = [e, 0];
                return {
                    update: function (l, c, u, h) {
                        const d = l.morphTargetInfluences;
                        if (!0 === t.isWebGL2) {
                            const i = c.morphAttributes.position.length;
                            let r = a.get(c);
                            if (void 0 === r || r.count !== i) {
                                void 0 !== r && r.texture.dispose();
                                const e = void 0 !== c.morphAttributes.normal,
                                    n = c.morphAttributes.position,
                                    o = c.morphAttributes.normal || [],
                                    l = !0 === e ? 2 : 1;
                                let u = c.attributes.position.count * l,
                                    h = 1;
                                u > t.maxTextureSize && (h = Math.ceil(u / t.maxTextureSize), u = t.maxTextureSize);
                                const d = new Float32Array(u * h * 4 * i),
                                    p = new Xi(d, u, h, i);
                                p.format = S, p.type = w;
                                const f = 4 * l;
                                for (let t = 0; t < i; t++) {
                                    const i = n[t],
                                        r = o[t],
                                        a = u * h * 4 * t;
                                    for (let t = 0; t < i.count; t++) {
                                        s.fromBufferAttribute(i, t), !0 === i.normalized && Qi(s, i);
                                        const n = t * f;
                                        d[a + n + 0] = s.x, d[a + n + 1] = s.y, d[a + n + 2] = s.z, d[a + n + 3] = 0, !0 === e && (s.fromBufferAttribute(r, t), !0 === r.normalized && Qi(s, r), d[a + n + 4] = s.x, d[a + n + 5] = s.y, d[a + n + 6] = s.z, d[a + n + 7] = 0)
                                    }
                                }
                                r = {
                                    count: i,
                                    texture: p,
                                    size: new ge(u, h)
                                }, a.set(c, r)
                            }
                            let o = 0;
                            for (let e = 0; e < d.length; e++) o += d[e];
                            const l = c.morphTargetsRelative ? 1 : 1 - o;
                            h.getUniforms().setValue(e, "morphTargetBaseInfluence", l), h.getUniforms().setValue(e, "morphTargetInfluences", d), h.getUniforms().setValue(e, "morphTargetsTexture", r.texture, n), h.getUniforms().setValue(e, "morphTargetsTextureSize", r.size)
                        } else {
                            const t = void 0 === d ? 0 : d.length;
                            let n = i[c.id];
                            if (void 0 === n || n.length !== t) {
                                n = [];
                                for (let e = 0; e < t; e++) n[e] = [e, 0];
                                i[c.id] = n
                            }
                            for (let e = 0; e < t; e++) {
                                const t = n[e];
                                t[0] = e, t[1] = d[e]
                            }
                            n.sort(qi);
                            for (let e = 0; e < 8; e++) e < t && n[e][1] ? (o[e][0] = n[e][0], o[e][1] = n[e][1]) : (o[e][0] = Number.MAX_SAFE_INTEGER, o[e][1] = 0);
                            o.sort(Yi);
                            const a = c.morphAttributes.position,
                                s = c.morphAttributes.normal;
                            let l = 0;
                            for (let e = 0; e < 8; e++) {
                                const t = o[e],
                                    n = t[0],
                                    i = t[1];
                                n !== Number.MAX_SAFE_INTEGER && i ? (a && c.getAttribute("morphTarget" + e) !== a[n] && c.setAttribute("morphTarget" + e, a[n]), s && c.getAttribute("morphNormal" + e) !== s[n] && c.setAttribute("morphNormal" + e, s[n]), r[e] = i, l += i) : (a && !0 === c.hasAttribute("morphTarget" + e) && c.deleteAttribute("morphTarget" + e), s && !0 === c.hasAttribute("morphNormal" + e) && c.deleteAttribute("morphNormal" + e), r[e] = 0)
                            }
                            const u = c.morphTargetsRelative ? 1 : 1 - l;
                            h.getUniforms().setValue(e, "morphTargetBaseInfluence", u), h.getUniforms().setValue(e, "morphTargetInfluences", r)
                        }
                    }
                }
            }
            function Zi(e, t, n, i) {
                let r = new WeakMap;
                function a(e) {
                    const t = e.target;
                    t.removeEventListener("dispose", a), n.remove(t.instanceMatrix), null !== t.instanceColor && n.remove(t.instanceColor)
                }
                return {
                    update: function (e) {
                        const s = i.render.frame,
                            o = e.geometry,
                            l = t.get(e, o);
                        return r.get(l) !== s && (t.update(l), r.set(l, s)), e.isInstancedMesh && (!1 === e.hasEventListener("dispose", a) && e.addEventListener("dispose", a), n.update(e.instanceMatrix, 34962), null !== e.instanceColor && n.update(e.instanceColor, 34962)), l
                    },
                    dispose: function () {
                        r = new WeakMap
                    }
                }
            }
            Xi.prototype.isDataTexture2DArray = true;
            class Ki extends Se {
                constructor(e = null, t = 1, n = 1, i = 1) {
                    super(null), this.image = {
                        data: e,
                        width: t,
                        height: n,
                        depth: i
                    }, this.magFilter = p, this.minFilter = p, this.wrapR = h, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.needsUpdate = true
                }
            }
            Ki.prototype.isDataTexture3D = true;
            const $i = new Se,
                er = new Xi,
                tr = new Ki,
                nr = new $n,
                ir = [],
                rr = [],
                ar = new Float32Array(16),
                sr = new Float32Array(9),
                or = new Float32Array(4);
            function lr(e, t, n) {
                const i = e[0];
                if (i <= 0 || i > 0) return e;
                const r = t * n;
                let a = ir[r];
                if (void 0 === a && (a = new Float32Array(r), ir[r] = a), 0 !== t) {
                    i.toArray(a, 0);
                    for (let i = 1, r = 0; i !== t; ++i) r += n, e[i].toArray(a, r)
                }
                return a
            }
            function cr(e, t) {
                if (e.length !== t.length) return false;
                for (let n = 0, i = e.length; n < i; n++)
                    if (e[n] !== t[n]) return false;
                return true
            }
            function ur(e, t) {
                for (let n = 0, i = t.length; n < i; n++) e[n] = t[n]
            }
            function hr(e, t) {
                let n = rr[t];
                void 0 === n && (n = new Int32Array(t), rr[t] = n);
                for (let i = 0; i !== t; ++i) n[i] = e.allocateTextureUnit();
                return n
            }
            function dr(e, t) {
                const n = this.cache;
                n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t)
            }
            function pr(e, t) {
                const n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
                else {
                    if (cr(n, t)) return;
                    e.uniform2fv(this.addr, t), ur(n, t)
                }
            }
            function fr(e, t) {
                const n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
                else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b);
                else {
                    if (cr(n, t)) return;
                    e.uniform3fv(this.addr, t), ur(n, t)
                }
            }
            function mr(e, t) {
                const n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
                else {
                    if (cr(n, t)) return;
                    e.uniform4fv(this.addr, t), ur(n, t)
                }
            }
            function gr(e, t) {
                const n = this.cache,
                    i = t.elements;
                if (void 0 === i) {
                    if (cr(n, t)) return;
                    e.uniformMatrix2fv(this.addr, false, t), ur(n, t)
                } else {
                    if (cr(n, i)) return;
                    or.set(i), e.uniformMatrix2fv(this.addr, false, or), ur(n, i)
                }
            }
            function vr(e, t) {
                const n = this.cache,
                    i = t.elements;
                if (void 0 === i) {
                    if (cr(n, t)) return;
                    e.uniformMatrix3fv(this.addr, false, t), ur(n, t)
                } else {
                    if (cr(n, i)) return;
                    sr.set(i), e.uniformMatrix3fv(this.addr, false, sr), ur(n, i)
                }
            }
            function yr(e, t) {
                const n = this.cache,
                    i = t.elements;
                if (void 0 === i) {
                    if (cr(n, t)) return;
                    e.uniformMatrix4fv(this.addr, false, t), ur(n, t)
                } else {
                    if (cr(n, i)) return;
                    ar.set(i), e.uniformMatrix4fv(this.addr, false, ar), ur(n, i)
                }
            }
            function xr(e, t) {
                const n = this.cache;
                n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t)
            }
            function br(e, t) {
                const n = this.cache;
                cr(n, t) || (e.uniform2iv(this.addr, t), ur(n, t))
            }
            function _r(e, t) {
                const n = this.cache;
                cr(n, t) || (e.uniform3iv(this.addr, t), ur(n, t))
            }
            function wr(e, t) {
                const n = this.cache;
                cr(n, t) || (e.uniform4iv(this.addr, t), ur(n, t))
            }
            function Er(e, t) {
                const n = this.cache;
                n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t)
            }
            function Mr(e, t) {
                const n = this.cache;
                cr(n, t) || (e.uniform2uiv(this.addr, t), ur(n, t))
            }
            function Tr(e, t) {
                const n = this.cache;
                cr(n, t) || (e.uniform3uiv(this.addr, t), ur(n, t))
            }
            function Sr(e, t) {
                const n = this.cache;
                cr(n, t) || (e.uniform4uiv(this.addr, t), ur(n, t))
            }
            function Ar(e, t, n) {
                const i = this.cache,
                    r = n.allocateTextureUnit();
                i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(t || $i, r)
            }
            function Lr(e, t, n) {
                const i = this.cache,
                    r = n.allocateTextureUnit();
                i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(t || tr, r)
            }
            function Rr(e, t, n) {
                const i = this.cache,
                    r = n.allocateTextureUnit();
                i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(t || nr, r)
            }
            function Pr(e, t, n) {
                const i = this.cache,
                    r = n.allocateTextureUnit();
                i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(t || er, r)
            }
            function Cr(e, t) {
                e.uniform1fv(this.addr, t)
            }
            function Ir(e, t) {
                const n = lr(t, this.size, 2);
                e.uniform2fv(this.addr, n)
            }
            function Fr(e, t) {
                const n = lr(t, this.size, 3);
                e.uniform3fv(this.addr, n)
            }
            function Dr(e, t) {
                const n = lr(t, this.size, 4);
                e.uniform4fv(this.addr, n)
            }
            function Nr(e, t) {
                const n = lr(t, this.size, 4);
                e.uniformMatrix2fv(this.addr, false, n)
            }
            function Or(e, t) {
                const n = lr(t, this.size, 9);
                e.uniformMatrix3fv(this.addr, false, n)
            }
            function Hr(e, t) {
                const n = lr(t, this.size, 16);
                e.uniformMatrix4fv(this.addr, false, n)
            }
            function Ur(e, t) {
                e.uniform1iv(this.addr, t)
            }
            function Br(e, t) {
                e.uniform2iv(this.addr, t)
            }
            function zr(e, t) {
                e.uniform3iv(this.addr, t)
            }
            function kr(e, t) {
                e.uniform4iv(this.addr, t)
            }
            function Gr(e, t) {
                e.uniform1uiv(this.addr, t)
            }
            function Vr(e, t) {
                e.uniform2uiv(this.addr, t)
            }
            function jr(e, t) {
                e.uniform3uiv(this.addr, t)
            }
            function Wr(e, t) {
                e.uniform4uiv(this.addr, t)
            }
            function Xr(e, t, n) {
                const i = t.length,
                    r = hr(n, i);
                e.uniform1iv(this.addr, r);
                for (let e = 0; e !== i; ++e) n.safeSetTexture2D(t[e] || $i, r[e])
            }
            function Yr(e, t, n) {
                const i = t.length,
                    r = hr(n, i);
                e.uniform1iv(this.addr, r);
                for (let e = 0; e !== i; ++e) n.setTexture3D(t[e] || tr, r[e])
            }
            function qr(e, t, n) {
                const i = t.length,
                    r = hr(n, i);
                e.uniform1iv(this.addr, r);
                for (let e = 0; e !== i; ++e) n.safeSetTextureCube(t[e] || nr, r[e])
            }
            function Qr(e, t, n) {
                const i = t.length,
                    r = hr(n, i);
                e.uniform1iv(this.addr, r);
                for (let e = 0; e !== i; ++e) n.setTexture2DArray(t[e] || er, r[e])
            }
            function Jr(e, t, n) {
                this.id = e, this.addr = n, this.cache = [], this.setValue = function (e) {
                    switch (e) {
                    case 5126:
                        return dr;
                    case 35664:
                        return pr;
                    case 35665:
                        return fr;
                    case 35666:
                        return mr;
                    case 35674:
                        return gr;
                    case 35675:
                        return vr;
                    case 35676:
                        return yr;
                    case 5124:
                    case 35670:
                        return xr;
                    case 35667:
                    case 35671:
                        return br;
                    case 35668:
                    case 35672:
                        return _r;
                    case 35669:
                    case 35673:
                        return wr;
                    case 5125:
                        return Er;
                    case 36294:
                        return Mr;
                    case 36295:
                        return Tr;
                    case 36296:
                        return Sr;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return Ar;
                    case 35679:
                    case 36299:
                    case 36307:
                        return Lr;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return Rr;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return Pr
                    }
                }(t.type)
            }
            function Zr(e, t, n) {
                this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = function (e) {
                    switch (e) {
                    case 5126:
                        return Cr;
                    case 35664:
                        return Ir;
                    case 35665:
                        return Fr;
                    case 35666:
                        return Dr;
                    case 35674:
                        return Nr;
                    case 35675:
                        return Or;
                    case 35676:
                        return Hr;
                    case 5124:
                    case 35670:
                        return Ur;
                    case 35667:
                    case 35671:
                        return Br;
                    case 35668:
                    case 35672:
                        return zr;
                    case 35669:
                    case 35673:
                        return kr;
                    case 5125:
                        return Gr;
                    case 36294:
                        return Vr;
                    case 36295:
                        return jr;
                    case 36296:
                        return Wr;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return Xr;
                    case 35679:
                    case 36299:
                    case 36307:
                        return Yr;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return qr;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return Qr
                    }
                }(t.type)
            }
            function Kr(e) {
                this.id = e, this.seq = [], this.map = {}
            }
            Zr.prototype.updateCache = function (e) {
                const t = this.cache;
                e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), ur(t, e)
            }, Kr.prototype.setValue = function (e, t, n) {
                const i = this.seq;
                for (let r = 0, a = i.length; r !== a; ++r) {
                    const a = i[r];
                    a.setValue(e, t[a.id], n)
                }
            };
            const $r = /(\w+)(\])?(\[|\.)?/g;
            function ea(e, t) {
                e.seq.push(t), e.map[t.id] = t
            }
            function ta(e, t, n) {
                const i = e.name,
                    r = i.length;
                for ($r.lastIndex = 0;;) {
                    const a = $r.exec(i),
                        s = $r.lastIndex;
                    let o = a[1];
                    const l = "]" === a[2],
                        c = a[3];
                    if (l && (o |= 0), void 0 === c || "[" === c && s + 2 === r) {
                        ea(n, void 0 === c ? new Jr(o, e, t) : new Zr(o, e, t));
                        break
                    } {
                        let e = n.map[o];
                        void 0 === e && (e = new Kr(o), ea(n, e)), n = e
                    }
                }
            }
            function na(e, t) {
                this.seq = [], this.map = {};
                const n = e.getProgramParameter(t, 35718);
                for (let i = 0; i < n; ++i) {
                    const n = e.getActiveUniform(t, i);
                    ta(n, e.getUniformLocation(t, n.name), this)
                }
            }
            function ia(e, t, n) {
                const i = e.createShader(t);
                return e.shaderSource(i, n), e.compileShader(i), i
            }
            na.prototype.setValue = function (e, t, n, i) {
                const r = this.map[t];
                void 0 !== r && r.setValue(e, n, i)
            }, na.prototype.setOptional = function (e, t, n) {
                const i = t[n];
                void 0 !== i && this.setValue(e, n, i)
            }, na.upload = function (e, t, n, i) {
                for (let r = 0, a = t.length; r !== a; ++r) {
                    const a = t[r],
                        s = n[a.id];
                    !1 !== s.needsUpdate && a.setValue(e, s.value, i)
                }
            }, na.seqWithValue = function (e, t) {
                const n = [];
                for (let i = 0, r = e.length; i !== r; ++i) {
                    const r = e[i];
                    r.id in t && n.push(r)
                }
                return n
            };
            let ra = 0;
            function aa(e) {
                switch (e) {
                case X:
                    return ["Linear", "( value )"];
                case Y:
                    return ["sRGB", "( value )"];
                case Q:
                    return ["RGBE", "( value )"];
                case J:
                    return ["RGBM", "( value, 7.0 )"];
                case Z:
                    return ["RGBM", "( value, 16.0 )"];
                case K:
                    return ["RGBD", "( value, 256.0 )"];
                case q:
                    return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                default:
                    return console.warn("THREE.WebGLProgram: Unsupported encoding:", e), ["Linear", "( value )"]
                }
            }
            function sa(e, t, n) {
                const i = e.getShaderParameter(t, 35713),
                    r = e.getShaderInfoLog(t).trim();
                return i && "" === r ? "" : n.toUpperCase() + "\n\n" + r + "\n\n" + function (e) {
                    const t = e.split("\n");
                    for (let e = 0; e < t.length; e++) t[e] = e + 1 + ": " + t[e];
                    return t.join("\n")
                }(e.getShaderSource(t))
            }
            function oa(e, t) {
                const n = aa(t);
                return "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
            }
            function la(e, t) {
                const n = aa(t);
                return "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
            }
            function ca(e, t) {
                let n;
                switch (t) {
                case 1:
                    n = "Linear";
                    break;
                case 2:
                    n = "Reinhard";
                    break;
                case 3:
                    n = "OptimizedCineon";
                    break;
                case 4:
                    n = "ACESFilmic";
                    break;
                case 5:
                    n = "Custom";
                    break;
                default:
                    console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), n = "Linear"
                }
                return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
            }
            function ua(e) {
                return "" !== e
            }
            function ha(e, t) {
                return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
            }
            function da(e, t) {
                return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
            }
            const pa = /^[ \t]*#include +<([\w\d./]+)>/gm;
            function fa(e) {
                return e.replace(pa, ma)
            }
            function ma(e, t) {
                const n = hi[t];
                if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">");
                return fa(n)
            }
            const ga = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
                va = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
            function ya(e) {
                return e.replace(va, ba).replace(ga, xa)
            }
            function xa(e, t, n, i) {
                return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), ba(0, t, n, i)
            }
            function ba(e, t, n, i) {
                let r = "";
                for (let e = parseInt(t); e < parseInt(n); e++) r += i.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e);
                return r
            }
            function _a(e) {
                let t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
                return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t
            }
            function wa(e, t, n, i) {
                const s = e.getContext(),
                    o = n.defines;
                let u = n.vertexShader,
                    h = n.fragmentShader;
                const d = function (e) {
                        let t = "SHADOWMAP_TYPE_BASIC";
                        return 1 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF" : 2 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === e.shadowMapType && (t = "SHADOWMAP_TYPE_VSM"), t
                    }(n),
                    p = function (e) {
                        let t = "ENVMAP_TYPE_CUBE";
                        if (e.envMap) switch (e.envMapMode) {
                        case r:
                        case a:
                            t = "ENVMAP_TYPE_CUBE";
                            break;
                        case l:
                        case c:
                            t = "ENVMAP_TYPE_CUBE_UV"
                        }
                        return t
                    }(n),
                    f = function (e) {
                        let t = "ENVMAP_MODE_REFLECTION";
                        if (e.envMap) switch (e.envMapMode) {
                        case a:
                        case c:
                            t = "ENVMAP_MODE_REFRACTION"
                        }
                        return t
                    }(n),
                    m = function (e) {
                        let t = "ENVMAP_BLENDING_NONE";
                        if (e.envMap) switch (e.combine) {
                        case 0:
                            t = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case 1:
                            t = "ENVMAP_BLENDING_MIX";
                            break;
                        case 2:
                            t = "ENVMAP_BLENDING_ADD"
                        }
                        return t
                    }(n),
                    g = e.gammaFactor > 0 ? e.gammaFactor : 1,
                    v = n.isWebGL2 ? "" : function (e) {
                        return [e.extensionDerivatives || e.envMapCubeUV || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap || e.transmission) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(ua).join("\n")
                    }(n),
                    y = function (e) {
                        const t = [];
                        for (const n in e) {
                            const i = e[n];
                            !1 !== i && t.push("#define " + n + " " + i)
                        }
                        return t.join("\n")
                    }(o),
                    x = s.createProgram();
                let b, _, w = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
                n.isRawShaderMaterial ? (b = [y].filter(ua).join("\n"), b.length > 0 && (b += "\n"), _ = [v, y].filter(ua).join("\n"), _.length > 0 && (_ += "\n")) : (b = [_a(n), "#define SHADER_NAME " + n.shaderName, y, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + g, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + f : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + d : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(ua).join("\n"), _ = [v, _a(n), "#define SHADER_NAME " + n.shaderName, y, "#define GAMMA_FACTOR " + g, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + p : "", n.envMap ? "#define " + f : "", n.envMap ? "#define " + m : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + d : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? hi.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? ca("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.format === T ? "#define OPAQUE" : "", hi.encodings_pars_fragment, n.map ? oa("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? oa("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? oa("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? oa("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.specularColorMap ? oa("specularColorMapTexelToLinear", n.specularColorMapEncoding) : "", n.sheenColorMap ? oa("sheenColorMapTexelToLinear", n.sheenColorMapEncoding) : "", n.lightMap ? oa("lightMapTexelToLinear", n.lightMapEncoding) : "", la("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(ua).join("\n")), u = fa(u), u = ha(u, n), u = da(u, n), h = fa(h), h = ha(h, n), h = da(h, n), u = ya(u), h = ya(h), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (w = "#version 300 es\n", b = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + b, _ = ["#define varying in", n.glslVersion === ne ? "" : "out highp vec4 pc_fragColor;", n.glslVersion === ne ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + _);
                const E = w + _ + h,
                    M = ia(s, 35633, w + b + u),
                    S = ia(s, 35632, E);
                if (s.attachShader(x, M), s.attachShader(x, S), void 0 !== n.index0AttributeName ? s.bindAttribLocation(x, 0, n.index0AttributeName) : !0 === n.morphTargets && s.bindAttribLocation(x, 0, "position"), s.linkProgram(x), e.debug.checkShaderErrors) {
                    const e = s.getProgramInfoLog(x).trim(),
                        t = s.getShaderInfoLog(M).trim(),
                        n = s.getShaderInfoLog(S).trim();
                    let i = true,
                        r = true;
                    if (!1 === s.getProgramParameter(x, 35714)) {
                        i = false;
                        const t = sa(s, M, "vertex"),
                            n = sa(s, S, "fragment");
                        console.error("THREE.WebGLProgram: Shader Error " + s.getError() + " - VALIDATE_STATUS " + s.getProgramParameter(x, 35715) + "\n\nProgram Info Log: " + e + "\n" + t + "\n" + n)
                    } else "" !== e ? console.warn("THREE.WebGLProgram: Program Info Log:", e) : "" !== t && "" !== n || (r = false);
                    r && (this.diagnostics = {
                        runnable: i,
                        programLog: e,
                        vertexShader: {
                            log: t,
                            prefix: b
                        },
                        fragmentShader: {
                            log: n,
                            prefix: _
                        }
                    })
                }
                let A, L;
                return s.deleteShader(M), s.deleteShader(S), this.getUniforms = function () {
                    return void 0 === A && (A = new na(s, x)), A
                }, this.getAttributes = function () {
                    return void 0 === L && (L = function (e, t) {
                        const n = {},
                            i = e.getProgramParameter(t, 35721);
                        for (let r = 0; r < i; r++) {
                            const i = e.getActiveAttrib(t, r),
                                a = i.name;
                            let s = 1;
                            35674 === i.type && (s = 2), 35675 === i.type && (s = 3), 35676 === i.type && (s = 4), n[a] = {
                                type: i.type,
                                location: e.getAttribLocation(t, a),
                                locationSize: s
                            }
                        }
                        return n
                    }(s, x)), L
                }, this.destroy = function () {
                    i.releaseStatesOfProgram(this), s.deleteProgram(x), this.program = void 0
                }, this.name = n.shaderName, this.id = ra++, this.cacheKey = t, this.usedTimes = 1, this.program = x, this.vertexShader = M, this.fragmentShader = S, this
            }
            function Ea(e, t, n, i, r, a, s) {
                const o = [],
                    u = r.isWebGL2,
                    h = r.logarithmicDepthBuffer,
                    d = r.floatVertexTextures,
                    p = r.maxVertexUniforms,
                    f = r.vertexTextures;
                let m = r.precision;
                const g = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distanceRGBA",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "toon",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        MeshMatcapMaterial: "matcap",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow",
                        SpriteMaterial: "sprite"
                    },
                    v = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoat", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", , "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "alphaTest", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "morphTargetsCount", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "format", "specularIntensityMap", "specularColorMap", "specularColorMapEncoding", "transmission", "transmissionMap", "thicknessMap", "sheen", "sheenColorMap", "sheenColorMapEncoding", "sheenRoughnessMap"];
                function y(e) {
                    let t;
                    return e && e.isTexture ? t = e.encoding : e && e.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), t = e.texture.encoding) : t = X, t
                }
                return {
                    getParameters: function (a, o, v, x, b) {
                        const _ = x.fog,
                            w = a.isMeshStandardMaterial ? x.environment : null,
                            E = (a.isMeshStandardMaterial ? n : t).get(a.envMap || w),
                            M = g[a.type],
                            T = b.isSkinnedMesh ? function (e) {
                                const t = e.skeleton.bones;
                                if (d) return 1024; {
                                    const e = p,
                                        n = Math.floor((e - 20) / 4),
                                        i = Math.min(n, t.length);
                                    return i < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + i + "."), 0) : i
                                }
                            }(b) : 0;
                        let S, A;
                        if (null !== a.precision && (m = r.getMaxPrecision(a.precision), m !== a.precision && console.warn("THREE.WebGLProgram.getParameters:", a.precision, "not supported, using", m, "instead.")), M) {
                            const e = pi[M];
                            S = e.vertexShader, A = e.fragmentShader
                        } else S = a.vertexShader, A = a.fragmentShader;
                        const L = e.getRenderTarget(),
                            R = a.alphaTest > 0,
                            P = a.clearcoat > 0;
                        return {
                            isWebGL2: u,
                            shaderID: M,
                            shaderName: a.type,
                            vertexShader: S,
                            fragmentShader: A,
                            defines: a.defines,
                            isRawShaderMaterial: !0 === a.isRawShaderMaterial,
                            glslVersion: a.glslVersion,
                            precision: m,
                            instancing: !0 === b.isInstancedMesh,
                            instancingColor: !0 === b.isInstancedMesh && null !== b.instanceColor,
                            supportsVertexTextures: f,
                            outputEncoding: null !== L ? y(L.texture) : e.outputEncoding,
                            map: !!a.map,
                            mapEncoding: y(a.map),
                            matcap: !!a.matcap,
                            matcapEncoding: y(a.matcap),
                            envMap: !!E,
                            envMapMode: E && E.mapping,
                            envMapEncoding: y(E),
                            envMapCubeUV: !!E && (E.mapping === l || E.mapping === c),
                            lightMap: !!a.lightMap,
                            lightMapEncoding: y(a.lightMap),
                            aoMap: !!a.aoMap,
                            emissiveMap: !!a.emissiveMap,
                            emissiveMapEncoding: y(a.emissiveMap),
                            bumpMap: !!a.bumpMap,
                            normalMap: !!a.normalMap,
                            objectSpaceNormalMap: 1 === a.normalMapType,
                            tangentSpaceNormalMap: 0 === a.normalMapType,
                            clearcoat: P,
                            clearcoatMap: P && !!a.clearcoatMap,
                            clearcoatRoughnessMap: P && !!a.clearcoatRoughnessMap,
                            clearcoatNormalMap: P && !!a.clearcoatNormalMap,
                            displacementMap: !!a.displacementMap,
                            roughnessMap: !!a.roughnessMap,
                            metalnessMap: !!a.metalnessMap,
                            specularMap: !!a.specularMap,
                            specularIntensityMap: !!a.specularIntensityMap,
                            specularColorMap: !!a.specularColorMap,
                            specularColorMapEncoding: y(a.specularColorMap),
                            alphaMap: !!a.alphaMap,
                            alphaTest: R,
                            gradientMap: !!a.gradientMap,
                            sheen: a.sheen > 0,
                            sheenColorMap: !!a.sheenColorMap,
                            sheenColorMapEncoding: y(a.sheenColorMap),
                            sheenRoughnessMap: !!a.sheenRoughnessMap,
                            transmission: a.transmission > 0,
                            transmissionMap: !!a.transmissionMap,
                            thicknessMap: !!a.thicknessMap,
                            combine: a.combine,
                            vertexTangents: !!a.normalMap && !!b.geometry && !!b.geometry.attributes.tangent,
                            vertexColors: a.vertexColors,
                            vertexAlphas: !0 === a.vertexColors && !!b.geometry && !!b.geometry.attributes.color && 4 === b.geometry.attributes.color.itemSize,
                            vertexUvs: !!a.map || !!a.bumpMap || !!a.normalMap || !!a.specularMap || !!a.alphaMap || !!a.emissiveMap || !!a.roughnessMap || !!a.metalnessMap || !!a.clearcoatMap || !!a.clearcoatRoughnessMap || !!a.clearcoatNormalMap || !!a.displacementMap || !!a.transmissionMap || !!a.thicknessMap || !!a.specularIntensityMap || !!a.specularColorMap || !!a.sheenColorMap || a.sheenRoughnessMap,
                            uvsVertexOnly: !(a.map || a.bumpMap || a.normalMap || a.specularMap || a.alphaMap || a.emissiveMap || a.roughnessMap || a.metalnessMap || a.clearcoatNormalMap || a.transmission > 0 || a.transmissionMap || a.thicknessMap || a.specularIntensityMap || a.specularColorMap || a.sheen > 0 || a.sheenColorMap || a.sheenRoughnessMap || !a.displacementMap),
                            fog: !!_,
                            useFog: a.fog,
                            fogExp2: _ && _.isFogExp2,
                            flatShading: !!a.flatShading,
                            sizeAttenuation: a.sizeAttenuation,
                            logarithmicDepthBuffer: h,
                            skinning: !0 === b.isSkinnedMesh && T > 0,
                            maxBones: T,
                            useVertexTexture: d,
                            morphTargets: !!b.geometry && !!b.geometry.morphAttributes.position,
                            morphNormals: !!b.geometry && !!b.geometry.morphAttributes.normal,
                            morphTargetsCount: b.geometry && b.geometry.morphAttributes.position ? b.geometry.morphAttributes.position.length : 0,
                            numDirLights: o.directional.length,
                            numPointLights: o.point.length,
                            numSpotLights: o.spot.length,
                            numRectAreaLights: o.rectArea.length,
                            numHemiLights: o.hemi.length,
                            numDirLightShadows: o.directionalShadowMap.length,
                            numPointLightShadows: o.pointShadowMap.length,
                            numSpotLightShadows: o.spotShadowMap.length,
                            numClippingPlanes: s.numPlanes,
                            numClipIntersection: s.numIntersection,
                            format: a.format,
                            dithering: a.dithering,
                            shadowMapEnabled: e.shadowMap.enabled && v.length > 0,
                            shadowMapType: e.shadowMap.type,
                            toneMapping: a.toneMapped ? e.toneMapping : 0,
                            physicallyCorrectLights: e.physicallyCorrectLights,
                            premultipliedAlpha: a.premultipliedAlpha,
                            doubleSided: 2 === a.side,
                            flipSided: 1 === a.side,
                            depthPacking: void 0 !== a.depthPacking && a.depthPacking,
                            index0AttributeName: a.index0AttributeName,
                            extensionDerivatives: a.extensions && a.extensions.derivatives,
                            extensionFragDepth: a.extensions && a.extensions.fragDepth,
                            extensionDrawBuffers: a.extensions && a.extensions.drawBuffers,
                            extensionShaderTextureLOD: a.extensions && a.extensions.shaderTextureLOD,
                            rendererExtensionFragDepth: u || i.has("EXT_frag_depth"),
                            rendererExtensionDrawBuffers: u || i.has("WEBGL_draw_buffers"),
                            rendererExtensionShaderTextureLod: u || i.has("EXT_shader_texture_lod"),
                            customProgramCacheKey: a.customProgramCacheKey()
                        }
                    },
                    getProgramCacheKey: function (t) {
                        const n = [];
                        if (t.shaderID ? n.push(t.shaderID) : (n.push(we(t.fragmentShader)), n.push(we(t.vertexShader))), void 0 !== t.defines)
                            for (const e in t.defines) n.push(e), n.push(t.defines[e]);
                        if (!1 === t.isRawShaderMaterial) {
                            for (let e = 0; e < v.length; e++) n.push(t[v[e]]);
                            n.push(e.outputEncoding), n.push(e.gammaFactor)
                        }
                        return n.push(t.customProgramCacheKey), n.join()
                    },
                    getUniforms: function (e) {
                        const t = g[e.type];
                        let n;
                        if (t) {
                            const e = pi[t];
                            n = Yn.clone(e.uniforms)
                        } else n = e.uniforms;
                        return n
                    },
                    acquireProgram: function (t, n) {
                        let i;
                        for (let e = 0, t = o.length; e < t; e++) {
                            const t = o[e];
                            if (t.cacheKey === n) {
                                i = t, ++i.usedTimes;
                                break
                            }
                        }
                        return void 0 === i && (i = new wa(e, n, t, a), o.push(i)), i
                    },
                    releaseProgram: function (e) {
                        if (0 == --e.usedTimes) {
                            const t = o.indexOf(e);
                            o[t] = o[o.length - 1], o.pop(), e.destroy()
                        }
                    },
                    programs: o
                }
            }
            function Ma() {
                let e = new WeakMap;
                return {
                    get: function (t) {
                        let n = e.get(t);
                        return void 0 === n && (n = {}, e.set(t, n)), n
                    },
                    remove: function (t) {
                        e.delete(t)
                    },
                    update: function (t, n, i) {
                        e.get(t)[n] = i
                    },
                    dispose: function () {
                        e = new WeakMap
                    }
                }
            }
            function Ta(e, t) {
                return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
            }
            function Sa(e, t) {
                return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
            }
            function Aa(e) {
                const t = [];
                let n = 0;
                const i = [],
                    r = [],
                    a = [],
                    s = {
                        id: -1
                    };
                function o(i, r, a, o, l, c) {
                    let u = t[n];
                    const h = e.get(a);
                    return void 0 === u ? (u = {
                        id: i.id,
                        object: i,
                        geometry: r,
                        material: a,
                        program: h.program || s,
                        groupOrder: o,
                        renderOrder: i.renderOrder,
                        z: l,
                        group: c
                    }, t[n] = u) : (u.id = i.id, u.object = i, u.geometry = r, u.material = a, u.program = h.program || s, u.groupOrder = o, u.renderOrder = i.renderOrder, u.z = l, u.group = c), n++, u
                }
                return {
                    opaque: i,
                    transmissive: r,
                    transparent: a,
                    init: function () {
                        n = 0, i.length = 0, r.length = 0, a.length = 0
                    },
                    push: function (e, t, n, s, l, c) {
                        const u = o(e, t, n, s, l, c);
                        n.transmission > 0 ? r.push(u) : !0 === n.transparent ? a.push(u) : i.push(u)
                    },
                    unshift: function (e, t, n, s, l, c) {
                        const u = o(e, t, n, s, l, c);
                        n.transmission > 0 ? r.unshift(u) : !0 === n.transparent ? a.unshift(u) : i.unshift(u)
                    },
                    finish: function () {
                        for (let e = n, i = t.length; e < i; e++) {
                            const n = t[e];
                            if (null === n.id) break;
                            n.id = null, n.object = null, n.geometry = null, n.material = null, n.program = null, n.group = null
                        }
                    },
                    sort: function (e, t) {
                        i.length > 1 && i.sort(e || Ta), r.length > 1 && r.sort(t || Sa), a.length > 1 && a.sort(t || Sa)
                    }
                }
            }
            function La(e) {
                let t = new WeakMap;
                return {
                    get: function (n, i) {
                        let r;
                        return !1 === t.has(n) ? (r = new Aa(e), t.set(n, [r])) : i >= t.get(n).length ? (r = new Aa(e), t.get(n).push(r)) : r = t.get(n)[i], r
                    },
                    dispose: function () {
                        t = new WeakMap
                    }
                }
            }
            function Ra() {
                const e = {};
                return {
                    get: function (t) {
                        if (void 0 !== e[t.id]) return e[t.id];
                        let n;
                        switch (t.type) {
                        case "DirectionalLight":
                            n = {
                                direction: new Fe,
                                color: new tn
                            };
                            break;
                        case "SpotLight":
                            n = {
                                position: new Fe,
                                direction: new Fe,
                                color: new tn,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0
                            };
                            break;
                        case "PointLight":
                            n = {
                                position: new Fe,
                                color: new tn,
                                distance: 0,
                                decay: 0
                            };
                            break;
                        case "HemisphereLight":
                            n = {
                                direction: new Fe,
                                skyColor: new tn,
                                groundColor: new tn
                            };
                            break;
                        case "RectAreaLight":
                            n = {
                                color: new tn,
                                position: new Fe,
                                halfWidth: new Fe,
                                halfHeight: new Fe
                            }
                        }
                        return e[t.id] = n, n
                    }
                }
            }
            let Pa = 0;
            function Ca(e, t) {
                return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0)
            }
            function Ia(e, t) {
                const n = new Ra,
                    i = function () {
                        const e = {};
                        return {
                            get: function (t) {
                                if (void 0 !== e[t.id]) return e[t.id];
                                let n;
                                switch (t.type) {
                                case "DirectionalLight":
                                case "SpotLight":
                                    n = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new ge
                                    };
                                    break;
                                case "PointLight":
                                    n = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new ge,
                                        shadowCameraNear: 1,
                                        shadowCameraFar: 1e3
                                    }
                                }
                                return e[t.id] = n, n
                            }
                        }
                    }(),
                    r = {
                        version: 0,
                        hash: {
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            numDirectionalShadows: -1,
                            numPointShadows: -1,
                            numSpotShadows: -1
                        },
                        ambient: [0, 0, 0],
                        probe: [],
                        directional: [],
                        directionalShadow: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotShadow: [],
                        spotShadowMap: [],
                        spotShadowMatrix: [],
                        rectArea: [],
                        rectAreaLTC1: null,
                        rectAreaLTC2: null,
                        point: [],
                        pointShadow: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: []
                    };
                for (let e = 0; e < 9; e++) r.probe.push(new Fe);
                const a = new Fe,
                    s = new ut,
                    o = new ut;
                return {
                    setup: function (a, s) {
                        let o = 0,
                            l = 0,
                            c = 0;
                        for (let e = 0; e < 9; e++) r.probe[e].set(0, 0, 0);
                        let u = 0,
                            h = 0,
                            d = 0,
                            p = 0,
                            f = 0,
                            m = 0,
                            g = 0,
                            v = 0;
                        a.sort(Ca);
                        const y = !0 !== s ? Math.PI : 1;
                        for (let e = 0, t = a.length; e < t; e++) {
                            const t = a[e],
                                s = t.color,
                                x = t.intensity,
                                b = t.distance,
                                _ = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
                            if (t.isAmbientLight) o += s.r * x * y, l += s.g * x * y, c += s.b * x * y;
                            else if (t.isLightProbe)
                                for (let e = 0; e < 9; e++) r.probe[e].addScaledVector(t.sh.coefficients[e], x);
                            else if (t.isDirectionalLight) {
                                const e = n.get(t);
                                if (e.color.copy(t.color).multiplyScalar(t.intensity * y), t.castShadow) {
                                    const e = t.shadow,
                                        n = i.get(t);
                                    n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, r.directionalShadow[u] = n, r.directionalShadowMap[u] = _, r.directionalShadowMatrix[u] = t.shadow.matrix, m++
                                }
                                r.directional[u] = e, u++
                            } else if (t.isSpotLight) {
                                const e = n.get(t);
                                if (e.position.setFromMatrixPosition(t.matrixWorld), e.color.copy(s).multiplyScalar(x * y), e.distance = b, e.coneCos = Math.cos(t.angle), e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra)), e.decay = t.decay, t.castShadow) {
                                    const e = t.shadow,
                                        n = i.get(t);
                                    n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, r.spotShadow[d] = n, r.spotShadowMap[d] = _, r.spotShadowMatrix[d] = t.shadow.matrix, v++
                                }
                                r.spot[d] = e, d++
                            } else if (t.isRectAreaLight) {
                                const e = n.get(t);
                                e.color.copy(s).multiplyScalar(x), e.halfWidth.set(.5 * t.width, 0, 0), e.halfHeight.set(0, .5 * t.height, 0), r.rectArea[p] = e, p++
                            } else if (t.isPointLight) {
                                const e = n.get(t);
                                if (e.color.copy(t.color).multiplyScalar(t.intensity * y), e.distance = t.distance, e.decay = t.decay, t.castShadow) {
                                    const e = t.shadow,
                                        n = i.get(t);
                                    n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, n.shadowCameraNear = e.camera.near, n.shadowCameraFar = e.camera.far, r.pointShadow[h] = n, r.pointShadowMap[h] = _, r.pointShadowMatrix[h] = t.shadow.matrix, g++
                                }
                                r.point[h] = e, h++
                            } else if (t.isHemisphereLight) {
                                const e = n.get(t);
                                e.skyColor.copy(t.color).multiplyScalar(x * y), e.groundColor.copy(t.groundColor).multiplyScalar(x * y), r.hemi[f] = e, f++
                            }
                        }
                        p > 0 && (t.isWebGL2 || !0 === e.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = di.LTC_FLOAT_1, r.rectAreaLTC2 = di.LTC_FLOAT_2) : !0 === e.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = di.LTC_HALF_1, r.rectAreaLTC2 = di.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = o, r.ambient[1] = l, r.ambient[2] = c;
                        const x = r.hash;
                        x.directionalLength === u && x.pointLength === h && x.spotLength === d && x.rectAreaLength === p && x.hemiLength === f && x.numDirectionalShadows === m && x.numPointShadows === g && x.numSpotShadows === v || (r.directional.length = u, r.spot.length = d, r.rectArea.length = p, r.point.length = h, r.hemi.length = f, r.directionalShadow.length = m, r.directionalShadowMap.length = m, r.pointShadow.length = g, r.pointShadowMap.length = g, r.spotShadow.length = v, r.spotShadowMap.length = v, r.directionalShadowMatrix.length = m, r.pointShadowMatrix.length = g, r.spotShadowMatrix.length = v, x.directionalLength = u, x.pointLength = h, x.spotLength = d, x.rectAreaLength = p, x.hemiLength = f, x.numDirectionalShadows = m, x.numPointShadows = g, x.numSpotShadows = v, r.version = Pa++)
                    },
                    setupView: function (e, t) {
                        let n = 0,
                            i = 0,
                            l = 0,
                            c = 0,
                            u = 0;
                        const h = t.matrixWorldInverse;
                        for (let t = 0, d = e.length; t < d; t++) {
                            const d = e[t];
                            if (d.isDirectionalLight) {
                                const e = r.directional[n];
                                e.direction.setFromMatrixPosition(d.matrixWorld), a.setFromMatrixPosition(d.target.matrixWorld), e.direction.sub(a), e.direction.transformDirection(h), n++
                            } else if (d.isSpotLight) {
                                const e = r.spot[l];
                                e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(h), e.direction.setFromMatrixPosition(d.matrixWorld), a.setFromMatrixPosition(d.target.matrixWorld), e.direction.sub(a), e.direction.transformDirection(h), l++
                            } else if (d.isRectAreaLight) {
                                const e = r.rectArea[c];
                                e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(h), o.identity(), s.copy(d.matrixWorld), s.premultiply(h), o.extractRotation(s), e.halfWidth.set(.5 * d.width, 0, 0), e.halfHeight.set(0, .5 * d.height, 0), e.halfWidth.applyMatrix4(o), e.halfHeight.applyMatrix4(o), c++
                            } else if (d.isPointLight) {
                                const e = r.point[i];
                                e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(h), i++
                            } else if (d.isHemisphereLight) {
                                const e = r.hemi[u];
                                e.direction.setFromMatrixPosition(d.matrixWorld), e.direction.transformDirection(h), e.direction.normalize(), u++
                            }
                        }
                    },
                    state: r
                }
            }
            function Fa(e, t) {
                const n = new Ia(e, t),
                    i = [],
                    r = [];
                return {
                    init: function () {
                        i.length = 0, r.length = 0
                    },
                    state: {
                        lightsArray: i,
                        shadowsArray: r,
                        lights: n
                    },
                    setupLights: function (e) {
                        n.setup(i, e)
                    },
                    setupLightsView: function (e) {
                        n.setupView(i, e)
                    },
                    pushLight: function (e) {
                        i.push(e)
                    },
                    pushShadow: function (e) {
                        r.push(e)
                    }
                }
            }
            function Da(e, t) {
                let n = new WeakMap;
                return {
                    get: function (i, r = 0) {
                        let a;
                        return !1 === n.has(i) ? (a = new Fa(e, t), n.set(i, [a])) : r >= n.get(i).length ? (a = new Fa(e, t), n.get(i).push(a)) : a = n.get(i)[r], a
                    },
                    dispose: function () {
                        n = new WeakMap
                    }
                }
            }
            class Na extends qt {
                constructor(e) {
                    super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
                }
            }
            Na.prototype.isMeshDepthMaterial = true;
            class Oa extends qt {
                constructor(e) {
                    super(), this.type = "MeshDistanceMaterial", this.referencePosition = new Fe, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = false, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
                }
            }
            function Ha(e, t, n) {
                let i = new oi;
                const r = new ge,
                    a = new ge,
                    s = new Le,
                    o = new Na({
                        depthPacking: 3201
                    }),
                    l = new Oa,
                    c = {},
                    u = n.maxTextureSize,
                    h = {
                        0: 1,
                        1: 0,
                        2: 2
                    },
                    d = new qn({
                        defines: {
                            VSM_SAMPLES: 8
                        },
                        uniforms: {
                            shadow_pass: {
                                value: null
                            },
                            resolution: {
                                value: new ge
                            },
                            radius: {
                                value: 4
                            }
                        },
                        vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                        fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
                    }),
                    f = d.clone();
                f.defines.HORIZONTAL_PASS = 1;
                const m = new Mn;
                m.setAttribute("position", new sn(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
                const v = new Gn(m, d),
                    y = this;
                function x(n, i) {
                    const r = t.update(v);
                    d.defines.VSM_SAMPLES !== n.blurSamples && (d.defines.VSM_SAMPLES = n.blurSamples, f.defines.VSM_SAMPLES = n.blurSamples, d.needsUpdate = true, f.needsUpdate = true), d.uniforms.shadow_pass.value = n.map.texture, d.uniforms.resolution.value = n.mapSize, d.uniforms.radius.value = n.radius, e.setRenderTarget(n.mapPass), e.clear(), e.renderBufferDirect(i, null, r, d, v, null), f.uniforms.shadow_pass.value = n.mapPass.texture, f.uniforms.resolution.value = n.mapSize, f.uniforms.radius.value = n.radius, e.setRenderTarget(n.map), e.clear(), e.renderBufferDirect(i, null, r, f, v, null)
                }
                function b(t, n, i, r, a, s, u) {
                    let d = null;
                    const p = !0 === r.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
                    if (d = void 0 !== p ? p : !0 === r.isPointLight ? l : o, e.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length || i.displacementMap && 0 !== i.displacementScale || i.alphaMap && i.alphaTest > 0) {
                        const e = d.uuid,
                            t = i.uuid;
                        let n = c[e];
                        void 0 === n && (n = {}, c[e] = n);
                        let r = n[t];
                        void 0 === r && (r = d.clone(), n[t] = r), d = r
                    }
                    return d.visible = i.visible, d.wireframe = i.wireframe, d.side = 3 === u ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : h[i.side], d.alphaMap = i.alphaMap, d.alphaTest = i.alphaTest, d.clipShadows = i.clipShadows, d.clippingPlanes = i.clippingPlanes, d.clipIntersection = i.clipIntersection, d.displacementMap = i.displacementMap, d.displacementScale = i.displacementScale, d.displacementBias = i.displacementBias, d.wireframeLinewidth = i.wireframeLinewidth, d.linewidth = i.linewidth, !0 === r.isPointLight && !0 === d.isMeshDistanceMaterial && (d.referencePosition.setFromMatrixPosition(r.matrixWorld), d.nearDistance = a, d.farDistance = s), d
                }
                function _(n, r, a, s, o) {
                    if (!1 === n.visible) return;
                    if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === o) && (!n.frustumCulled || i.intersectsObject(n))) {
                        n.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, n.matrixWorld);
                        const i = t.update(n),
                            r = n.material;
                        if (Array.isArray(r)) {
                            const t = i.groups;
                            for (let l = 0, c = t.length; l < c; l++) {
                                const c = t[l],
                                    u = r[c.materialIndex];
                                if (u && u.visible) {
                                    const t = b(n, 0, u, s, a.near, a.far, o);
                                    e.renderBufferDirect(a, null, i, t, n, c)
                                }
                            }
                        } else if (r.visible) {
                            const t = b(n, 0, r, s, a.near, a.far, o);
                            e.renderBufferDirect(a, null, i, t, n, null)
                        }
                    }
                    const l = n.children;
                    for (let e = 0, t = l.length; e < t; e++) _(l[e], r, a, s, o)
                }
                this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = 1, this.render = function (t, n, o) {
                    if (!1 === y.enabled) return;
                    if (!1 === y.autoUpdate && !1 === y.needsUpdate) return;
                    if (0 === t.length) return;
                    const l = e.getRenderTarget(),
                        c = e.getActiveCubeFace(),
                        h = e.getActiveMipmapLevel(),
                        d = e.state;
                    d.setBlending(0), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(true), d.setScissorTest(false);
                    for (let l = 0, c = t.length; l < c; l++) {
                        const c = t[l],
                            h = c.shadow;
                        if (void 0 === h) {
                            console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
                            continue
                        }
                        if (!1 === h.autoUpdate && !1 === h.needsUpdate) continue;
                        r.copy(h.mapSize);
                        const f = h.getFrameExtents();
                        if (r.multiply(f), a.copy(h.mapSize), (r.x > u || r.y > u) && (r.x > u && (a.x = Math.floor(u / f.x), r.x = a.x * f.x, h.mapSize.x = a.x), r.y > u && (a.y = Math.floor(u / f.y), r.y = a.y * f.y, h.mapSize.y = a.y)), null === h.map && !h.isPointLightShadow && 3 === this.type) {
                            const e = {
                                minFilter: g,
                                magFilter: g,
                                format: S
                            };
                            h.map = new Re(r.x, r.y, e), h.map.texture.name = c.name + ".shadowMap", h.mapPass = new Re(r.x, r.y, e), h.camera.updateProjectionMatrix()
                        }
                        if (null === h.map) {
                            const e = {
                                minFilter: p,
                                magFilter: p,
                                format: S
                            };
                            h.map = new Re(r.x, r.y, e), h.map.texture.name = c.name + ".shadowMap", h.camera.updateProjectionMatrix()
                        }
                        e.setRenderTarget(h.map), e.clear();
                        const m = h.getViewportCount();
                        for (let e = 0; e < m; e++) {
                            const t = h.getViewport(e);
                            s.set(a.x * t.x, a.y * t.y, a.x * t.z, a.y * t.w), d.viewport(s), h.updateMatrices(c, e), i = h.getFrustum(), _(n, o, h.camera, c, this.type)
                        }
                        h.isPointLightShadow || 3 !== this.type || x(h, o), h.needsUpdate = false
                    }
                    y.needsUpdate = false, e.setRenderTarget(l, c, h)
                }
            }
            function Ua(e, t, i) {
                const r = i.isWebGL2,
                    a = new function () {
                        let t = false;
                        const n = new Le;
                        let i = null;
                        const r = new Le(0, 0, 0, 0);
                        return {
                            setMask: function (n) {
                                i === n || t || (e.colorMask(n, n, n, n), i = n)
                            },
                            setLocked: function (e) {
                                t = e
                            },
                            setClear: function (t, i, a, s, o) {
                                !0 === o && (t *= s, i *= s, a *= s), n.set(t, i, a, s), !1 === r.equals(n) && (e.clearColor(t, i, a, s), r.copy(n))
                            },
                            reset: function () {
                                t = false, i = null, r.set(-1, 0, 0, 0)
                            }
                        }
                    },
                    s = new function () {
                        let t = false,
                            n = null,
                            i = null,
                            r = null;
                        return {
                            setTest: function (e) {
                                e ? H(2929) : U(2929)
                            },
                            setMask: function (i) {
                                n === i || t || (e.depthMask(i), n = i)
                            },
                            setFunc: function (t) {
                                if (i !== t) {
                                    if (t) switch (t) {
                                    case 0:
                                        e.depthFunc(512);
                                        break;
                                    case 1:
                                        e.depthFunc(519);
                                        break;
                                    case 2:
                                        e.depthFunc(513);
                                        break;
                                    default:
                                        e.depthFunc(515);
                                        break;
                                    case 4:
                                        e.depthFunc(514);
                                        break;
                                    case 5:
                                        e.depthFunc(518);
                                        break;
                                    case 6:
                                        e.depthFunc(516);
                                        break;
                                    case 7:
                                        e.depthFunc(517)
                                    } else e.depthFunc(515);
                                    i = t
                                }
                            },
                            setLocked: function (e) {
                                t = e
                            },
                            setClear: function (t) {
                                r !== t && (e.clearDepth(t), r = t)
                            },
                            reset: function () {
                                t = false, n = null, i = null, r = null
                            }
                        }
                    },
                    o = new function () {
                        let t = false,
                            n = null,
                            i = null,
                            r = null,
                            a = null,
                            s = null,
                            o = null,
                            l = null,
                            c = null;
                        return {
                            setTest: function (e) {
                                t || (e ? H(2960) : U(2960))
                            },
                            setMask: function (i) {
                                n === i || t || (e.stencilMask(i), n = i)
                            },
                            setFunc: function (t, n, s) {
                                i === t && r === n && a === s || (e.stencilFunc(t, n, s), i = t, r = n, a = s)
                            },
                            setOp: function (t, n, i) {
                                s === t && o === n && l === i || (e.stencilOp(t, n, i), s = t, o = n, l = i)
                            },
                            setLocked: function (e) {
                                t = e
                            },
                            setClear: function (t) {
                                c !== t && (e.clearStencil(t), c = t)
                            },
                            reset: function () {
                                t = false, n = null, i = null, r = null, a = null, s = null, o = null, l = null, c = null
                            }
                        }
                    };
                let l = {},
                    c = {},
                    u = null,
                    h = false,
                    d = null,
                    p = null,
                    f = null,
                    m = null,
                    g = null,
                    v = null,
                    y = null,
                    x = false,
                    b = null,
                    _ = null,
                    w = null,
                    E = null,
                    M = null;
                const T = e.getParameter(35661);
                let S = false,
                    A = 0;
                const L = e.getParameter(7938); - 1 !== L.indexOf("WebGL") ? (A = parseFloat(/^WebGL (\d)/.exec(L)[1]), S = A >= 1) : -1 !== L.indexOf("OpenGL ES") && (A = parseFloat(/^OpenGL ES (\d)/.exec(L)[1]), S = A >= 2);
                let R = null,
                    P = {};
                const C = e.getParameter(3088),
                    I = e.getParameter(2978),
                    F = (new Le).fromArray(C),
                    D = (new Le).fromArray(I);
                function N(t, n, i) {
                    const r = new Uint8Array(4),
                        a = e.createTexture();
                    e.bindTexture(t, a), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728);
                    for (let t = 0; t < i; t++) e.texImage2D(n + t, 0, 6408, 1, 1, 0, 6408, 5121, r);
                    return a
                }
                const O = {};
                function H(t) {
                    !0 !== l[t] && (e.enable(t), l[t] = true)
                }
                function U(t) {
                    !1 !== l[t] && (e.disable(t), l[t] = false)
                }
                O[3553] = N(3553, 3553, 1), O[34067] = N(34067, 34069, 6), a.setClear(0, 0, 0, 1), s.setClear(1), o.setClear(0), H(2929), s.setFunc(3), G(false), V(1), H(2884), k(0);
                const B = {
                    [n]: 32774,
                    101: 32778,
                    102: 32779
                };
                if (r) B[103] = 32775, B[104] = 32776;
                else {
                    const e = t.get("EXT_blend_minmax");
                    null !== e && (B[103] = e.MIN_EXT, B[104] = e.MAX_EXT)
                }
                const z = {
                    200: 0,
                    201: 1,
                    202: 768,
                    204: 770,
                    210: 776,
                    208: 774,
                    206: 772,
                    203: 769,
                    205: 771,
                    209: 775,
                    207: 773
                };
                function k(t, i, r, a, s, o, l, c) {
                    if (0 !== t) {
                        if (!1 === h && (H(3042), h = true), 5 === t) s = s || i, o = o || r, l = l || a, i === p && s === g || (e.blendEquationSeparate(B[i], B[s]), p = i, g = s), r === f && a === m && o === v && l === y || (e.blendFuncSeparate(z[r], z[a], z[o], z[l]), f = r, m = a, v = o, y = l), d = t, x = null;
                        else if (t !== d || c !== x) {
                            if (p === n && g === n || (e.blendEquation(32774), p = n, g = n), c) switch (t) {
                            case 1:
                                e.blendFuncSeparate(1, 771, 1, 771);
                                break;
                            case 2:
                                e.blendFunc(1, 1);
                                break;
                            case 3:
                                e.blendFuncSeparate(0, 0, 769, 771);
                                break;
                            case 4:
                                e.blendFuncSeparate(0, 768, 0, 770);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", t)
                            } else switch (t) {
                            case 1:
                                e.blendFuncSeparate(770, 771, 1, 771);
                                break;
                            case 2:
                                e.blendFunc(770, 1);
                                break;
                            case 3:
                                e.blendFunc(0, 769);
                                break;
                            case 4:
                                e.blendFunc(0, 768);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", t)
                            }
                            f = null, m = null, v = null, y = null, d = t, x = c
                        }
                    } else !0 === h && (U(3042), h = false)
                }
                function G(t) {
                    b !== t && (t ? e.frontFace(2304) : e.frontFace(2305), b = t)
                }
                function V(t) {
                    0 !== t ? (H(2884), t !== _ && (1 === t ? e.cullFace(1029) : 2 === t ? e.cullFace(1028) : e.cullFace(1032))) : U(2884), _ = t
                }
                function j(t, n, i) {
                    t ? (H(32823), E === n && M === i || (e.polygonOffset(n, i), E = n, M = i)) : U(32823)
                }
                function W(t) {
                    void 0 === t && (t = 33984 + T - 1), R !== t && (e.activeTexture(t), R = t)
                }
                return {
                    buffers: {
                        color: a,
                        depth: s,
                        stencil: o
                    },
                    enable: H,
                    disable: U,
                    bindFramebuffer: function (t, n) {
                        return c[t] !== n && (e.bindFramebuffer(t, n), c[t] = n, r && (36009 === t && (c[36160] = n), 36160 === t && (c[36009] = n)), true)
                    },
                    useProgram: function (t) {
                        return u !== t && (e.useProgram(t), u = t, true)
                    },
                    setBlending: k,
                    setMaterial: function (e, t) {
                        2 === e.side ? U(2884) : H(2884);
                        let n = 1 === e.side;
                        t && (n = !n), G(n), 1 === e.blending && !1 === e.transparent ? k(0) : k(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), s.setFunc(e.depthFunc), s.setTest(e.depthTest), s.setMask(e.depthWrite), a.setMask(e.colorWrite);
                        const i = e.stencilWrite;
                        o.setTest(i), i && (o.setMask(e.stencilWriteMask), o.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), o.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), j(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), !0 === e.alphaToCoverage ? H(32926) : U(32926)
                    },
                    setFlipSided: G,
                    setCullFace: V,
                    setLineWidth: function (t) {
                        t !== w && (S && e.lineWidth(t), w = t)
                    },
                    setPolygonOffset: j,
                    setScissorTest: function (e) {
                        e ? H(3089) : U(3089)
                    },
                    activeTexture: W,
                    bindTexture: function (t, n) {
                        null === R && W();
                        let i = P[R];
                        void 0 === i && (i = {
                            type: void 0,
                            texture: void 0
                        }, P[R] = i), i.type === t && i.texture === n || (e.bindTexture(t, n || O[t]), i.type = t, i.texture = n)
                    },
                    unbindTexture: function () {
                        const t = P[R];
                        void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0)
                    },
                    compressedTexImage2D: function () {
                        try {
                            e.compressedTexImage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texImage2D: function () {
                        try {
                            e.texImage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texImage3D: function () {
                        try {
                            e.texImage3D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texStorage2D: function () {
                        try {
                            e.texStorage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texSubImage2D: function () {
                        try {
                            e.texSubImage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    scissor: function (t) {
                        !1 === F.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), F.copy(t))
                    },
                    viewport: function (t) {
                        !1 === D.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), D.copy(t))
                    },
                    reset: function () {
                        e.disable(3042), e.disable(2884), e.disable(2929), e.disable(32823), e.disable(3089), e.disable(2960), e.disable(32926), e.blendEquation(32774), e.blendFunc(1, 0), e.blendFuncSeparate(1, 0, 1, 0), e.colorMask(true, true, true, true), e.clearColor(0, 0, 0, 0), e.depthMask(true), e.depthFunc(513), e.clearDepth(1), e.stencilMask(4294967295), e.stencilFunc(519, 0, 4294967295), e.stencilOp(7680, 7680, 7680), e.clearStencil(0), e.cullFace(1029), e.frontFace(2305), e.polygonOffset(0, 0), e.activeTexture(33984), e.bindFramebuffer(36160, null), !0 === r && (e.bindFramebuffer(36009, null), e.bindFramebuffer(36008, null)), e.useProgram(null), e.lineWidth(1), e.scissor(0, 0, e.canvas.width, e.canvas.height), e.viewport(0, 0, e.canvas.width, e.canvas.height), l = {}, R = null, P = {}, c = {}, u = null, h = false, d = null, p = null, f = null, m = null, g = null, v = null, y = null, x = false, b = null, _ = null, w = null, E = null, M = null, F.set(0, 0, e.canvas.width, e.canvas.height), D.set(0, 0, e.canvas.width, e.canvas.height), a.reset(), s.reset(), o.reset()
                    }
                }
            }
            function Ba(e, t, n, i, r, a, s) {
                const o = r.isWebGL2,
                    l = r.maxTextures,
                    c = r.maxCubemapSize,
                    x = r.maxTextureSize,
                    R = r.maxSamples,
                    P = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : void 0,
                    C = new WeakMap;
                let I, F = false;
                try {
                    F = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
                } catch (e) {}
                function D(e, t) {
                    return F ? new OffscreenCanvas(e, t) : _e("canvas")
                }
                function N(e, t, n, i) {
                    let r = 1;
                    if ((e.width > i || e.height > i) && (r = i / Math.max(e.width, e.height)), r < 1 || !0 === t) {
                        if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                            const i = t ? fe : Math.floor,
                                a = i(r * e.width),
                                s = i(r * e.height);
                            void 0 === I && (I = D(a, s));
                            const o = n ? D(a, s) : I;
                            return o.width = a, o.height = s, o.getContext("2d").drawImage(e, 0, 0, a, s), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + a + "x" + s + ")."), o
                        }
                        return "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."), e
                    }
                    return e
                }
                function O(e) {
                    return de(e.width) && de(e.height)
                }
                function H(e, t) {
                    return e.generateMipmaps && t && e.minFilter !== p && e.minFilter !== g
                }
                function U(t) {
                    e.generateMipmap(t)
                }
                function B(n, i, r) {
                    if (!1 === o) return i;
                    if (null !== n) {
                        if (void 0 !== e[n]) return e[n];
                        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                    }
                    let a = i;
                    return 6403 === i && (5126 === r && (a = 33326), 5131 === r && (a = 33325), 5121 === r && (a = 33321)), 6407 === i && (5126 === r && (a = 34837), 5131 === r && (a = 34843), 5121 === r && (a = 32849)), 6408 === i && (5126 === r && (a = 34836), 5131 === r && (a = 34842), 5121 === r && (a = 32856)), 33325 !== a && 33326 !== a && 34842 !== a && 34836 !== a || t.get("EXT_color_buffer_float"), a
                }
                function z(e) {
                    return e === p || e === f || e === m ? 9728 : 9729
                }
                function k(t) {
                    const n = t.target;
                    n.removeEventListener("dispose", k),
                        function (t) {
                            const n = i.get(t);
                            void 0 !== n.__webglInit && (e.deleteTexture(n.__webglTexture), i.remove(t))
                        }(n), n.isVideoTexture && C.delete(n), s.memory.textures--
                }
                function G(t) {
                    const n = t.target;
                    n.removeEventListener("dispose", G),
                        function (t) {
                            const n = t.texture,
                                r = i.get(t),
                                a = i.get(n);
                            if (t) {
                                if (void 0 !== a.__webglTexture && (e.deleteTexture(a.__webglTexture), s.memory.textures--), t.depthTexture && t.depthTexture.dispose(), t.isWebGLCubeRenderTarget)
                                    for (let t = 0; t < 6; t++) e.deleteFramebuffer(r.__webglFramebuffer[t]), r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer[t]);
                                else e.deleteFramebuffer(r.__webglFramebuffer), r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer), r.__webglMultisampledFramebuffer && e.deleteFramebuffer(r.__webglMultisampledFramebuffer), r.__webglColorRenderbuffer && e.deleteRenderbuffer(r.__webglColorRenderbuffer), r.__webglDepthRenderbuffer && e.deleteRenderbuffer(r.__webglDepthRenderbuffer);
                                if (t.isWebGLMultipleRenderTargets)
                                    for (let t = 0, r = n.length; t < r; t++) {
                                        const r = i.get(n[t]);
                                        r.__webglTexture && (e.deleteTexture(r.__webglTexture), s.memory.textures--), i.remove(n[t])
                                    }
                                i.remove(n), i.remove(t)
                            }
                        }(n)
                }
                let V = 0;
                function j(e, t) {
                    const r = i.get(e);
                    if (e.isVideoTexture && function (e) {
                            const t = s.render.frame;
                            C.get(e) !== t && (C.set(e, t), e.update())
                        }(e), e.version > 0 && r.__version !== e.version) {
                        const n = e.image;
                        if (void 0 === n) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                        else {
                            if (!1 !== n.complete) return void J(r, e, t);
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                        }
                    }
                    n.activeTexture(33984 + t), n.bindTexture(3553, r.__webglTexture)
                }
                function W(t, r) {
                    const s = i.get(t);
                    t.version > 0 && s.__version !== t.version ? function (t, i, r) {
                        if (6 !== i.image.length) return;
                        Q(t, i), n.activeTexture(33984 + r), n.bindTexture(34067, t.__webglTexture), e.pixelStorei(37440, i.flipY), e.pixelStorei(37441, i.premultiplyAlpha), e.pixelStorei(3317, i.unpackAlignment), e.pixelStorei(37443, 0);
                        const s = i && (i.isCompressedTexture || i.image[0].isCompressedTexture),
                            l = i.image[0] && i.image[0].isDataTexture,
                            u = [];
                        for (let e = 0; e < 6; e++) u[e] = s || l ? l ? i.image[e].image : i.image[e] : N(i.image[e], false, true, c);
                        const h = O(u[0]) || o,
                            d = a.convert(i.format),
                            p = a.convert(i.type),
                            f = B(i.internalFormat, d, p, i.encoding);
                        let m;
                        if (q(34067, i, h), s)
                            for (let e = 0; e < 6; e++) {
                                m = u[e].mipmaps;
                                for (let t = 0; t < m.length; t++) {
                                    const r = m[t];
                                    i.format !== S && i.format !== T ? null !== d ? n.compressedTexImage2D(34069 + e, t, f, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + e, t, f, r.width, r.height, 0, d, p, r.data)
                                }
                            } else {
                                m = i.mipmaps;
                                for (let e = 0; e < 6; e++)
                                    if (l) {
                                        n.texImage2D(34069 + e, 0, f, u[e].width, u[e].height, 0, d, p, u[e].data);
                                        for (let t = 0; t < m.length; t++) {
                                            const i = m[t].image[e].image;
                                            n.texImage2D(34069 + e, t + 1, f, i.width, i.height, 0, d, p, i.data)
                                        }
                                    } else {
                                        n.texImage2D(34069 + e, 0, f, d, p, u[e]);
                                        for (let t = 0; t < m.length; t++) {
                                            const i = m[t];
                                            n.texImage2D(34069 + e, t + 1, f, d, p, i.image[e])
                                        }
                                    }
                            }
                        H(i, h) && U(34067), t.__version = i.version, i.onUpdate && i.onUpdate(i)
                    }(s, t, r) : (n.activeTexture(33984 + r), n.bindTexture(34067, s.__webglTexture))
                }
                const X = {
                        [u]: 10497,
                        [h]: 33071,
                        [d]: 33648
                    },
                    Y = {
                        [p]: 9728,
                        [f]: 9984,
                        [m]: 9986,
                        [g]: 9729,
                        [v]: 9985,
                        [y]: 9987
                    };
                function q(n, a, s) {
                    if (s ? (e.texParameteri(n, 10242, X[a.wrapS]), e.texParameteri(n, 10243, X[a.wrapT]), 32879 !== n && 35866 !== n || e.texParameteri(n, 32882, X[a.wrapR]), e.texParameteri(n, 10240, Y[a.magFilter]), e.texParameteri(n, 10241, Y[a.minFilter])) : (e.texParameteri(n, 10242, 33071), e.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || e.texParameteri(n, 32882, 33071), a.wrapS === h && a.wrapT === h || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(n, 10240, z(a.magFilter)), e.texParameteri(n, 10241, z(a.minFilter)), a.minFilter !== p && a.minFilter !== g && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === t.has("EXT_texture_filter_anisotropic")) {
                        const s = t.get("EXT_texture_filter_anisotropic");
                        if (a.type === w && !1 === t.has("OES_texture_float_linear")) return;
                        if (!1 === o && a.type === E && !1 === t.has("OES_texture_half_float_linear")) return;
                        (a.anisotropy > 1 || i.get(a).__currentAnisotropy) && (e.texParameterf(n, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())), i.get(a).__currentAnisotropy = a.anisotropy)
                    }
                }
                function Q(t, n) {
                    void 0 === t.__webglInit && (t.__webglInit = true, n.addEventListener("dispose", k), t.__webglTexture = e.createTexture(), s.memory.textures++)
                }
                function J(t, i, r) {
                    let s = 3553;
                    i.isDataTexture2DArray && (s = 35866), i.isDataTexture3D && (s = 32879), Q(t, i), n.activeTexture(33984 + r), n.bindTexture(s, t.__webglTexture), e.pixelStorei(37440, i.flipY), e.pixelStorei(37441, i.premultiplyAlpha), e.pixelStorei(3317, i.unpackAlignment), e.pixelStorei(37443, 0);
                    const l = function (e) {
                            return !o && (e.wrapS !== h || e.wrapT !== h || e.minFilter !== p && e.minFilter !== g)
                        }(i) && !1 === O(i.image),
                        c = N(i.image, l, false, x),
                        u = O(c) || o,
                        d = a.convert(i.format);
                    let f, m = a.convert(i.type),
                        v = B(i.internalFormat, d, m, i.encoding);
                    q(s, i, u);
                    const y = i.mipmaps;
                    if (i.isDepthTexture) v = 6402, o ? v = i.type === w ? 36012 : i.type === _ ? 33190 : i.type === M ? 35056 : 33189 : i.type === w && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i.format === A && 6402 === v && i.type !== b && i.type !== _ && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = b, m = a.convert(i.type)), i.format === L && 6402 === v && (v = 34041, i.type !== M && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = M, m = a.convert(i.type))), n.texImage2D(3553, 0, v, c.width, c.height, 0, d, m, null);
                    else if (i.isDataTexture)
                        if (y.length > 0 && u) {
                            for (let e = 0, t = y.length; e < t; e++) f = y[e], n.texImage2D(3553, e, v, f.width, f.height, 0, d, m, f.data);
                            i.generateMipmaps = false
                        } else n.texImage2D(3553, 0, v, c.width, c.height, 0, d, m, c.data);
                    else if (i.isCompressedTexture)
                        for (let e = 0, t = y.length; e < t; e++) f = y[e], i.format !== S && i.format !== T ? null !== d ? n.compressedTexImage2D(3553, e, v, f.width, f.height, 0, f.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, e, v, f.width, f.height, 0, d, m, f.data);
                    else if (i.isDataTexture2DArray) n.texImage3D(35866, 0, v, c.width, c.height, c.depth, 0, d, m, c.data);
                    else if (i.isDataTexture3D) n.texImage3D(32879, 0, v, c.width, c.height, c.depth, 0, d, m, c.data);
                    else {
                        const e = function (e, t, n) {
                                return !0 === H(e, n) ? Math.log2(Math.max(t.width, t.height)) + 1 : e.mipmaps.length > 0 ? e.mipmaps.length : 1
                            }(i, c, u),
                            r = o && !0 !== i.isVideoTexture,
                            a = void 0 === t.__version;
                        if (y.length > 0 && u) {
                            r && a && n.texStorage2D(3553, e, v, y[0].width, y[0].height);
                            for (let e = 0, t = y.length; e < t; e++) f = y[e], r ? n.texSubImage2D(3553, e, 0, 0, d, m, f) : n.texImage2D(3553, e, v, d, m, f);
                            i.generateMipmaps = false
                        } else r ? (a && n.texStorage2D(3553, e, v, c.width, c.height), n.texSubImage2D(3553, 0, 0, 0, d, m, c)) : n.texImage2D(3553, 0, v, d, m, c)
                    }
                    H(i, u) && U(s), t.__version = i.version, i.onUpdate && i.onUpdate(i)
                }
                function Z(t, r, s, o, l) {
                    const c = a.convert(s.format),
                        u = a.convert(s.type),
                        h = B(s.internalFormat, c, u, s.encoding);
                    i.get(r).__hasExternalTextures || (32879 === l || 35866 === l ? n.texImage3D(l, 0, h, r.width, r.height, r.depth, 0, c, u, null) : n.texImage2D(l, 0, h, r.width, r.height, 0, c, u, null)), n.bindFramebuffer(36160, t), r.useRenderToTexture ? P.framebufferTexture2DMultisampleEXT(36160, o, l, i.get(s).__webglTexture, 0, ee(r)) : e.framebufferTexture2D(36160, o, l, i.get(s).__webglTexture, 0), n.bindFramebuffer(36160, null)
                }
                function K(t, n, i) {
                    if (e.bindRenderbuffer(36161, t), n.depthBuffer && !n.stencilBuffer) {
                        let r = 33189;
                        if (i || n.useRenderToTexture) {
                            const t = n.depthTexture;
                            t && t.isDepthTexture && (t.type === w ? r = 36012 : t.type === _ && (r = 33190));
                            const i = ee(n);
                            n.useRenderToTexture ? P.renderbufferStorageMultisampleEXT(36161, i, r, n.width, n.height) : e.renderbufferStorageMultisample(36161, i, r, n.width, n.height)
                        } else e.renderbufferStorage(36161, r, n.width, n.height);
                        e.framebufferRenderbuffer(36160, 36096, 36161, t)
                    } else if (n.depthBuffer && n.stencilBuffer) {
                        const r = ee(n);
                        i && n.useRenderbuffer ? e.renderbufferStorageMultisample(36161, r, 35056, n.width, n.height) : n.useRenderToTexture ? P.renderbufferStorageMultisampleEXT(36161, r, 35056, n.width, n.height) : e.renderbufferStorage(36161, 34041, n.width, n.height), e.framebufferRenderbuffer(36160, 33306, 36161, t)
                    } else {
                        const t = !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture,
                            r = a.convert(t.format),
                            s = a.convert(t.type),
                            o = B(t.internalFormat, r, s, t.encoding),
                            l = ee(n);
                        i && n.useRenderbuffer ? e.renderbufferStorageMultisample(36161, l, o, n.width, n.height) : n.useRenderToTexture ? P.renderbufferStorageMultisampleEXT(36161, l, o, n.width, n.height) : e.renderbufferStorage(36161, o, n.width, n.height)
                    }
                    e.bindRenderbuffer(36161, null)
                }
                function $(t) {
                    const r = i.get(t),
                        a = !0 === t.isWebGLCubeRenderTarget;
                    if (t.depthTexture && !r.__autoAllocateDepthBuffer) {
                        if (a) throw new Error("target.depthTexture not supported in Cube render targets");
                        ! function (t, r) {
                            if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                            if (n.bindFramebuffer(36160, t), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = true), j(r.depthTexture, 0);
                            const a = i.get(r.depthTexture).__webglTexture,
                                s = ee(r);
                            if (r.depthTexture.format === A) r.useRenderToTexture ? P.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, a, 0, s) : e.framebufferTexture2D(36160, 36096, 3553, a, 0);
                            else {
                                if (r.depthTexture.format !== L) throw new Error("Unknown depthTexture format");
                                r.useRenderToTexture ? P.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, a, 0, s) : e.framebufferTexture2D(36160, 33306, 3553, a, 0)
                            }
                        }(r.__webglFramebuffer, t)
                    } else if (a) {
                        r.__webglDepthbuffer = [];
                        for (let i = 0; i < 6; i++) n.bindFramebuffer(36160, r.__webglFramebuffer[i]), r.__webglDepthbuffer[i] = e.createRenderbuffer(), K(r.__webglDepthbuffer[i], t, false)
                    } else n.bindFramebuffer(36160, r.__webglFramebuffer), r.__webglDepthbuffer = e.createRenderbuffer(), K(r.__webglDepthbuffer, t, false);
                    n.bindFramebuffer(36160, null)
                }
                function ee(e) {
                    return o && (e.useRenderbuffer || e.useRenderToTexture) ? Math.min(R, e.samples) : 0
                }
                let te = false,
                    ne = false;
                this.allocateTextureUnit = function () {
                    const e = V;
                    return e >= l && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + l), V += 1, e
                }, this.resetTextureUnits = function () {
                    V = 0
                }, this.setTexture2D = j, this.setTexture2DArray = function (e, t) {
                    const r = i.get(e);
                    e.version > 0 && r.__version !== e.version ? J(r, e, t) : (n.activeTexture(33984 + t), n.bindTexture(35866, r.__webglTexture))
                }, this.setTexture3D = function (e, t) {
                    const r = i.get(e);
                    e.version > 0 && r.__version !== e.version ? J(r, e, t) : (n.activeTexture(33984 + t), n.bindTexture(32879, r.__webglTexture))
                }, this.setTextureCube = W, this.rebindTextures = function (e, t, n) {
                    const r = i.get(e);
                    void 0 !== t && Z(r.__webglFramebuffer, e, e.texture, 36064, 3553), void 0 !== n && $(e)
                }, this.setupRenderTarget = function (t) {
                    const l = t.texture,
                        c = i.get(t),
                        u = i.get(l);
                    t.addEventListener("dispose", G), !0 !== t.isWebGLMultipleRenderTargets && (void 0 === u.__webglTexture && (u.__webglTexture = e.createTexture()), u.__version = l.version, s.memory.textures++);
                    const h = !0 === t.isWebGLCubeRenderTarget,
                        d = !0 === t.isWebGLMultipleRenderTargets,
                        p = l.isDataTexture3D || l.isDataTexture2DArray,
                        f = O(t) || o;
                    if (!o || l.format !== T || l.type !== w && l.type !== E || (l.format = S, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), h) {
                        c.__webglFramebuffer = [];
                        for (let t = 0; t < 6; t++) c.__webglFramebuffer[t] = e.createFramebuffer()
                    } else if (c.__webglFramebuffer = e.createFramebuffer(), d)
                        if (r.drawBuffers) {
                            const n = t.texture;
                            for (let t = 0, r = n.length; t < r; t++) {
                                const r = i.get(n[t]);
                                void 0 === r.__webglTexture && (r.__webglTexture = e.createTexture(), s.memory.textures++)
                            }
                        } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                    else if (t.useRenderbuffer)
                        if (o) {
                            c.__webglMultisampledFramebuffer = e.createFramebuffer(), c.__webglColorRenderbuffer = e.createRenderbuffer(), e.bindRenderbuffer(36161, c.__webglColorRenderbuffer);
                            const i = a.convert(l.format),
                                r = a.convert(l.type),
                                s = B(l.internalFormat, i, r, l.encoding),
                                o = ee(t);
                            e.renderbufferStorageMultisample(36161, o, s, t.width, t.height), n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064, 36161, c.__webglColorRenderbuffer), e.bindRenderbuffer(36161, null), t.depthBuffer && (c.__webglDepthRenderbuffer = e.createRenderbuffer(), K(c.__webglDepthRenderbuffer, t, true)), n.bindFramebuffer(36160, null)
                        } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                    if (h) {
                        n.bindTexture(34067, u.__webglTexture), q(34067, l, f);
                        for (let e = 0; e < 6; e++) Z(c.__webglFramebuffer[e], t, l, 36064, 34069 + e);
                        H(l, f) && U(34067), n.unbindTexture()
                    } else if (d) {
                        const e = t.texture;
                        for (let r = 0, a = e.length; r < a; r++) {
                            const a = e[r],
                                s = i.get(a);
                            n.bindTexture(3553, s.__webglTexture), q(3553, a, f), Z(c.__webglFramebuffer, t, a, 36064 + r, 3553), H(a, f) && U(3553)
                        }
                        n.unbindTexture()
                    } else {
                        let e = 3553;
                        p && (o ? e = l.isDataTexture3D ? 32879 : 35866 : console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")), n.bindTexture(e, u.__webglTexture), q(e, l, f), Z(c.__webglFramebuffer, t, l, 36064, e), H(l, f) && U(e), n.unbindTexture()
                    }
                    t.depthBuffer && $(t)
                }, this.updateRenderTargetMipmap = function (e) {
                    const t = O(e) || o,
                        r = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture];
                    for (let a = 0, s = r.length; a < s; a++) {
                        const s = r[a];
                        if (H(s, t)) {
                            const t = e.isWebGLCubeRenderTarget ? 34067 : 3553,
                                r = i.get(s).__webglTexture;
                            n.bindTexture(t, r), U(t), n.unbindTexture()
                        }
                    }
                }, this.updateMultisampleRenderTarget = function (t) {
                    if (t.useRenderbuffer)
                        if (o) {
                            const r = t.width,
                                a = t.height;
                            let s = 16384;
                            const o = [36064],
                                l = t.stencilBuffer ? 33306 : 36096;
                            t.depthBuffer && o.push(l), t.ignoreDepthForMultisampleCopy || (t.depthBuffer && (s |= 256), t.stencilBuffer && (s |= 1024));
                            const c = i.get(t);
                            n.bindFramebuffer(36008, c.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, c.__webglFramebuffer), t.ignoreDepthForMultisampleCopy && (e.invalidateFramebuffer(36008, [l]), e.invalidateFramebuffer(36009, [l])), e.blitFramebuffer(0, 0, r, a, 0, 0, r, a, s, 9728), e.invalidateFramebuffer(36008, o), n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, c.__webglMultisampledFramebuffer)
                        } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
                }, this.setupDepthRenderbuffer = $, this.setupFrameBufferTexture = Z, this.safeSetTexture2D = function (e, t) {
                    e && e.isWebGLRenderTarget && (!1 === te && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), te = true), e = e.texture), j(e, t)
                }, this.safeSetTextureCube = function (e, t) {
                    e && e.isWebGLCubeRenderTarget && (!1 === ne && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), ne = true), e = e.texture), W(e, t)
                }
            }
            function za(e, t, n) {
                const i = n.isWebGL2;
                return {
                    convert: function (e) {
                        let n;
                        if (e === x) return 5121;
                        if (1017 === e) return 32819;
                        if (1018 === e) return 32820;
                        if (1019 === e) return 33635;
                        if (1010 === e) return 5120;
                        if (1011 === e) return 5122;
                        if (e === b) return 5123;
                        if (1013 === e) return 5124;
                        if (e === _) return 5125;
                        if (e === w) return 5126;
                        if (e === E) return i ? 5131 : (n = t.get("OES_texture_half_float"), null !== n ? n.HALF_FLOAT_OES : null);
                        if (1021 === e) return 6406;
                        if (e === T) return 6407;
                        if (e === S) return 6408;
                        if (1024 === e) return 6409;
                        if (1025 === e) return 6410;
                        if (e === A) return 6402;
                        if (e === L) return 34041;
                        if (1028 === e) return 6403;
                        if (1029 === e) return 36244;
                        if (1030 === e) return 33319;
                        if (1031 === e) return 33320;
                        if (1032 === e) return 36248;
                        if (1033 === e) return 36249;
                        if (e === R || e === P || e === C || e === I) {
                            if (n = t.get("WEBGL_compressed_texture_s3tc"), null === n) return null;
                            if (e === R) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (e === P) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (e === C) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (e === I) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        }
                        if (e === F || e === D || e === N || e === O) {
                            if (n = t.get("WEBGL_compressed_texture_pvrtc"), null === n) return null;
                            if (e === F) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (e === D) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (e === N) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (e === O) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                        }
                        if (36196 === e) return n = t.get("WEBGL_compressed_texture_etc1"), null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null;
                        if ((e === H || e === U) && (n = t.get("WEBGL_compressed_texture_etc"), null !== n)) {
                            if (e === H) return n.COMPRESSED_RGB8_ETC2;
                            if (e === U) return n.COMPRESSED_RGBA8_ETC2_EAC
                        }
                        return 37808 === e || 37809 === e || 37810 === e || 37811 === e || 37812 === e || 37813 === e || 37814 === e || 37815 === e || 37816 === e || 37817 === e || 37818 === e || 37819 === e || 37820 === e || 37821 === e || 37840 === e || 37841 === e || 37842 === e || 37843 === e || 37844 === e || 37845 === e || 37846 === e || 37847 === e || 37848 === e || 37849 === e || 37850 === e || 37851 === e || 37852 === e || 37853 === e ? (n = t.get("WEBGL_compressed_texture_astc"), null !== n ? e : null) : 36492 === e ? (n = t.get("EXT_texture_compression_bptc"), null !== n ? e : null) : e === M ? i ? 34042 : (n = t.get("WEBGL_depth_texture"), null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null) : void 0
                    }
                }
            }
            Oa.prototype.isMeshDistanceMaterial = true;
            class ka extends Jn {
                constructor(e = []) {
                    super(), this.cameras = e
                }
            }
            ka.prototype.isArrayCamera = true;
            class Ga extends Nt {
                constructor() {
                    super(), this.type = "Group"
                }
            }
            Ga.prototype.isGroup = true;
            const Va = {
                type: "move"
            };
            class ja {
                constructor() {
                    this._targetRay = null, this._grip = null, this._hand = null
                }
                getHandSpace() {
                    return null === this._hand && (this._hand = new Ga, this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = {
                        pinching: false
                    }), this._hand
                }
                getTargetRaySpace() {
                    return null === this._targetRay && (this._targetRay = new Ga, this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new Fe, this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new Fe), this._targetRay
                }
                getGripSpace() {
                    return null === this._grip && (this._grip = new Ga, this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new Fe, this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new Fe), this._grip
                }
                dispatchEvent(e) {
                    return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this
                }
                disconnect(e) {
                    return this.dispatchEvent({
                        type: "disconnected",
                        data: e
                    }), null !== this._targetRay && (this._targetRay.visible = false), null !== this._grip && (this._grip.visible = false), null !== this._hand && (this._hand.visible = false), this
                }
                update(e, t, n) {
                    let i = null,
                        r = null,
                        a = null;
                    const s = this._targetRay,
                        o = this._grip,
                        l = this._hand;
                    if (e && "visible-blurred" !== t.session.visibilityState)
                        if (null !== s && (i = t.getPose(e.targetRaySpace, n), null !== i && (s.matrix.fromArray(i.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), i.linearVelocity ? (s.hasLinearVelocity = true, s.linearVelocity.copy(i.linearVelocity)) : s.hasLinearVelocity = false, i.angularVelocity ? (s.hasAngularVelocity = true, s.angularVelocity.copy(i.angularVelocity)) : s.hasAngularVelocity = false, this.dispatchEvent(Va))), l && e.hand) {
                            a = true;
                            for (const i of e.hand.values()) {
                                const e = t.getJointPose(i, n);
                                if (void 0 === l.joints[i.jointName]) {
                                    const e = new Ga;
                                    e.matrixAutoUpdate = false, e.visible = false, l.joints[i.jointName] = e, l.add(e)
                                }
                                const r = l.joints[i.jointName];
                                null !== e && (r.matrix.fromArray(e.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.jointRadius = e.radius), r.visible = null !== e
                            }
                            const i = l.joints["index-finger-tip"],
                                r = l.joints["thumb-tip"],
                                s = i.position.distanceTo(r.position),
                                o = .02,
                                c = .005;
                            l.inputState.pinching && s > o + c ? (l.inputState.pinching = false, this.dispatchEvent({
                                type: "pinchend",
                                handedness: e.handedness,
                                target: this
                            })) : !l.inputState.pinching && s <= o - c && (l.inputState.pinching = true, this.dispatchEvent({
                                type: "pinchstart",
                                handedness: e.handedness,
                                target: this
                            }))
                        } else null !== o && e.gripSpace && (r = t.getPose(e.gripSpace, n), null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), r.linearVelocity ? (o.hasLinearVelocity = true, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = false, r.angularVelocity ? (o.hasAngularVelocity = true, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = false));
                    return null !== s && (s.visible = null !== i), null !== o && (o.visible = null !== r), null !== l && (l.visible = null !== a), this
                }
            }
            class Wa extends Se {
                constructor(e, t, n, i, r, a, s, o, l, c) {
                    if ((c = void 0 !== c ? c : A) !== A && c !== L) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                    void 0 === n && c === A && (n = b), void 0 === n && c === L && (n = M), super(null, i, r, a, s, o, c, n, l), this.image = {
                        width: e,
                        height: t
                    }, this.magFilter = void 0 !== s ? s : p, this.minFilter = void 0 !== o ? o : p, this.flipY = false, this.generateMipmaps = false
                }
            }
            Wa.prototype.isDepthTexture = true;
            class Xa extends ie {
                constructor(e, t) {
                    super();
                    const n = this;
                    let i = null,
                        r = 1,
                        a = null,
                        s = "local-floor";
                    const o = e.extensions.has("WEBGL_multisampled_render_to_texture");
                    let l = null,
                        c = null,
                        u = null,
                        h = null,
                        d = false,
                        p = null;
                    const f = t.getContextAttributes();
                    let m = null,
                        g = null;
                    const v = [],
                        y = new Map,
                        _ = new Jn;
                    _.layers.enable(1), _.viewport = new Le;
                    const w = new Jn;
                    w.layers.enable(2), w.viewport = new Le;
                    const E = [_, w],
                        R = new ka;
                    R.layers.enable(1), R.layers.enable(2);
                    let P = null,
                        C = null;
                    function I(e) {
                        const t = y.get(e.inputSource);
                        t && t.dispatchEvent({
                            type: e.type,
                            data: e.inputSource
                        })
                    }
                    function F() {
                        y.forEach((function (e, t) {
                            e.disconnect(t)
                        })), y.clear(), P = null, C = null, e.setRenderTarget(m), h = null, u = null, c = null, i = null, g = null, B.stop(), n.isPresenting = false, n.dispatchEvent({
                            type: "sessionend"
                        })
                    }
                    function D(e) {
                        const t = i.inputSources;
                        for (let e = 0; e < v.length; e++) y.set(t[e], v[e]);
                        for (let t = 0; t < e.removed.length; t++) {
                            const n = e.removed[t],
                                i = y.get(n);
                            i && (i.dispatchEvent({
                                type: "disconnected",
                                data: n
                            }), y.delete(n))
                        }
                        for (let t = 0; t < e.added.length; t++) {
                            const n = e.added[t],
                                i = y.get(n);
                            i && i.dispatchEvent({
                                type: "connected",
                                data: n
                            })
                        }
                    }
                    this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getController = function (e) {
                        let t = v[e];
                        return void 0 === t && (t = new ja, v[e] = t), t.getTargetRaySpace()
                    }, this.getControllerGrip = function (e) {
                        let t = v[e];
                        return void 0 === t && (t = new ja, v[e] = t), t.getGripSpace()
                    }, this.getHand = function (e) {
                        let t = v[e];
                        return void 0 === t && (t = new ja, v[e] = t), t.getHandSpace()
                    }, this.setFramebufferScaleFactor = function (e) {
                        r = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                    }, this.setReferenceSpaceType = function (e) {
                        s = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                    }, this.getReferenceSpace = function () {
                        return a
                    }, this.getBaseLayer = function () {
                        return null !== u ? u : h
                    }, this.getBinding = function () {
                        return c
                    }, this.getFrame = function () {
                        return p
                    }, this.getSession = function () {
                        return i
                    }, this.setSession = async function (l) {
                        if (i = l, null !== i) {
                            if (m = e.getRenderTarget(), i.addEventListener("select", I), i.addEventListener("selectstart", I), i.addEventListener("selectend", I), i.addEventListener("squeeze", I), i.addEventListener("squeezestart", I), i.addEventListener("squeezeend", I), i.addEventListener("end", F), i.addEventListener("inputsourceschange", D), !0 !== f.xrCompatible && await t.makeXRCompatible(), void 0 === i.renderState.layers || !1 === e.capabilities.isWebGL2) {
                                const e = {
                                    antialias: void 0 !== i.renderState.layers || f.antialias,
                                    alpha: f.alpha,
                                    depth: f.depth,
                                    stencil: f.stencil,
                                    framebufferScaleFactor: r
                                };
                                h = new XRWebGLLayer(i, t, e), i.updateRenderState({
                                    baseLayer: h
                                }), g = new Re(h.framebufferWidth, h.framebufferHeight)
                            } else {
                                d = f.antialias;
                                let e = null,
                                    n = null,
                                    a = null;
                                f.depth && (a = f.stencil ? 35056 : 33189, e = f.stencil ? L : A, n = f.stencil ? M : b);
                                const s = {
                                    colorFormat: f.alpha || d ? 32856 : 32849,
                                    depthFormat: a,
                                    scaleFactor: r
                                };
                                c = new XRWebGLBinding(i, t), u = c.createProjectionLayer(s), i.updateRenderState({
                                    layers: [u]
                                }), g = d ? new Ce(u.textureWidth, u.textureHeight, {
                                    format: S,
                                    type: x,
                                    depthTexture: new Wa(u.textureWidth, u.textureHeight, n, void 0, void 0, void 0, void 0, void 0, void 0, e),
                                    stencilBuffer: f.stencil,
                                    ignoreDepth: u.ignoreDepthValues,
                                    useRenderToTexture: o
                                }) : new Re(u.textureWidth, u.textureHeight, {
                                    format: f.alpha ? S : T,
                                    type: x,
                                    depthTexture: new Wa(u.textureWidth, u.textureHeight, n, void 0, void 0, void 0, void 0, void 0, void 0, e),
                                    stencilBuffer: f.stencil,
                                    ignoreDepth: u.ignoreDepthValues
                                })
                            }
                            this.setFoveation(0), a = await i.requestReferenceSpace(s), B.setContext(i), B.start(), n.isPresenting = true, n.dispatchEvent({
                                type: "sessionstart"
                            })
                        }
                    };
                    const N = new Fe,
                        O = new Fe;
                    function H(e, t) {
                        null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.copy(e.matrixWorld).invert()
                    }
                    this.updateCamera = function (e) {
                        if (null === i) return;
                        R.near = w.near = _.near = e.near, R.far = w.far = _.far = e.far, P === R.near && C === R.far || (i.updateRenderState({
                            depthNear: R.near,
                            depthFar: R.far
                        }), P = R.near, C = R.far);
                        const t = e.parent,
                            n = R.cameras;
                        H(R, t);
                        for (let e = 0; e < n.length; e++) H(n[e], t);
                        R.matrixWorld.decompose(R.position, R.quaternion, R.scale), e.position.copy(R.position), e.quaternion.copy(R.quaternion), e.scale.copy(R.scale), e.matrix.copy(R.matrix), e.matrixWorld.copy(R.matrixWorld);
                        const r = e.children;
                        for (let e = 0, t = r.length; e < t; e++) r[e].updateMatrixWorld(true);
                        2 === n.length ? function (e, t, n) {
                            N.setFromMatrixPosition(t.matrixWorld), O.setFromMatrixPosition(n.matrixWorld);
                            const i = N.distanceTo(O),
                                r = t.projectionMatrix.elements,
                                a = n.projectionMatrix.elements,
                                s = r[14] / (r[10] - 1),
                                o = r[14] / (r[10] + 1),
                                l = (r[9] + 1) / r[5],
                                c = (r[9] - 1) / r[5],
                                u = (r[8] - 1) / r[0],
                                h = (a[8] + 1) / a[0],
                                d = s * u,
                                p = s * h,
                                f = i / (-u + h),
                                m = f * -u;
                            t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(m), e.translateZ(f), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert();
                            const g = s + f,
                                v = o + f,
                                y = d - m,
                                x = p + (i - m),
                                b = l * o / v * g,
                                _ = c * o / v * g;
                            e.projectionMatrix.makePerspective(y, x, b, _, g, v)
                        }(R, _, w) : R.projectionMatrix.copy(_.projectionMatrix)
                    }, this.getCamera = function () {
                        return R
                    }, this.getFoveation = function () {
                        return null !== u ? u.fixedFoveation : null !== h ? h.fixedFoveation : void 0
                    }, this.setFoveation = function (e) {
                        null !== u && (u.fixedFoveation = e), null !== h && void 0 !== h.fixedFoveation && (h.fixedFoveation = e)
                    };
                    let U = null;
                    const B = new li;
                    B.setAnimationLoop((function (t, n) {
                        if (l = n.getViewerPose(a), p = n, null !== l) {
                            const t = l.views;
                            null !== h && (e.setRenderTargetFramebuffer(g, h.framebuffer), e.setRenderTarget(g));
                            let n = false;
                            t.length !== R.cameras.length && (R.cameras.length = 0, n = true);
                            for (let i = 0; i < t.length; i++) {
                                const r = t[i];
                                let a = null;
                                if (null !== h) a = h.getViewport(r);
                                else {
                                    const t = c.getViewSubImage(u, r);
                                    a = t.viewport, 0 === i && (e.setRenderTargetTextures(g, t.colorTexture, u.ignoreDepthValues ? void 0 : t.depthStencilTexture), e.setRenderTarget(g))
                                }
                                const s = E[i];
                                s.matrix.fromArray(r.transform.matrix), s.projectionMatrix.fromArray(r.projectionMatrix), s.viewport.set(a.x, a.y, a.width, a.height), 0 === i && R.matrix.copy(s.matrix), !0 === n && R.cameras.push(s)
                            }
                        }
                        const r = i.inputSources;
                        for (let e = 0; e < v.length; e++) {
                            const t = v[e],
                                i = r[e];
                            t.update(i, n, a)
                        }
                        U && U(t, n), p = null
                    })), this.setAnimationLoop = function (e) {
                        U = e
                    }, this.dispose = function () {}
                }
            }
            function Ya(e) {
                function t(t, n) {
                    t.opacity.value = n.opacity, n.color && t.diffuse.value.copy(n.color), n.emissive && t.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (t.map.value = n.map), n.alphaMap && (t.alphaMap.value = n.alphaMap), n.specularMap && (t.specularMap.value = n.specularMap), n.alphaTest > 0 && (t.alphaTest.value = n.alphaTest);
                    const i = e.get(n).envMap;
                    let r, a;
                    i && (t.envMap.value = i, t.flipEnvMap.value = i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1, t.reflectivity.value = n.reflectivity, t.ior.value = n.ior, t.refractionRatio.value = n.refractionRatio), n.lightMap && (t.lightMap.value = n.lightMap, t.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (t.aoMap.value = n.aoMap, t.aoMapIntensity.value = n.aoMapIntensity), n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ? r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n.clearcoatNormalMap ? r = n.clearcoatNormalMap : n.clearcoatRoughnessMap ? r = n.clearcoatRoughnessMap : n.specularIntensityMap ? r = n.specularIntensityMap : n.specularColorMap ? r = n.specularColorMap : n.transmissionMap ? r = n.transmissionMap : n.thicknessMap ? r = n.thicknessMap : n.sheenColorMap ? r = n.sheenColorMap : n.sheenRoughnessMap && (r = n.sheenRoughnessMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix)), n.aoMap ? a = n.aoMap : n.lightMap && (a = n.lightMap), void 0 !== a && (a.isWebGLRenderTarget && (a = a.texture), !0 === a.matrixAutoUpdate && a.updateMatrix(), t.uv2Transform.value.copy(a.matrix))
                }
                function n(t, n) {
                    t.roughness.value = n.roughness, t.metalness.value = n.metalness, n.roughnessMap && (t.roughnessMap.value = n.roughnessMap), n.metalnessMap && (t.metalnessMap.value = n.metalnessMap), n.emissiveMap && (t.emissiveMap.value = n.emissiveMap), n.bumpMap && (t.bumpMap.value = n.bumpMap, t.bumpScale.value = n.bumpScale, 1 === n.side && (t.bumpScale.value *= -1)), n.normalMap && (t.normalMap.value = n.normalMap, t.normalScale.value.copy(n.normalScale), 1 === n.side && t.normalScale.value.negate()), n.displacementMap && (t.displacementMap.value = n.displacementMap, t.displacementScale.value = n.displacementScale, t.displacementBias.value = n.displacementBias), e.get(n).envMap && (t.envMapIntensity.value = n.envMapIntensity)
                }
                return {
                    refreshFogUniforms: function (e, t) {
                        e.fogColor.value.copy(t.color), t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density)
                    },
                    refreshMaterialUniforms: function (e, i, r, a, s) {
                        i.isMeshBasicMaterial ? t(e, i) : i.isMeshLambertMaterial ? (t(e, i), function (e, t) {
                            t.emissiveMap && (e.emissiveMap.value = t.emissiveMap)
                        }(e, i)) : i.isMeshToonMaterial ? (t(e, i), function (e, t) {
                            t.gradientMap && (e.gradientMap.value = t.gradientMap), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                        }(e, i)) : i.isMeshPhongMaterial ? (t(e, i), function (e, t) {
                            e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                        }(e, i)) : i.isMeshStandardMaterial ? (t(e, i), i.isMeshPhysicalMaterial ? function (e, t, i) {
                            n(e, t), e.ior.value = t.ior, t.sheen > 0 && (e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen), e.sheenRoughness.value = t.sheenRoughness, t.sheenColorMap && (e.sheenColorMap.value = t.sheenColorMap), t.sheenRoughnessMap && (e.sheenRoughnessMap.value = t.sheenRoughnessMap)), t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap), t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap), t.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), e.clearcoatNormalMap.value = t.clearcoatNormalMap, 1 === t.side && e.clearcoatNormalScale.value.negate())), t.transmission > 0 && (e.transmission.value = t.transmission, e.transmissionSamplerMap.value = i.texture, e.transmissionSamplerSize.value.set(i.width, i.height), t.transmissionMap && (e.transmissionMap.value = t.transmissionMap), e.thickness.value = t.thickness, t.thicknessMap && (e.thicknessMap.value = t.thicknessMap), e.attenuationDistance.value = t.attenuationDistance, e.attenuationColor.value.copy(t.attenuationColor)), e.specularIntensity.value = t.specularIntensity, e.specularColor.value.copy(t.specularColor), t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap), t.specularColorMap && (e.specularColorMap.value = t.specularColorMap)
                        }(e, i, s) : n(e, i)) : i.isMeshMatcapMaterial ? (t(e, i), function (e, t) {
                            t.matcap && (e.matcap.value = t.matcap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                        }(e, i)) : i.isMeshDepthMaterial ? (t(e, i), function (e, t) {
                            t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                        }(e, i)) : i.isMeshDistanceMaterial ? (t(e, i), function (e, t) {
                            t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), e.referencePosition.value.copy(t.referencePosition), e.nearDistance.value = t.nearDistance, e.farDistance.value = t.farDistance
                        }(e, i)) : i.isMeshNormalMaterial ? (t(e, i), function (e, t) {
                            t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                        }(e, i)) : i.isLineBasicMaterial ? (function (e, t) {
                            e.diffuse.value.copy(t.color), e.opacity.value = t.opacity
                        }(e, i), i.isLineDashedMaterial && function (e, t) {
                            e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale
                        }(e, i)) : i.isPointsMaterial ? function (e, t, n, i) {
                            let r;
                            e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.size.value = t.size * n, e.scale.value = .5 * i, t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest), t.map ? r = t.map : t.alphaMap && (r = t.alphaMap), void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix))
                        }(e, i, r, a) : i.isSpriteMaterial ? function (e, t) {
                            let n;
                            e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.rotation.value = t.rotation, t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest), t.map ? n = t.map : t.alphaMap && (n = t.alphaMap), void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), e.uvTransform.value.copy(n.matrix))
                        }(e, i) : i.isShadowMaterial ? (e.color.value.copy(i.color), e.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = false)
                    }
                }
            }
            function qa(e = {}) {
                const t = void 0 !== e.canvas ? e.canvas : function () {
                        const e = _e("canvas");
                        return e.style.display = "block", e
                    }(),
                    n = void 0 !== e.context ? e.context : null,
                    i = void 0 !== e.alpha && e.alpha,
                    r = void 0 === e.depth || e.depth,
                    a = void 0 === e.stencil || e.stencil,
                    s = void 0 !== e.antialias && e.antialias,
                    o = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
                    l = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
                    c = void 0 !== e.powerPreference ? e.powerPreference : "default",
                    u = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat;
                let d = null,
                    f = null;
                const m = [],
                    g = [];
                this.domElement = t, this.debug = {
                    checkShaderErrors: true
                }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this.gammaFactor = 2, this.outputEncoding = X, this.physicallyCorrectLights = false, this.toneMapping = 0, this.toneMappingExposure = 1;
                const v = this;
                let b = false,
                    _ = 0,
                    M = 0,
                    T = null,
                    A = -1,
                    L = null;
                const R = new Le,
                    P = new Le;
                let C = null,
                    I = t.width,
                    F = t.height,
                    D = 1,
                    N = null,
                    O = null;
                const H = new Le(0, 0, I, F),
                    U = new Le(0, 0, I, F);
                let B = false;
                const z = [],
                    k = new oi;
                let G = false,
                    V = false,
                    j = null;
                const W = new ut,
                    Y = new Fe,
                    q = {
                        background: null,
                        fog: null,
                        environment: null,
                        overrideMaterial: null,
                        isScene: true
                    };
                function Q() {
                    return null === T ? D : 1
                }
                let J, Z, K, $, ee, te, ne, ie, re, ae, se, oe, le, ce, ue, he, de, pe, fe, me, ge, ve, ye, xe = n;
                function be(e, n) {
                    for (let i = 0; i < e.length; i++) {
                        const r = e[i],
                            a = t.getContext(r, n);
                        if (null !== a) return a
                    }
                    return null
                }
                try {
                    const e = {
                        alpha: i,
                        depth: r,
                        stencil: a,
                        antialias: s,
                        premultipliedAlpha: o,
                        preserveDrawingBuffer: l,
                        powerPreference: c,
                        failIfMajorPerformanceCaveat: u
                    };
                    if ("setAttribute" in t && t.setAttribute("data-engine", "three.js r135"), t.addEventListener("webglcontextlost", Me, false), t.addEventListener("webglcontextrestored", Te, false), null === xe) {
                        const t = ["webgl2", "webgl", "experimental-webgl"];
                        if (!0 === v.isWebGL1Renderer && t.shift(), xe = be(t, e), null === xe) throw be(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                    }
                    void 0 === xe.getShaderPrecisionFormat && (xe.getShaderPrecisionFormat = function () {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    })
                } catch (e) {
                    throw console.error("THREE.WebGLRenderer: " + e.message), e
                }
                function we() {
                    J = new Gi(xe), Z = new vi(xe, J, e), J.init(Z), ve = new za(xe, J, Z), K = new Ua(xe, J, Z), z[0] = 1029, $ = new Wi(xe), ee = new Ma, te = new Ba(xe, J, K, ee, Z, ve, $), ne = new xi(v), ie = new ki(v), re = new ci(xe, Z), ye = new mi(xe, J, re, Z), ae = new Vi(xe, re, $, ye), se = new Zi(xe, ae, re, $), fe = new Ji(xe, Z, te), he = new yi(ee), oe = new Ea(v, ne, ie, J, Z, ye, he), le = new Ya(ee), ce = new La(ee), ue = new Da(J, Z), pe = new fi(v, ne, K, se, o), de = new Ha(v, se, Z), me = new gi(xe, J, $, Z), ge = new ji(xe, J, $, Z), $.programs = oe.programs, v.capabilities = Z, v.extensions = J, v.properties = ee, v.renderLists = ce, v.shadowMap = de, v.state = K, v.info = $
                }
                we();
                const Ee = new Xa(v, xe);
                function Me(e) {
                    e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), b = true
                }
                function Te() {
                    console.log("THREE.WebGLRenderer: Context Restored."), b = false;
                    const e = $.autoReset,
                        t = de.enabled,
                        n = de.autoUpdate,
                        i = de.needsUpdate,
                        r = de.type;
                    we(), $.autoReset = e, de.enabled = t, de.autoUpdate = n, de.needsUpdate = i, de.type = r
                }
                function Se(e) {
                    const t = e.target;
                    t.removeEventListener("dispose", Se),
                        function (e) {
                            (function (e) {
                                const t = ee.get(e).programs;
                                void 0 !== t && t.forEach((function (e) {
                                    oe.releaseProgram(e)
                                }))
                            })(e), ee.remove(e)
                        }(t)
                }
                this.xr = Ee, this.getContext = function () {
                    return xe
                }, this.getContextAttributes = function () {
                    return xe.getContextAttributes()
                }, this.forceContextLoss = function () {
                    const e = J.get("WEBGL_lose_context");
                    e && e.loseContext()
                }, this.forceContextRestore = function () {
                    const e = J.get("WEBGL_lose_context");
                    e && e.restoreContext()
                }, this.getPixelRatio = function () {
                    return D
                }, this.setPixelRatio = function (e) {
                    void 0 !== e && (D = e, this.setSize(I, F, false))
                }, this.getSize = function (e) {
                    return e.set(I, F)
                }, this.setSize = function (e, n, i) {
                    Ee.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (I = e, F = n, t.width = Math.floor(e * D), t.height = Math.floor(n * D), !1 !== i && (t.style.width = e + "px", t.style.height = n + "px"), this.setViewport(0, 0, e, n))
                }, this.getDrawingBufferSize = function (e) {
                    return e.set(I * D, F * D).floor()
                }, this.setDrawingBufferSize = function (e, n, i) {
                    I = e, F = n, D = i, t.width = Math.floor(e * i), t.height = Math.floor(n * i), this.setViewport(0, 0, e, n)
                }, this.getCurrentViewport = function (e) {
                    return e.copy(R)
                }, this.getViewport = function (e) {
                    return e.copy(H)
                }, this.setViewport = function (e, t, n, i) {
                    e.isVector4 ? H.set(e.x, e.y, e.z, e.w) : H.set(e, t, n, i), K.viewport(R.copy(H).multiplyScalar(D).floor())
                }, this.getScissor = function (e) {
                    return e.copy(U)
                }, this.setScissor = function (e, t, n, i) {
                    e.isVector4 ? U.set(e.x, e.y, e.z, e.w) : U.set(e, t, n, i), K.scissor(P.copy(U).multiplyScalar(D).floor())
                }, this.getScissorTest = function () {
                    return B
                }, this.setScissorTest = function (e) {
                    K.setScissorTest(B = e)
                }, this.setOpaqueSort = function (e) {
                    N = e
                }, this.setTransparentSort = function (e) {
                    O = e
                }, this.getClearColor = function (e) {
                    return e.copy(pe.getClearColor())
                }, this.setClearColor = function () {
                    pe.setClearColor.apply(pe, arguments)
                }, this.getClearAlpha = function () {
                    return pe.getClearAlpha()
                }, this.setClearAlpha = function () {
                    pe.setClearAlpha.apply(pe, arguments)
                }, this.clear = function (e, t, n) {
                    let i = 0;
                    (void 0 === e || e) && (i |= 16384), (void 0 === t || t) && (i |= 256), (void 0 === n || n) && (i |= 1024), xe.clear(i)
                }, this.clearColor = function () {
                    this.clear(true, false, false)
                }, this.clearDepth = function () {
                    this.clear(false, true, false)
                }, this.clearStencil = function () {
                    this.clear(false, false, true)
                }, this.dispose = function () {
                    t.removeEventListener("webglcontextlost", Me, false), t.removeEventListener("webglcontextrestored", Te, false), ce.dispose(), ue.dispose(), ee.dispose(), ne.dispose(), ie.dispose(), se.dispose(), ye.dispose(), Ee.dispose(), Ee.removeEventListener("sessionstart", Pe), Ee.removeEventListener("sessionend", Ie), j && (j.dispose(), j = null), De.stop()
                }, this.renderBufferDirect = function (e, t, n, i, r, a) {
                    null === t && (t = q);
                    const s = r.isMesh && r.matrixWorld.determinant() < 0,
                        o = function (e, t, n, i, r) {
                            !0 !== t.isScene && (t = q), te.resetTextureUnits();
                            const a = t.fog,
                                s = i.isMeshStandardMaterial ? t.environment : null,
                                o = null === T ? v.outputEncoding : T.texture.encoding,
                                l = (i.isMeshStandardMaterial ? ie : ne).get(i.envMap || s),
                                c = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
                                u = !!i.normalMap && !!n.attributes.tangent,
                                h = !!n.morphAttributes.position,
                                d = !!n.morphAttributes.normal,
                                p = n.morphAttributes.position ? n.morphAttributes.position.length : 0,
                                m = ee.get(i),
                                g = f.state.lights;
                            if (!0 === G && (!0 === V || e !== L)) {
                                const t = e === L && i.id === A;
                                he.setState(i, e, t)
                            }
                            let y = false;
                            i.version === m.__version ? m.needsLights && m.lightsStateVersion !== g.state.version || m.outputEncoding !== o || r.isInstancedMesh && !1 === m.instancing ? y = !0 : r.isInstancedMesh || !0 !== m.instancing ? r.isSkinnedMesh && !1 === m.skinning ? y = !0 : r.isSkinnedMesh || !0 !== m.skinning ? m.envMap !== l || i.fog && m.fog !== a ? y = !0 : void 0 === m.numClippingPlanes || m.numClippingPlanes === he.numPlanes && m.numIntersection === he.numIntersection ? (m.vertexAlphas !== c || m.vertexTangents !== u || m.morphTargets !== h || m.morphNormals !== d || !0 === Z.isWebGL2 && m.morphTargetsCount !== p) && (y = true) : y = !0 : y = !0 : y = !0 : (y = true, m.__version = i.version);
                            let x = m.currentProgram;
                            !0 === y && (x = Be(i, t, r));
                            let b = false,
                                _ = false,
                                w = false;
                            const E = x.getUniforms(),
                                M = m.uniforms;
                            if (K.useProgram(x.program) && (b = true, _ = true, w = true), i.id !== A && (A = i.id, _ = true), b || L !== e) {
                                if (E.setValue(xe, "projectionMatrix", e.projectionMatrix), Z.logarithmicDepthBuffer && E.setValue(xe, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), L !== e && (L = e, _ = true, w = true), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) {
                                    const t = E.map.cameraPosition;
                                    void 0 !== t && t.setValue(xe, Y.setFromMatrixPosition(e.matrixWorld))
                                }(i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && E.setValue(xe, "isOrthographic", !0 === e.isOrthographicCamera), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || r.isSkinnedMesh) && E.setValue(xe, "viewMatrix", e.matrixWorldInverse)
                            }
                            if (r.isSkinnedMesh) {
                                E.setOptional(xe, r, "bindMatrix"), E.setOptional(xe, r, "bindMatrixInverse");
                                const e = r.skeleton;
                                e && (Z.floatVertexTextures ? (null === e.boneTexture && e.computeBoneTexture(), E.setValue(xe, "boneTexture", e.boneTexture, te), E.setValue(xe, "boneTextureSize", e.boneTextureSize)) : E.setOptional(xe, e, "boneMatrices"))
                            }
                            var S, R;
                            return !n || void 0 === n.morphAttributes.position && void 0 === n.morphAttributes.normal || fe.update(r, n, i, x), (_ || m.receiveShadow !== r.receiveShadow) && (m.receiveShadow = r.receiveShadow, E.setValue(xe, "receiveShadow", r.receiveShadow)), _ && (E.setValue(xe, "toneMappingExposure", v.toneMappingExposure), m.needsLights && (R = w, (S = M).ambientLightColor.needsUpdate = R, S.lightProbe.needsUpdate = R, S.directionalLights.needsUpdate = R, S.directionalLightShadows.needsUpdate = R, S.pointLights.needsUpdate = R, S.pointLightShadows.needsUpdate = R, S.spotLights.needsUpdate = R, S.spotLightShadows.needsUpdate = R, S.rectAreaLights.needsUpdate = R, S.hemisphereLights.needsUpdate = R), a && i.fog && le.refreshFogUniforms(M, a), le.refreshMaterialUniforms(M, i, D, F, j), na.upload(xe, m.uniformsList, M, te)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (na.upload(xe, m.uniformsList, M, te), i.uniformsNeedUpdate = false), i.isSpriteMaterial && E.setValue(xe, "center", r.center), E.setValue(xe, "modelViewMatrix", r.modelViewMatrix), E.setValue(xe, "normalMatrix", r.normalMatrix), E.setValue(xe, "modelMatrix", r.matrixWorld), x
                        }(e, t, n, i, r);
                    K.setMaterial(i, s);
                    let l = n.index;
                    const c = n.attributes.position;
                    if (null === l) {
                        if (void 0 === c || 0 === c.count) return
                    } else if (0 === l.count) return;
                    let u, h = 1;
                    !0 === i.wireframe && (l = ae.getWireframeAttribute(n), h = 2), ye.setup(r, i, o, n, l);
                    let d = me;
                    null !== l && (u = re.get(l), d = ge, d.setIndex(u));
                    const p = null !== l ? l.count : c.count,
                        m = n.drawRange.start * h,
                        g = n.drawRange.count * h,
                        y = null !== a ? a.start * h : 0,
                        x = null !== a ? a.count * h : 1 / 0,
                        b = Math.max(m, y),
                        _ = Math.min(p, m + g, y + x) - 1,
                        w = Math.max(0, _ - b + 1);
                    if (0 !== w) {
                        if (r.isMesh) !0 === i.wireframe ? (K.setLineWidth(i.wireframeLinewidth * Q()), d.setMode(1)) : d.setMode(4);
                        else if (r.isLine) {
                            let e = i.linewidth;
                            void 0 === e && (e = 1), K.setLineWidth(e * Q()), r.isLineSegments ? d.setMode(1) : r.isLineLoop ? d.setMode(2) : d.setMode(3)
                        } else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
                        if (r.isInstancedMesh) d.renderInstances(b, w, r.count);
                        else if (n.isInstancedBufferGeometry) {
                            const e = Math.min(n.instanceCount, n._maxInstanceCount);
                            d.renderInstances(b, w, e)
                        } else d.render(b, w)
                    }
                }, this.compile = function (e, t) {
                    f = ue.get(e), f.init(), g.push(f), e.traverseVisible((function (e) {
                        e.isLight && e.layers.test(t.layers) && (f.pushLight(e), e.castShadow && f.pushShadow(e))
                    })), f.setupLights(v.physicallyCorrectLights), e.traverse((function (t) {
                        const n = t.material;
                        if (n)
                            if (Array.isArray(n))
                                for (let i = 0; i < n.length; i++) Be(n[i], e, t);
                            else Be(n, e, t)
                    })), g.pop(), f = null
                };
                let Ae = null;
                function Pe() {
                    De.stop()
                }
                function Ie() {
                    De.start()
                }
                const De = new li;
                function Ne(e, t, n, i) {
                    if (!1 === e.visible) return;
                    if (e.layers.test(t.layers))
                        if (e.isGroup) n = e.renderOrder;
                        else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
                    else if (e.isLight) f.pushLight(e), e.castShadow && f.pushShadow(e);
                    else if (e.isSprite) {
                        if (!e.frustumCulled || k.intersectsSprite(e)) {
                            i && Y.setFromMatrixPosition(e.matrixWorld).applyMatrix4(W);
                            const t = se.update(e),
                                r = e.material;
                            r.visible && d.push(e, t, r, n, Y.z, null)
                        }
                    } else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== $.render.frame && (e.skeleton.update(), e.skeleton.frame = $.render.frame), !e.frustumCulled || k.intersectsObject(e))) {
                        i && Y.setFromMatrixPosition(e.matrixWorld).applyMatrix4(W);
                        const t = se.update(e),
                            r = e.material;
                        if (Array.isArray(r)) {
                            const i = t.groups;
                            for (let a = 0, s = i.length; a < s; a++) {
                                const s = i[a],
                                    o = r[s.materialIndex];
                                o && o.visible && d.push(e, t, o, n, Y.z, s)
                            }
                        } else r.visible && d.push(e, t, r, n, Y.z, null)
                    }
                    const r = e.children;
                    for (let e = 0, a = r.length; e < a; e++) Ne(r[e], t, n, i)
                }
                function Oe(e, t, n, i) {
                    const r = e.opaque,
                        a = e.transmissive,
                        o = e.transparent;
                    f.setupLightsView(n), a.length > 0 && function (e, t, n) {
                        if (null === j) {
                            const e = !0 === s && !0 === Z.isWebGL2;
                            j = new(e ? Ce : Re)(1024, 1024, {
                                generateMipmaps: true,
                                type: null !== ve.convert(E) ? E : x,
                                minFilter: y,
                                magFilter: p,
                                wrapS: h,
                                wrapT: h,
                                useRenderToTexture: J.has("WEBGL_multisampled_render_to_texture")
                            })
                        }
                        const i = v.getRenderTarget();
                        v.setRenderTarget(j), v.clear();
                        const r = v.toneMapping;
                        v.toneMapping = 0, He(e, t, n), v.toneMapping = r, te.updateMultisampleRenderTarget(j), te.updateRenderTargetMipmap(j), v.setRenderTarget(i)
                    }(r, t, n), i && K.viewport(R.copy(i)), r.length > 0 && He(r, t, n), a.length > 0 && He(a, t, n), o.length > 0 && He(o, t, n)
                }
                function He(e, t, n) {
                    const i = !0 === t.isScene ? t.overrideMaterial : null;
                    for (let r = 0, a = e.length; r < a; r++) {
                        const a = e[r],
                            s = a.object,
                            o = a.geometry,
                            l = null === i ? a.material : i,
                            c = a.group;
                        s.layers.test(n.layers) && Ue(s, t, n, o, l, c)
                    }
                }
                function Ue(e, t, n, i, r, a) {
                    e.onBeforeRender(v, t, n, i, r, a), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), r.onBeforeRender(v, t, n, i, e, a), !0 === r.transparent && 2 === r.side ? (r.side = 1, r.needsUpdate = true, v.renderBufferDirect(n, t, i, r, e, a), r.side = 0, r.needsUpdate = true, v.renderBufferDirect(n, t, i, r, e, a), r.side = 2) : v.renderBufferDirect(n, t, i, r, e, a), e.onAfterRender(v, t, n, i, r, a)
                }
                function Be(e, t, n) {
                    !0 !== t.isScene && (t = q);
                    const i = ee.get(e),
                        r = f.state.lights,
                        a = f.state.shadowsArray,
                        s = r.state.version,
                        o = oe.getParameters(e, r.state, a, t, n),
                        l = oe.getProgramCacheKey(o);
                    let c = i.programs;
                    i.environment = e.isMeshStandardMaterial ? t.environment : null, i.fog = t.fog, i.envMap = (e.isMeshStandardMaterial ? ie : ne).get(e.envMap || i.environment), void 0 === c && (e.addEventListener("dispose", Se), c = new Map, i.programs = c);
                    let u = c.get(l);
                    if (void 0 !== u) {
                        if (i.currentProgram === u && i.lightsStateVersion === s) return ze(e, o), u
                    } else o.uniforms = oe.getUniforms(e), e.onBuild(n, o, v), e.onBeforeCompile(o, v), u = oe.acquireProgram(o, l), c.set(l, u), i.uniforms = o.uniforms;
                    const h = i.uniforms;
                    (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (h.clippingPlanes = he.uniform), ze(e, o), i.needsLights = function (e) {
                        return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
                    }(e), i.lightsStateVersion = s, i.needsLights && (h.ambientLightColor.value = r.state.ambient, h.lightProbe.value = r.state.probe, h.directionalLights.value = r.state.directional, h.directionalLightShadows.value = r.state.directionalShadow, h.spotLights.value = r.state.spot, h.spotLightShadows.value = r.state.spotShadow, h.rectAreaLights.value = r.state.rectArea, h.ltc_1.value = r.state.rectAreaLTC1, h.ltc_2.value = r.state.rectAreaLTC2, h.pointLights.value = r.state.point, h.pointLightShadows.value = r.state.pointShadow, h.hemisphereLights.value = r.state.hemi, h.directionalShadowMap.value = r.state.directionalShadowMap, h.directionalShadowMatrix.value = r.state.directionalShadowMatrix, h.spotShadowMap.value = r.state.spotShadowMap, h.spotShadowMatrix.value = r.state.spotShadowMatrix, h.pointShadowMap.value = r.state.pointShadowMap, h.pointShadowMatrix.value = r.state.pointShadowMatrix);
                    const d = u.getUniforms(),
                        p = na.seqWithValue(d.seq, h);
                    return i.currentProgram = u, i.uniformsList = p, u
                }
                function ze(e, t) {
                    const n = ee.get(e);
                    n.outputEncoding = t.outputEncoding, n.instancing = t.instancing, n.skinning = t.skinning, n.morphTargets = t.morphTargets, n.morphNormals = t.morphNormals, n.morphTargetsCount = t.morphTargetsCount, n.numClippingPlanes = t.numClippingPlanes, n.numIntersection = t.numClipIntersection, n.vertexAlphas = t.vertexAlphas, n.vertexTangents = t.vertexTangents
                }
                De.setAnimationLoop((function (e) {
                    Ae && Ae(e)
                })), "undefined" != typeof window && De.setContext(window), this.setAnimationLoop = function (e) {
                    Ae = e, Ee.setAnimationLoop(e), null === e ? De.stop() : De.start()
                }, Ee.addEventListener("sessionstart", Pe), Ee.addEventListener("sessionend", Ie), this.render = function (e, t) {
                    if (void 0 !== t && !0 !== t.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    if (!0 === b) return;
                    !0 === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), !0 === Ee.enabled && !0 === Ee.isPresenting && (!0 === Ee.cameraAutoUpdate && Ee.updateCamera(t), t = Ee.getCamera()), !0 === e.isScene && e.onBeforeRender(v, e, t, T), f = ue.get(e, g.length), f.init(), g.push(f), W.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), k.setFromProjectionMatrix(W), V = this.localClippingEnabled, G = he.init(this.clippingPlanes, V, t), d = ce.get(e, m.length), d.init(), m.push(d), Ne(e, t, 0, v.sortObjects), d.finish(), !0 === v.sortObjects && d.sort(N, O), !0 === G && he.beginShadows();
                    const n = f.state.shadowsArray;
                    if (de.render(n, e, t), !0 === G && he.endShadows(), !0 === this.info.autoReset && this.info.reset(), pe.render(d, e), f.setupLights(v.physicallyCorrectLights), t.isArrayCamera) {
                        const n = t.cameras;
                        for (let t = 0, i = n.length; t < i; t++) {
                            const i = n[t];
                            Oe(d, e, i, i.viewport)
                        }
                    } else Oe(d, e, t);
                    null !== T && (te.updateMultisampleRenderTarget(T), te.updateRenderTargetMipmap(T)), !0 === e.isScene && e.onAfterRender(v, e, t), K.buffers.depth.setTest(true), K.buffers.depth.setMask(true), K.buffers.color.setMask(true), K.setPolygonOffset(false), ye.resetDefaultState(), A = -1, L = null, g.pop(), f = g.length > 0 ? g[g.length - 1] : null, m.pop(), d = m.length > 0 ? m[m.length - 1] : null
                }, this.getActiveCubeFace = function () {
                    return _
                }, this.getActiveMipmapLevel = function () {
                    return M
                }, this.getRenderTarget = function () {
                    return T
                }, this.setRenderTargetTextures = function (e, t, n) {
                    ee.get(e.texture).__webglTexture = t, ee.get(e.depthTexture).__webglTexture = n;
                    const i = ee.get(e);
                    i.__hasExternalTextures = true, i.__hasExternalTextures && (i.__autoAllocateDepthBuffer = void 0 === n, i.__autoAllocateDepthBuffer || e.useRenderToTexture && (console.warn("render-to-texture extension was disabled because an external texture was provided"), e.useRenderToTexture = false, e.useRenderbuffer = true))
                }, this.setRenderTargetFramebuffer = function (e, t) {
                    const n = ee.get(e);
                    n.__webglFramebuffer = t, n.__useDefaultFramebuffer = void 0 === t
                }, this.setRenderTarget = function (e, t = 0, n = 0) {
                    T = e, _ = t, M = n;
                    let i = true;
                    if (e) {
                        const t = ee.get(e);
                        void 0 !== t.__useDefaultFramebuffer ? (K.bindFramebuffer(36160, null), i = false) : void 0 === t.__webglFramebuffer ? te.setupRenderTarget(e) : t.__hasExternalTextures && te.rebindTextures(e, ee.get(e.texture).__webglTexture, ee.get(e.depthTexture).__webglTexture)
                    }
                    let r = null,
                        a = false,
                        s = false;
                    if (e) {
                        const n = e.texture;
                        (n.isDataTexture3D || n.isDataTexture2DArray) && (s = true);
                        const i = ee.get(e).__webglFramebuffer;
                        e.isWebGLCubeRenderTarget ? (r = i[t], a = true) : r = e.useRenderbuffer ? ee.get(e).__webglMultisampledFramebuffer : i, R.copy(e.viewport), P.copy(e.scissor), C = e.scissorTest
                    } else R.copy(H).multiplyScalar(D).floor(), P.copy(U).multiplyScalar(D).floor(), C = B;
                    if (K.bindFramebuffer(36160, r) && Z.drawBuffers && i) {
                        let t = false;
                        if (e)
                            if (e.isWebGLMultipleRenderTargets) {
                                const n = e.texture;
                                if (z.length !== n.length || 36064 !== z[0]) {
                                    for (let e = 0, t = n.length; e < t; e++) z[e] = 36064 + e;
                                    z.length = n.length, t = true
                                }
                            } else 1 === z.length && 36064 === z[0] || (z[0] = 36064, z.length = 1, t = true);
                        else 1 === z.length && 1029 === z[0] || (z[0] = 1029, z.length = 1, t = true);
                        t && (Z.isWebGL2 ? xe.drawBuffers(z) : J.get("WEBGL_draw_buffers").drawBuffersWEBGL(z))
                    }
                    if (K.viewport(R), K.scissor(P), K.setScissorTest(C), a) {
                        const i = ee.get(e.texture);
                        xe.framebufferTexture2D(36160, 36064, 34069 + t, i.__webglTexture, n)
                    } else if (s) {
                        const i = ee.get(e.texture),
                            r = t || 0;
                        xe.framebufferTextureLayer(36160, 36064, i.__webglTexture, n || 0, r)
                    }
                    A = -1
                }, this.readRenderTargetPixels = function (e, t, n, i, r, a, s) {
                    if (!e || !e.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    let o = ee.get(e).__webglFramebuffer;
                    if (e.isWebGLCubeRenderTarget && void 0 !== s && (o = o[s]), o) {
                        K.bindFramebuffer(36160, o);
                        try {
                            const s = e.texture,
                                o = s.format,
                                l = s.type;
                            if (o !== S && ve.convert(o) !== xe.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            const c = l === E && (J.has("EXT_color_buffer_half_float") || Z.isWebGL2 && J.has("EXT_color_buffer_float"));
                            if (!(l === x || ve.convert(l) === xe.getParameter(35738) || l === w && (Z.isWebGL2 || J.has("OES_texture_float") || J.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            36053 === xe.checkFramebufferStatus(36160) ? t >= 0 && t <= e.width - i && n >= 0 && n <= e.height - r && xe.readPixels(t, n, i, r, ve.convert(o), ve.convert(l), a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                        } finally {
                            const e = null !== T ? ee.get(T).__webglFramebuffer : null;
                            K.bindFramebuffer(36160, e)
                        }
                    }
                }, this.copyFramebufferToTexture = function (e, t, n = 0) {
                    const i = Math.pow(2, -n),
                        r = Math.floor(t.image.width * i),
                        a = Math.floor(t.image.height * i);
                    let s = ve.convert(t.format);
                    Z.isWebGL2 && (6407 === s && (s = 32849), 6408 === s && (s = 32856)), te.setTexture2D(t, 0), xe.copyTexImage2D(3553, n, s, e.x, e.y, r, a, 0), K.unbindTexture()
                }, this.copyTextureToTexture = function (e, t, n, i = 0) {
                    const r = t.image.width,
                        a = t.image.height,
                        s = ve.convert(n.format),
                        o = ve.convert(n.type);
                    te.setTexture2D(n, 0), xe.pixelStorei(37440, n.flipY), xe.pixelStorei(37441, n.premultiplyAlpha), xe.pixelStorei(3317, n.unpackAlignment), t.isDataTexture ? xe.texSubImage2D(3553, i, e.x, e.y, r, a, s, o, t.image.data) : t.isCompressedTexture ? xe.compressedTexSubImage2D(3553, i, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, s, t.mipmaps[0].data) : xe.texSubImage2D(3553, i, e.x, e.y, s, o, t.image), 0 === i && n.generateMipmaps && xe.generateMipmap(3553), K.unbindTexture()
                }, this.copyTextureToTexture3D = function (e, t, n, i, r = 0) {
                    if (v.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                    const a = e.max.x - e.min.x + 1,
                        s = e.max.y - e.min.y + 1,
                        o = e.max.z - e.min.z + 1,
                        l = ve.convert(i.format),
                        c = ve.convert(i.type);
                    let u;
                    if (i.isDataTexture3D) te.setTexture3D(i, 0), u = 32879;
                    else {
                        if (!i.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                        te.setTexture2DArray(i, 0), u = 35866
                    }
                    xe.pixelStorei(37440, i.flipY), xe.pixelStorei(37441, i.premultiplyAlpha), xe.pixelStorei(3317, i.unpackAlignment);
                    const h = xe.getParameter(3314),
                        d = xe.getParameter(32878),
                        p = xe.getParameter(3316),
                        f = xe.getParameter(3315),
                        m = xe.getParameter(32877),
                        g = n.isCompressedTexture ? n.mipmaps[0] : n.image;
                    xe.pixelStorei(3314, g.width), xe.pixelStorei(32878, g.height), xe.pixelStorei(3316, e.min.x), xe.pixelStorei(3315, e.min.y), xe.pixelStorei(32877, e.min.z), n.isDataTexture || n.isDataTexture3D ? xe.texSubImage3D(u, r, t.x, t.y, t.z, a, s, o, l, c, g.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), xe.compressedTexSubImage3D(u, r, t.x, t.y, t.z, a, s, o, l, g.data)) : xe.texSubImage3D(u, r, t.x, t.y, t.z, a, s, o, l, c, g), xe.pixelStorei(3314, h), xe.pixelStorei(32878, d), xe.pixelStorei(3316, p), xe.pixelStorei(3315, f), xe.pixelStorei(32877, m), 0 === r && i.generateMipmaps && xe.generateMipmap(u), K.unbindTexture()
                }, this.initTexture = function (e) {
                    te.setTexture2D(e, 0), K.unbindTexture()
                }, this.resetState = function () {
                    _ = 0, M = 0, T = null, K.reset(), ye.reset()
                }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }
            qa.prototype.isWebGLRenderer = true;
            class Qa extends qa {}
            Qa.prototype.isWebGL1Renderer = true;
            class Ja {
                constructor(e, t = 25e-5) {
                    this.name = "", this.color = new tn(e), this.density = t
                }
                clone() {
                    return new Ja(this.color, this.density)
                }
                toJSON() {
                    return {
                        type: "FogExp2",
                        color: this.color.getHex(),
                        density: this.density
                    }
                }
            }
            Ja.prototype.isFogExp2 = true;
            class Za {
                constructor(e, t = 1, n = 1e3) {
                    this.name = "", this.color = new tn(e), this.near = t, this.far = n
                }
                clone() {
                    return new Za(this.color, this.near, this.far)
                }
                toJSON() {
                    return {
                        type: "Fog",
                        color: this.color.getHex(),
                        near: this.near,
                        far: this.far
                    }
                }
            }
            Za.prototype.isFog = true;
            class Ka extends Nt {
                constructor() {
                    super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = true, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                        detail: this
                    }))
                }
                copy(e, t) {
                    return super.copy(e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return null !== this.fog && (t.object.fog = this.fog.toJSON()), t
                }
            }
            Ka.prototype.isScene = true;
            class $a {
                constructor(e, t) {
                    this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = ee, this.updateRange = {
                        offset: 0,
                        count: -1
                    }, this.version = 0, this.uuid = le()
                }
                onUploadCallback() {}
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
                setUsage(e) {
                    return this.usage = e, this
                }
                copy(e) {
                    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
                }
                copyAt(e, t, n) {
                    e *= this.stride, n *= t.stride;
                    for (let i = 0, r = this.stride; i < r; i++) this.array[e + i] = t.array[n + i];
                    return this
                }
                set(e, t = 0) {
                    return this.array.set(e, t), this
                }
                clone(e) {
                    void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = le()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
                        n = new this.constructor(t, this.stride);
                    return n.setUsage(this.usage), n
                }
                onUpload(e) {
                    return this.onUploadCallback = e, this
                }
                toJSON(e) {
                    return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = le()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
                        uuid: this.uuid,
                        buffer: this.array.buffer._uuid,
                        type: this.array.constructor.name,
                        stride: this.stride
                    }
                }
            }
            $a.prototype.isInterleavedBuffer = true;
            const es = new Fe;
            class ts {
                constructor(e, t, n, i = false) {
                    this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = !0 === i
                }
                get count() {
                    return this.data.count
                }
                get array() {
                    return this.data.array
                }
                set needsUpdate(e) {
                    this.data.needsUpdate = e
                }
                applyMatrix4(e) {
                    for (let t = 0, n = this.data.count; t < n; t++) es.x = this.getX(t), es.y = this.getY(t), es.z = this.getZ(t), es.applyMatrix4(e), this.setXYZ(t, es.x, es.y, es.z);
                    return this
                }
                applyNormalMatrix(e) {
                    for (let t = 0, n = this.count; t < n; t++) es.x = this.getX(t), es.y = this.getY(t), es.z = this.getZ(t), es.applyNormalMatrix(e), this.setXYZ(t, es.x, es.y, es.z);
                    return this
                }
                transformDirection(e) {
                    for (let t = 0, n = this.count; t < n; t++) es.x = this.getX(t), es.y = this.getY(t), es.z = this.getZ(t), es.transformDirection(e), this.setXYZ(t, es.x, es.y, es.z);
                    return this
                }
                setX(e, t) {
                    return this.data.array[e * this.data.stride + this.offset] = t, this
                }
                setY(e, t) {
                    return this.data.array[e * this.data.stride + this.offset + 1] = t, this
                }
                setZ(e, t) {
                    return this.data.array[e * this.data.stride + this.offset + 2] = t, this
                }
                setW(e, t) {
                    return this.data.array[e * this.data.stride + this.offset + 3] = t, this
                }
                getX(e) {
                    return this.data.array[e * this.data.stride + this.offset]
                }
                getY(e) {
                    return this.data.array[e * this.data.stride + this.offset + 1]
                }
                getZ(e) {
                    return this.data.array[e * this.data.stride + this.offset + 2]
                }
                getW(e) {
                    return this.data.array[e * this.data.stride + this.offset + 3]
                }
                setXY(e, t, n) {
                    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
                }
                setXYZ(e, t, n, i) {
                    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this
                }
                setXYZW(e, t, n, i, r) {
                    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = r, this
                }
                clone(e) {
                    if (void 0 === e) {
                        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                        const e = [];
                        for (let t = 0; t < this.count; t++) {
                            const n = t * this.data.stride + this.offset;
                            for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[n + t])
                        }
                        return new sn(new this.array.constructor(e), this.itemSize, this.normalized)
                    }
                    return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new ts(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
                }
                toJSON(e) {
                    if (void 0 === e) {
                        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                        const e = [];
                        for (let t = 0; t < this.count; t++) {
                            const n = t * this.data.stride + this.offset;
                            for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[n + t])
                        }
                        return {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: e,
                            normalized: this.normalized
                        }
                    }
                    return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
                        isInterleavedBufferAttribute: true,
                        itemSize: this.itemSize,
                        data: this.data.uuid,
                        offset: this.offset,
                        normalized: this.normalized
                    }
                }
            }
            ts.prototype.isInterleavedBufferAttribute = true;
            class ns extends qt {
                constructor(e) {
                    super(), this.type = "SpriteMaterial", this.color = new tn(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = true, this.transparent = true, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this
                }
            }
            let is;
            ns.prototype.isSpriteMaterial = true;
            const rs = new Fe,
                as = new Fe,
                ss = new Fe,
                os = new ge,
                ls = new ge,
                cs = new ut,
                us = new Fe,
                hs = new Fe,
                ds = new Fe,
                ps = new ge,
                fs = new ge,
                ms = new ge;
            class gs extends Nt {
                constructor(e) {
                    if (super(), this.type = "Sprite", void 0 === is) {
                        is = new Mn;
                        const e = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                            t = new $a(e, 5);
                        is.setIndex([0, 1, 2, 0, 2, 3]), is.setAttribute("position", new ts(t, 3, 0, false)), is.setAttribute("uv", new ts(t, 2, 3, false))
                    }
                    this.geometry = is, this.material = void 0 !== e ? e : new ns, this.center = new ge(.5, .5)
                }
                raycast(e, t) {
                    null === e.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), as.setFromMatrixScale(this.matrixWorld), cs.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), ss.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && as.multiplyScalar(-ss.z);
                    const n = this.material.rotation;
                    let i, r;
                    0 !== n && (r = Math.cos(n), i = Math.sin(n));
                    const a = this.center;
                    vs(us.set(-.5, -.5, 0), ss, a, as, i, r), vs(hs.set(.5, -.5, 0), ss, a, as, i, r), vs(ds.set(.5, .5, 0), ss, a, as, i, r), ps.set(0, 0), fs.set(1, 0), ms.set(1, 1);
                    let s = e.ray.intersectTriangle(us, hs, ds, false, rs);
                    if (null === s && (vs(hs.set(-.5, .5, 0), ss, a, as, i, r), fs.set(0, 1), s = e.ray.intersectTriangle(us, ds, hs, false, rs), null === s)) return;
                    const o = e.ray.origin.distanceTo(rs);
                    o < e.near || o > e.far || t.push({
                        distance: o,
                        point: rs.clone(),
                        uv: Xt.getUV(rs, us, hs, ds, ps, fs, ms, new ge),
                        face: null,
                        object: this
                    })
                }
                copy(e) {
                    return super.copy(e), void 0 !== e.center && this.center.copy(e.center), this.material = e.material, this
                }
            }
            function vs(e, t, n, i, r, a) {
                os.subVectors(e, n).addScalar(.5).multiply(i), void 0 !== r ? (ls.x = a * os.x - r * os.y, ls.y = r * os.x + a * os.y) : ls.copy(os), e.copy(t), e.x += ls.x, e.y += ls.y, e.applyMatrix4(cs)
            }
            gs.prototype.isSprite = true;
            const ys = new Fe,
                xs = new Fe;
            class bs extends Nt {
                constructor() {
                    super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
                        levels: {
                            enumerable: true,
                            value: []
                        },
                        isLOD: {
                            value: true
                        }
                    }), this.autoUpdate = true
                }
                copy(e) {
                    super.copy(e, false);
                    const t = e.levels;
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e];
                        this.addLevel(n.object.clone(), n.distance)
                    }
                    return this.autoUpdate = e.autoUpdate, this
                }
                addLevel(e, t = 0) {
                    t = Math.abs(t);
                    const n = this.levels;
                    let i;
                    for (i = 0; i < n.length && !(t < n[i].distance); i++);
                    return n.splice(i, 0, {
                        distance: t,
                        object: e
                    }), this.add(e), this
                }
                getCurrentLevel() {
                    return this._currentLevel
                }
                getObjectForDistance(e) {
                    const t = this.levels;
                    if (t.length > 0) {
                        let n, i;
                        for (n = 1, i = t.length; n < i && !(e < t[n].distance); n++);
                        return t[n - 1].object
                    }
                    return null
                }
                raycast(e, t) {
                    if (this.levels.length > 0) {
                        ys.setFromMatrixPosition(this.matrixWorld);
                        const n = e.ray.origin.distanceTo(ys);
                        this.getObjectForDistance(n).raycast(e, t)
                    }
                }
                update(e) {
                    const t = this.levels;
                    if (t.length > 1) {
                        ys.setFromMatrixPosition(e.matrixWorld), xs.setFromMatrixPosition(this.matrixWorld);
                        const n = ys.distanceTo(xs) / e.zoom;
                        let i, r;
                        for (t[0].object.visible = true, i = 1, r = t.length; i < r && n >= t[i].distance; i++) t[i - 1].object.visible = false, t[i].object.visible = true;
                        for (this._currentLevel = i - 1; i < r; i++) t[i].object.visible = false
                    }
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    !1 === this.autoUpdate && (t.object.autoUpdate = false), t.object.levels = [];
                    const n = this.levels;
                    for (let e = 0, i = n.length; e < i; e++) {
                        const i = n[e];
                        t.object.levels.push({
                            object: i.object.uuid,
                            distance: i.distance
                        })
                    }
                    return t
                }
            }
            const _s = new Fe,
                ws = new Le,
                Es = new Le,
                Ms = new Fe,
                Ts = new ut;
            class Ss extends Gn {
                constructor(e, t) {
                    super(e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new ut, this.bindMatrixInverse = new ut
                }
                copy(e) {
                    return super.copy(e), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this
                }
                bind(e, t) {
                    this.skeleton = e, void 0 === t && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert()
                }
                pose() {
                    this.skeleton.pose()
                }
                normalizeSkinWeights() {
                    const e = new Le,
                        t = this.geometry.attributes.skinWeight;
                    for (let n = 0, i = t.count; n < i; n++) {
                        e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.w = t.getW(n);
                        const i = 1 / e.manhattanLength();
                        i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w)
                    }
                }
                updateMatrixWorld(e) {
                    super.updateMatrixWorld(e), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                }
                boneTransform(e, t) {
                    const n = this.skeleton,
                        i = this.geometry;
                    ws.fromBufferAttribute(i.attributes.skinIndex, e), Es.fromBufferAttribute(i.attributes.skinWeight, e), _s.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
                    for (let e = 0; e < 4; e++) {
                        const i = Es.getComponent(e);
                        if (0 !== i) {
                            const r = ws.getComponent(e);
                            Ts.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), t.addScaledVector(Ms.copy(_s).applyMatrix4(Ts), i)
                        }
                    }
                    return t.applyMatrix4(this.bindMatrixInverse)
                }
            }
            Ss.prototype.isSkinnedMesh = true;
            class As extends Nt {
                constructor() {
                    super(), this.type = "Bone"
                }
            }
            As.prototype.isBone = true;
            class Ls extends Se {
                constructor(e = null, t = 1, n = 1, i, r, a, s, o, l = 1003, c = 1003, u, h) {
                    super(null, a, s, o, l, c, i, r, u, h), this.image = {
                        data: e,
                        width: t,
                        height: n
                    }, this.magFilter = l, this.minFilter = c, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.needsUpdate = true
                }
            }
            Ls.prototype.isDataTexture = true;
            const Rs = new ut,
                Ps = new ut;
            class Cs {
                constructor(e = [], t = []) {
                    this.uuid = le(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init()
                }
                init() {
                    const e = this.bones,
                        t = this.boneInverses;
                    if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length) this.calculateInverses();
                    else if (e.length !== t.length) {
                        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                        for (let e = 0, t = this.bones.length; e < t; e++) this.boneInverses.push(new ut)
                    }
                }
                calculateInverses() {
                    this.boneInverses.length = 0;
                    for (let e = 0, t = this.bones.length; e < t; e++) {
                        const t = new ut;
                        this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(t)
                    }
                }
                pose() {
                    for (let e = 0, t = this.bones.length; e < t; e++) {
                        const t = this.bones[e];
                        t && t.matrixWorld.copy(this.boneInverses[e]).invert()
                    }
                    for (let e = 0, t = this.bones.length; e < t; e++) {
                        const t = this.bones[e];
                        t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
                    }
                }
                update() {
                    const e = this.bones,
                        t = this.boneInverses,
                        n = this.boneMatrices,
                        i = this.boneTexture;
                    for (let i = 0, r = e.length; i < r; i++) {
                        const r = e[i] ? e[i].matrixWorld : Ps;
                        Rs.multiplyMatrices(r, t[i]), Rs.toArray(n, 16 * i)
                    }
                    null !== i && (i.needsUpdate = true)
                }
                clone() {
                    return new Cs(this.bones, this.boneInverses)
                }
                computeBoneTexture() {
                    let e = Math.sqrt(4 * this.bones.length);
                    e = pe(e), e = Math.max(e, 4);
                    const t = new Float32Array(e * e * 4);
                    t.set(this.boneMatrices);
                    const n = new Ls(t, e, e, S, w);
                    return this.boneMatrices = t, this.boneTexture = n, this.boneTextureSize = e, this
                }
                getBoneByName(e) {
                    for (let t = 0, n = this.bones.length; t < n; t++) {
                        const n = this.bones[t];
                        if (n.name === e) return n
                    }
                }
                dispose() {
                    null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
                }
                fromJSON(e, t) {
                    this.uuid = e.uuid;
                    for (let n = 0, i = e.bones.length; n < i; n++) {
                        const i = e.bones[n];
                        let r = t[i];
                        void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", i), r = new As), this.bones.push(r), this.boneInverses.push((new ut).fromArray(e.boneInverses[n]))
                    }
                    return this.init(), this
                }
                toJSON() {
                    const e = {
                        metadata: {
                            version: 4.5,
                            type: "Skeleton",
                            generator: "Skeleton.toJSON"
                        },
                        bones: [],
                        boneInverses: []
                    };
                    e.uuid = this.uuid;
                    const t = this.bones,
                        n = this.boneInverses;
                    for (let i = 0, r = t.length; i < r; i++) {
                        const r = t[i];
                        e.bones.push(r.uuid);
                        const a = n[i];
                        e.boneInverses.push(a.toArray())
                    }
                    return e
                }
            }
            class Is extends sn {
                constructor(e, t, n, i = 1) {
                    "number" == typeof n && (i = n, n = false, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(e, t, n), this.meshPerAttribute = i
                }
                copy(e) {
                    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = true, e
                }
            }
            Is.prototype.isInstancedBufferAttribute = true;
            const Fs = new ut,
                Ds = new ut,
                Ns = [],
                Os = new Gn;
            class Hs extends Gn {
                constructor(e, t, n) {
                    super(e, t), this.instanceMatrix = new Is(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = false
                }
                copy(e) {
                    return super.copy(e), this.instanceMatrix.copy(e.instanceMatrix), null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this
                }
                getColorAt(e, t) {
                    t.fromArray(this.instanceColor.array, 3 * e)
                }
                getMatrixAt(e, t) {
                    t.fromArray(this.instanceMatrix.array, 16 * e)
                }
                raycast(e, t) {
                    const n = this.matrixWorld,
                        i = this.count;
                    if (Os.geometry = this.geometry, Os.material = this.material, void 0 !== Os.material)
                        for (let r = 0; r < i; r++) {
                            this.getMatrixAt(r, Fs), Ds.multiplyMatrices(n, Fs), Os.matrixWorld = Ds, Os.raycast(e, Ns);
                            for (let e = 0, n = Ns.length; e < n; e++) {
                                const n = Ns[e];
                                n.instanceId = r, n.object = this, t.push(n)
                            }
                            Ns.length = 0
                        }
                }
                setColorAt(e, t) {
                    null === this.instanceColor && (this.instanceColor = new Is(new Float32Array(3 * this.instanceMatrix.count), 3)), t.toArray(this.instanceColor.array, 3 * e)
                }
                setMatrixAt(e, t) {
                    t.toArray(this.instanceMatrix.array, 16 * e)
                }
                updateMorphTargets() {}
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            Hs.prototype.isInstancedMesh = true;
            class Us extends qt {
                constructor(e) {
                    super(), this.type = "LineBasicMaterial", this.color = new tn(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this
                }
            }
            Us.prototype.isLineBasicMaterial = true;
            const Bs = new Fe,
                zs = new Fe,
                ks = new ut,
                Gs = new ct,
                Vs = new tt;
            class js extends Nt {
                constructor(e = new Mn, t = new Us) {
                    super(), this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets()
                }
                copy(e) {
                    return super.copy(e), this.material = e.material, this.geometry = e.geometry, this
                }
                computeLineDistances() {
                    const e = this.geometry;
                    if (e.isBufferGeometry)
                        if (null === e.index) {
                            const t = e.attributes.position,
                                n = [0];
                            for (let e = 1, i = t.count; e < i; e++) Bs.fromBufferAttribute(t, e - 1), zs.fromBufferAttribute(t, e), n[e] = n[e - 1], n[e] += Bs.distanceTo(zs);
                            e.setAttribute("lineDistance", new mn(n, 1))
                        } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    else e.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                    return this
                }
                raycast(e, t) {
                    const n = this.geometry,
                        i = this.matrixWorld,
                        r = e.params.Line.threshold,
                        a = n.drawRange;
                    if (null === n.boundingSphere && n.computeBoundingSphere(), Vs.copy(n.boundingSphere), Vs.applyMatrix4(i), Vs.radius += r, !1 === e.ray.intersectsSphere(Vs)) return;
                    ks.copy(i).invert(), Gs.copy(e.ray).applyMatrix4(ks);
                    const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        o = s * s,
                        l = new Fe,
                        c = new Fe,
                        u = new Fe,
                        h = new Fe,
                        d = this.isLineSegments ? 2 : 1;
                    if (n.isBufferGeometry) {
                        const i = n.index,
                            r = n.attributes.position;
                        if (null !== i)
                            for (let n = Math.max(0, a.start), s = Math.min(i.count, a.start + a.count) - 1; n < s; n += d) {
                                const a = i.getX(n),
                                    s = i.getX(n + 1);
                                if (l.fromBufferAttribute(r, a), c.fromBufferAttribute(r, s), Gs.distanceSqToSegment(l, c, h, u) > o) continue;
                                h.applyMatrix4(this.matrixWorld);
                                const d = e.ray.origin.distanceTo(h);
                                d < e.near || d > e.far || t.push({
                                    distance: d,
                                    point: u.clone().applyMatrix4(this.matrixWorld),
                                    index: n,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            } else
                                for (let n = Math.max(0, a.start), i = Math.min(r.count, a.start + a.count) - 1; n < i; n += d) {
                                    if (l.fromBufferAttribute(r, n), c.fromBufferAttribute(r, n + 1), Gs.distanceSqToSegment(l, c, h, u) > o) continue;
                                    h.applyMatrix4(this.matrixWorld);
                                    const i = e.ray.origin.distanceTo(h);
                                    i < e.near || i > e.far || t.push({
                                        distance: i,
                                        point: u.clone().applyMatrix4(this.matrixWorld),
                                        index: n,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                                }
                    } else n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
                updateMorphTargets() {
                    const e = this.geometry;
                    if (e.isBufferGeometry) {
                        const t = e.morphAttributes,
                            n = Object.keys(t);
                        if (n.length > 0) {
                            const e = t[n[0]];
                            if (void 0 !== e) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (let t = 0, n = e.length; t < n; t++) {
                                    const n = e[t].name || String(t);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
                                }
                            }
                        }
                    } else {
                        const t = e.morphTargets;
                        void 0 !== t && t.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                }
            }
            js.prototype.isLine = true;
            const Ws = new Fe,
                Xs = new Fe;
            class Ys extends js {
                constructor(e, t) {
                    super(e, t), this.type = "LineSegments"
                }
                computeLineDistances() {
                    const e = this.geometry;
                    if (e.isBufferGeometry)
                        if (null === e.index) {
                            const t = e.attributes.position,
                                n = [];
                            for (let e = 0, i = t.count; e < i; e += 2) Ws.fromBufferAttribute(t, e), Xs.fromBufferAttribute(t, e + 1), n[e] = 0 === e ? 0 : n[e - 1], n[e + 1] = n[e] + Ws.distanceTo(Xs);
                            e.setAttribute("lineDistance", new mn(n, 1))
                        } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    else e.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                    return this
                }
            }
            Ys.prototype.isLineSegments = true;
            class qs extends js {
                constructor(e, t) {
                    super(e, t), this.type = "LineLoop"
                }
            }
            qs.prototype.isLineLoop = true;
            class Qs extends qt {
                constructor(e) {
                    super(), this.type = "PointsMaterial", this.color = new tn(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this
                }
            }
            Qs.prototype.isPointsMaterial = true;
            const Js = new ut,
                Zs = new ct,
                Ks = new tt,
                $s = new Fe;
            class eo extends Nt {
                constructor(e = new Mn, t = new Qs) {
                    super(), this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets()
                }
                copy(e) {
                    return super.copy(e), this.material = e.material, this.geometry = e.geometry, this
                }
                raycast(e, t) {
                    const n = this.geometry,
                        i = this.matrixWorld,
                        r = e.params.Points.threshold,
                        a = n.drawRange;
                    if (null === n.boundingSphere && n.computeBoundingSphere(), Ks.copy(n.boundingSphere), Ks.applyMatrix4(i), Ks.radius += r, !1 === e.ray.intersectsSphere(Ks)) return;
                    Js.copy(i).invert(), Zs.copy(e.ray).applyMatrix4(Js);
                    const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        o = s * s;
                    if (n.isBufferGeometry) {
                        const r = n.index,
                            s = n.attributes.position;
                        if (null !== r)
                            for (let n = Math.max(0, a.start), l = Math.min(r.count, a.start + a.count); n < l; n++) {
                                const a = r.getX(n);
                                $s.fromBufferAttribute(s, a), to($s, a, o, i, e, t, this)
                            } else
                                for (let n = Math.max(0, a.start), r = Math.min(s.count, a.start + a.count); n < r; n++) $s.fromBufferAttribute(s, n), to($s, n, o, i, e, t, this)
                    } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
                updateMorphTargets() {
                    const e = this.geometry;
                    if (e.isBufferGeometry) {
                        const t = e.morphAttributes,
                            n = Object.keys(t);
                        if (n.length > 0) {
                            const e = t[n[0]];
                            if (void 0 !== e) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (let t = 0, n = e.length; t < n; t++) {
                                    const n = e[t].name || String(t);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
                                }
                            }
                        }
                    } else {
                        const t = e.morphTargets;
                        void 0 !== t && t.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                }
            }
            function to(e, t, n, i, r, a, s) {
                const o = Zs.distanceSqToPoint(e);
                if (o < n) {
                    const n = new Fe;
                    Zs.closestPointToPoint(e, n), n.applyMatrix4(i);
                    const l = r.ray.origin.distanceTo(n);
                    if (l < r.near || l > r.far) return;
                    a.push({
                        distance: l,
                        distanceToRay: Math.sqrt(o),
                        point: n,
                        index: t,
                        face: null,
                        object: s
                    })
                }
            }
            eo.prototype.isPoints = true;
            class no extends Se {
                constructor(e, t, n, i, r, a, s, o, l) {
                    super(e, t, n, i, r, a, s, o, l), this.format = void 0 !== s ? s : T, this.minFilter = void 0 !== a ? a : g, this.magFilter = void 0 !== r ? r : g, this.generateMipmaps = false;
                    const c = this;
                    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback((function t() {
                        c.needsUpdate = true, e.requestVideoFrameCallback(t)
                    }))
                }
                clone() {
                    return new this.constructor(this.image).copy(this)
                }
                update() {
                    const e = this.image;
                    0 == "requestVideoFrameCallback" in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = true)
                }
            }
            no.prototype.isVideoTexture = true;
            class io extends Se {
                constructor(e, t, n, i, r, a, s, o, l, c, u, h) {
                    super(null, a, s, o, l, c, i, r, u, h), this.image = {
                        width: t,
                        height: n
                    }, this.mipmaps = e, this.flipY = false, this.generateMipmaps = false
                }
            }
            io.prototype.isCompressedTexture = true;
            class ro extends Se {
                constructor(e, t, n, i, r, a, s, o, l) {
                    super(e, t, n, i, r, a, s, o, l), this.needsUpdate = true
                }
            }
            ro.prototype.isCanvasTexture = true;
            class ao extends Mn {
                constructor(e = 1, t = 8, n = 0, i = 2 * Math.PI) {
                    super(), this.type = "CircleGeometry", this.parameters = {
                        radius: e,
                        segments: t,
                        thetaStart: n,
                        thetaLength: i
                    }, t = Math.max(3, t);
                    const r = [],
                        a = [],
                        s = [],
                        o = [],
                        l = new Fe,
                        c = new ge;
                    a.push(0, 0, 0), s.push(0, 0, 1), o.push(.5, .5);
                    for (let r = 0, u = 3; r <= t; r++, u += 3) {
                        const h = n + r / t * i;
                        l.x = e * Math.cos(h), l.y = e * Math.sin(h), a.push(l.x, l.y, l.z), s.push(0, 0, 1), c.x = (a[u] / e + 1) / 2, c.y = (a[u + 1] / e + 1) / 2, o.push(c.x, c.y)
                    }
                    for (let e = 1; e <= t; e++) r.push(e, e + 1, 0);
                    this.setIndex(r), this.setAttribute("position", new mn(a, 3)), this.setAttribute("normal", new mn(s, 3)), this.setAttribute("uv", new mn(o, 2))
                }
                static fromJSON(e) {
                    return new ao(e.radius, e.segments, e.thetaStart, e.thetaLength)
                }
            }
            class so extends Mn {
                constructor(e = 1, t = 1, n = 1, i = 8, r = 1, a = false, s = 0, o = 2 * Math.PI) {
                    super(), this.type = "CylinderGeometry", this.parameters = {
                        radiusTop: e,
                        radiusBottom: t,
                        height: n,
                        radialSegments: i,
                        heightSegments: r,
                        openEnded: a,
                        thetaStart: s,
                        thetaLength: o
                    };
                    const l = this;
                    i = Math.floor(i), r = Math.floor(r);
                    const c = [],
                        u = [],
                        h = [],
                        d = [];
                    let p = 0;
                    const f = [],
                        m = n / 2;
                    let g = 0;
                    function v(n) {
                        const r = p,
                            a = new ge,
                            f = new Fe;
                        let v = 0;
                        const y = !0 === n ? e : t,
                            x = !0 === n ? 1 : -1;
                        for (let e = 1; e <= i; e++) u.push(0, m * x, 0), h.push(0, x, 0), d.push(.5, .5), p++;
                        const b = p;
                        for (let e = 0; e <= i; e++) {
                            const t = e / i * o + s,
                                n = Math.cos(t),
                                r = Math.sin(t);
                            f.x = y * r, f.y = m * x, f.z = y * n, u.push(f.x, f.y, f.z), h.push(0, x, 0), a.x = .5 * n + .5, a.y = .5 * r * x + .5, d.push(a.x, a.y), p++
                        }
                        for (let e = 0; e < i; e++) {
                            const t = r + e,
                                i = b + e;
                            !0 === n ? c.push(i, i + 1, t) : c.push(i + 1, i, t), v += 3
                        }
                        l.addGroup(g, v, !0 === n ? 1 : 2), g += v
                    }! function () {
                        const a = new Fe,
                            v = new Fe;
                        let y = 0;
                        const x = (t - e) / n;
                        for (let l = 0; l <= r; l++) {
                            const c = [],
                                g = l / r,
                                y = g * (t - e) + e;
                            for (let e = 0; e <= i; e++) {
                                const t = e / i,
                                    r = t * o + s,
                                    l = Math.sin(r),
                                    f = Math.cos(r);
                                v.x = y * l, v.y = -g * n + m, v.z = y * f, u.push(v.x, v.y, v.z), a.set(l, x, f).normalize(), h.push(a.x, a.y, a.z), d.push(t, 1 - g), c.push(p++)
                            }
                            f.push(c)
                        }
                        for (let e = 0; e < i; e++)
                            for (let t = 0; t < r; t++) {
                                const n = f[t][e],
                                    i = f[t + 1][e],
                                    r = f[t + 1][e + 1],
                                    a = f[t][e + 1];
                                c.push(n, i, a), c.push(i, r, a), y += 6
                            }
                        l.addGroup(g, y, 0), g += y
                    }(), !1 === a && (e > 0 && v(true), t > 0 && v(false)), this.setIndex(c), this.setAttribute("position", new mn(u, 3)), this.setAttribute("normal", new mn(h, 3)), this.setAttribute("uv", new mn(d, 2))
                }
                static fromJSON(e) {
                    return new so(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
                }
            }
            class oo extends so {
                constructor(e = 1, t = 1, n = 8, i = 1, r = false, a = 0, s = 2 * Math.PI) {
                    super(0, e, t, n, i, r, a, s), this.type = "ConeGeometry", this.parameters = {
                        radius: e,
                        height: t,
                        radialSegments: n,
                        heightSegments: i,
                        openEnded: r,
                        thetaStart: a,
                        thetaLength: s
                    }
                }
                static fromJSON(e) {
                    return new oo(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
                }
            }
            class lo extends Mn {
                constructor(e = [], t = [], n = 1, i = 0) {
                    super(), this.type = "PolyhedronGeometry", this.parameters = {
                        vertices: e,
                        indices: t,
                        radius: n,
                        detail: i
                    };
                    const r = [],
                        a = [];
                    function s(e, t, n, i) {
                        const r = i + 1,
                            a = [];
                        for (let i = 0; i <= r; i++) {
                            a[i] = [];
                            const s = e.clone().lerp(n, i / r),
                                o = t.clone().lerp(n, i / r),
                                l = r - i;
                            for (let e = 0; e <= l; e++) a[i][e] = 0 === e && i === r ? s : s.clone().lerp(o, e / l)
                        }
                        for (let e = 0; e < r; e++)
                            for (let t = 0; t < 2 * (r - e) - 1; t++) {
                                const n = Math.floor(t / 2);
                                t % 2 == 0 ? (o(a[e][n + 1]), o(a[e + 1][n]), o(a[e][n])) : (o(a[e][n + 1]), o(a[e + 1][n + 1]), o(a[e + 1][n]))
                            }
                    }
                    function o(e) {
                        r.push(e.x, e.y, e.z)
                    }
                    function l(t, n) {
                        const i = 3 * t;
                        n.x = e[i + 0], n.y = e[i + 1], n.z = e[i + 2]
                    }
                    function c(e, t, n, i) {
                        i < 0 && 1 === e.x && (a[t] = e.x - 1), 0 === n.x && 0 === n.z && (a[t] = i / 2 / Math.PI + .5)
                    }
                    function u(e) {
                        return Math.atan2(e.z, -e.x)
                    }! function (e) {
                        const n = new Fe,
                            i = new Fe,
                            r = new Fe;
                        for (let a = 0; a < t.length; a += 3) l(t[a + 0], n), l(t[a + 1], i), l(t[a + 2], r), s(n, i, r, e)
                    }(i),
                    function (e) {
                        const t = new Fe;
                        for (let n = 0; n < r.length; n += 3) t.x = r[n + 0], t.y = r[n + 1], t.z = r[n + 2], t.normalize().multiplyScalar(e), r[n + 0] = t.x, r[n + 1] = t.y, r[n + 2] = t.z
                    }(n),
                    function () {
                        const e = new Fe;
                        for (let n = 0; n < r.length; n += 3) {
                            e.x = r[n + 0], e.y = r[n + 1], e.z = r[n + 2];
                            const i = u(e) / 2 / Math.PI + .5,
                                s = (t = e, Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) / Math.PI + .5);
                            a.push(i, 1 - s)
                        }
                        var t;
                        (function () {
                            const e = new Fe,
                                t = new Fe,
                                n = new Fe,
                                i = new Fe,
                                s = new ge,
                                o = new ge,
                                l = new ge;
                            for (let h = 0, d = 0; h < r.length; h += 9, d += 6) {
                                e.set(r[h + 0], r[h + 1], r[h + 2]), t.set(r[h + 3], r[h + 4], r[h + 5]), n.set(r[h + 6], r[h + 7], r[h + 8]), s.set(a[d + 0], a[d + 1]), o.set(a[d + 2], a[d + 3]), l.set(a[d + 4], a[d + 5]), i.copy(e).add(t).add(n).divideScalar(3);
                                const p = u(i);
                                c(s, d + 0, e, p), c(o, d + 2, t, p), c(l, d + 4, n, p)
                            }
                        })(),
                        function () {
                            for (let e = 0; e < a.length; e += 6) {
                                const t = a[e + 0],
                                    n = a[e + 2],
                                    i = a[e + 4],
                                    r = Math.max(t, n, i),
                                    s = Math.min(t, n, i);
                                r > .9 && s < .1 && (t < .2 && (a[e + 0] += 1), n < .2 && (a[e + 2] += 1), i < .2 && (a[e + 4] += 1))
                            }
                        }()
                    }(), this.setAttribute("position", new mn(r, 3)), this.setAttribute("normal", new mn(r.slice(), 3)), this.setAttribute("uv", new mn(a, 2)), 0 === i ? this.computeVertexNormals() : this.normalizeNormals()
                }
                static fromJSON(e) {
                    return new lo(e.vertices, e.indices, e.radius, e.details)
                }
            }
            class co extends lo {
                constructor(e = 1, t = 0) {
                    const n = (1 + Math.sqrt(5)) / 2,
                        i = 1 / n;
                    super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronGeometry", this.parameters = {
                        radius: e,
                        detail: t
                    }
                }
                static fromJSON(e) {
                    return new co(e.radius, e.detail)
                }
            }
            const uo = new Fe,
                ho = new Fe,
                po = new Fe,
                fo = new Xt;
            class mo extends Mn {
                constructor(e = null, t = 1) {
                    if (super(), this.type = "EdgesGeometry", this.parameters = {
                            geometry: e,
                            thresholdAngle: t
                        }, null !== e) {
                        const n = 4,
                            i = Math.pow(10, n),
                            r = Math.cos(se * t),
                            a = e.getIndex(),
                            s = e.getAttribute("position"),
                            o = a ? a.count : s.count,
                            l = [0, 0, 0],
                            c = ["a", "b", "c"],
                            u = new Array(3),
                            h = {},
                            d = [];
                        for (let e = 0; e < o; e += 3) {
                            a ? (l[0] = a.getX(e), l[1] = a.getX(e + 1), l[2] = a.getX(e + 2)) : (l[0] = e, l[1] = e + 1, l[2] = e + 2);
                            const {
                                a: t,
                                b: n,
                                c: o
                            } = fo;
                            if (t.fromBufferAttribute(s, l[0]), n.fromBufferAttribute(s, l[1]), o.fromBufferAttribute(s, l[2]), fo.getNormal(po), u[0] = `${Math.round(t.x*i)},${Math.round(t.y*i)},${Math.round(t.z*i)}`, u[1] = `${Math.round(n.x*i)},${Math.round(n.y*i)},${Math.round(n.z*i)}`, u[2] = `${Math.round(o.x*i)},${Math.round(o.y*i)},${Math.round(o.z*i)}`, u[0] !== u[1] && u[1] !== u[2] && u[2] !== u[0])
                                for (let e = 0; e < 3; e++) {
                                    const t = (e + 1) % 3,
                                        n = u[e],
                                        i = u[t],
                                        a = fo[c[e]],
                                        s = fo[c[t]],
                                        o = `${n}_${i}`,
                                        p = `${i}_${n}`;
                                    p in h && h[p] ? (po.dot(h[p].normal) <= r && (d.push(a.x, a.y, a.z), d.push(s.x, s.y, s.z)), h[p] = null) : o in h || (h[o] = {
                                        index0: l[e],
                                        index1: l[t],
                                        normal: po.clone()
                                    })
                                }
                        }
                        for (const e in h)
                            if (h[e]) {
                                const {
                                    index0: t,
                                    index1: n
                                } = h[e];
                                uo.fromBufferAttribute(s, t), ho.fromBufferAttribute(s, n), d.push(uo.x, uo.y, uo.z), d.push(ho.x, ho.y, ho.z)
                            } this.setAttribute("position", new mn(d, 3))
                    }
                }
            }
            class go {
                constructor() {
                    this.type = "Curve", this.arcLengthDivisions = 200
                }
                getPoint() {
                    return console.warn("THREE.Curve: .getPoint() not implemented."), null
                }
                getPointAt(e, t) {
                    const n = this.getUtoTmapping(e);
                    return this.getPoint(n, t)
                }
                getPoints(e = 5) {
                    const t = [];
                    for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                    return t
                }
                getSpacedPoints(e = 5) {
                    const t = [];
                    for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
                    return t
                }
                getLength() {
                    const e = this.getLengths();
                    return e[e.length - 1]
                }
                getLengths(e = this.arcLengthDivisions) {
                    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = false;
                    const t = [];
                    let n, i = this.getPoint(0),
                        r = 0;
                    t.push(0);
                    for (let a = 1; a <= e; a++) n = this.getPoint(a / e), r += n.distanceTo(i), t.push(r), i = n;
                    return this.cacheArcLengths = t, t
                }
                updateArcLengths() {
                    this.needsUpdate = true, this.getLengths()
                }
                getUtoTmapping(e, t) {
                    const n = this.getLengths();
                    let i = 0;
                    const r = n.length;
                    let a;
                    a = t || e * n[r - 1];
                    let s, o = 0,
                        l = r - 1;
                    for (; o <= l;)
                        if (i = Math.floor(o + (l - o) / 2), s = n[i] - a, s < 0) o = i + 1;
                        else {
                            if (!(s > 0)) {
                                l = i;
                                break
                            }
                            l = i - 1
                        } if (i = l, n[i] === a) return i / (r - 1);
                    const c = n[i];
                    return (i + (a - c) / (n[i + 1] - c)) / (r - 1)
                }
                getTangent(e, t) {
                    const n = 1e-4;
                    let i = e - n,
                        r = e + n;
                    i < 0 && (i = 0), r > 1 && (r = 1);
                    const a = this.getPoint(i),
                        s = this.getPoint(r),
                        o = t || (a.isVector2 ? new ge : new Fe);
                    return o.copy(s).sub(a).normalize(), o
                }
                getTangentAt(e, t) {
                    const n = this.getUtoTmapping(e);
                    return this.getTangent(n, t)
                }
                computeFrenetFrames(e, t) {
                    const n = new Fe,
                        i = [],
                        r = [],
                        a = [],
                        s = new Fe,
                        o = new ut;
                    for (let t = 0; t <= e; t++) {
                        const n = t / e;
                        i[t] = this.getTangentAt(n, new Fe)
                    }
                    r[0] = new Fe, a[0] = new Fe;
                    let l = Number.MAX_VALUE;
                    const c = Math.abs(i[0].x),
                        u = Math.abs(i[0].y),
                        h = Math.abs(i[0].z);
                    c <= l && (l = c, n.set(1, 0, 0)), u <= l && (l = u, n.set(0, 1, 0)), h <= l && n.set(0, 0, 1), s.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], s), a[0].crossVectors(i[0], r[0]);
                    for (let t = 1; t <= e; t++) {
                        if (r[t] = r[t - 1].clone(), a[t] = a[t - 1].clone(), s.crossVectors(i[t - 1], i[t]), s.length() > Number.EPSILON) {
                            s.normalize();
                            const e = Math.acos(ce(i[t - 1].dot(i[t]), -1, 1));
                            r[t].applyMatrix4(o.makeRotationAxis(s, e))
                        }
                        a[t].crossVectors(i[t], r[t])
                    }
                    if (!0 === t) {
                        let t = Math.acos(ce(r[0].dot(r[e]), -1, 1));
                        t /= e, i[0].dot(s.crossVectors(r[0], r[e])) > 0 && (t = -t);
                        for (let n = 1; n <= e; n++) r[n].applyMatrix4(o.makeRotationAxis(i[n], t * n)), a[n].crossVectors(i[n], r[n])
                    }
                    return {
                        tangents: i,
                        normals: r,
                        binormals: a
                    }
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.arcLengthDivisions = e.arcLengthDivisions, this
                }
                toJSON() {
                    const e = {
                        metadata: {
                            version: 4.5,
                            type: "Curve",
                            generator: "Curve.toJSON"
                        }
                    };
                    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
                }
                fromJSON(e) {
                    return this.arcLengthDivisions = e.arcLengthDivisions, this
                }
            }
            class vo extends go {
                constructor(e = 0, t = 0, n = 1, i = 1, r = 0, a = 2 * Math.PI, s = false, o = 0) {
                    super(), this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = i, this.aStartAngle = r, this.aEndAngle = a, this.aClockwise = s, this.aRotation = o
                }
                getPoint(e, t) {
                    const n = t || new ge,
                        i = 2 * Math.PI;
                    let r = this.aEndAngle - this.aStartAngle;
                    const a = Math.abs(r) < Number.EPSILON;
                    for (; r < 0;) r += i;
                    for (; r > i;) r -= i;
                    r < Number.EPSILON && (r = a ? 0 : i), !0 !== this.aClockwise || a || (r === i ? r = -i : r -= i);
                    const s = this.aStartAngle + e * r;
                    let o = this.aX + this.xRadius * Math.cos(s),
                        l = this.aY + this.yRadius * Math.sin(s);
                    if (0 !== this.aRotation) {
                        const e = Math.cos(this.aRotation),
                            t = Math.sin(this.aRotation),
                            n = o - this.aX,
                            i = l - this.aY;
                        o = n * e - i * t + this.aX, l = n * t + i * e + this.aY
                    }
                    return n.set(o, l)
                }
                copy(e) {
                    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
                }
            }
            vo.prototype.isEllipseCurve = true;
            class yo extends vo {
                constructor(e, t, n, i, r, a) {
                    super(e, t, n, n, i, r, a), this.type = "ArcCurve"
                }
            }
            function xo() {
                let e = 0,
                    t = 0,
                    n = 0,
                    i = 0;
                function r(r, a, s, o) {
                    e = r, t = s, n = -3 * r + 3 * a - 2 * s - o, i = 2 * r - 2 * a + s + o
                }
                return {
                    initCatmullRom: function (e, t, n, i, a) {
                        r(t, n, a * (n - e), a * (i - t))
                    },
                    initNonuniformCatmullRom: function (e, t, n, i, a, s, o) {
                        let l = (t - e) / a - (n - e) / (a + s) + (n - t) / s,
                            c = (n - t) / s - (i - t) / (s + o) + (i - n) / o;
                        l *= s, c *= s, r(t, n, l, c)
                    },
                    calc: function (r) {
                        const a = r * r;
                        return e + t * r + n * a + i * (a * r)
                    }
                }
            }
            yo.prototype.isArcCurve = true;
            const bo = new Fe,
                _o = new xo,
                wo = new xo,
                Eo = new xo;
            class Mo extends go {
                constructor(e = [], t = false, n = "centripetal", i = .5) {
                    super(), this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = i
                }
                getPoint(e, t = new Fe) {
                    const n = t,
                        i = this.points,
                        r = i.length,
                        a = (r - (this.closed ? 0 : 1)) * e;
                    let s, o, l = Math.floor(a),
                        c = a - l;
                    this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2, c = 1), this.closed || l > 0 ? s = i[(l - 1) % r] : (bo.subVectors(i[0], i[1]).add(i[0]), s = bo);
                    const u = i[l % r],
                        h = i[(l + 1) % r];
                    if (this.closed || l + 2 < r ? o = i[(l + 2) % r] : (bo.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), o = bo), "centripetal" === this.curveType || "chordal" === this.curveType) {
                        const e = "chordal" === this.curveType ? .5 : .25;
                        let t = Math.pow(s.distanceToSquared(u), e),
                            n = Math.pow(u.distanceToSquared(h), e),
                            i = Math.pow(h.distanceToSquared(o), e);
                        n < 1e-4 && (n = 1), t < 1e-4 && (t = n), i < 1e-4 && (i = n), _o.initNonuniformCatmullRom(s.x, u.x, h.x, o.x, t, n, i), wo.initNonuniformCatmullRom(s.y, u.y, h.y, o.y, t, n, i), Eo.initNonuniformCatmullRom(s.z, u.z, h.z, o.z, t, n, i)
                    } else "catmullrom" === this.curveType && (_o.initCatmullRom(s.x, u.x, h.x, o.x, this.tension), wo.initCatmullRom(s.y, u.y, h.y, o.y, this.tension), Eo.initCatmullRom(s.z, u.z, h.z, o.z, this.tension));
                    return n.set(_o.calc(c), wo.calc(c), Eo.calc(c)), n
                }
                copy(e) {
                    super.copy(e), this.points = [];
                    for (let t = 0, n = e.points.length; t < n; t++) {
                        const n = e.points[t];
                        this.points.push(n.clone())
                    }
                    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
                }
                toJSON() {
                    const e = super.toJSON();
                    e.points = [];
                    for (let t = 0, n = this.points.length; t < n; t++) {
                        const n = this.points[t];
                        e.points.push(n.toArray())
                    }
                    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
                }
                fromJSON(e) {
                    super.fromJSON(e), this.points = [];
                    for (let t = 0, n = e.points.length; t < n; t++) {
                        const n = e.points[t];
                        this.points.push((new Fe).fromArray(n))
                    }
                    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
                }
            }
            function To(e, t, n, i, r) {
                const a = .5 * (i - t),
                    s = .5 * (r - n),
                    o = e * e;
                return (2 * n - 2 * i + a + s) * (e * o) + (-3 * n + 3 * i - 2 * a - s) * o + a * e + n
            }
            function So(e, t, n, i) {
                return function (e, t) {
                    const n = 1 - e;
                    return n * n * t
                }(e, t) + function (e, t) {
                    return 2 * (1 - e) * e * t
                }(e, n) + function (e, t) {
                    return e * e * t
                }(e, i)
            }
            function Ao(e, t, n, i, r) {
                return function (e, t) {
                    const n = 1 - e;
                    return n * n * n * t
                }(e, t) + function (e, t) {
                    const n = 1 - e;
                    return 3 * n * n * e * t
                }(e, n) + function (e, t) {
                    return 3 * (1 - e) * e * e * t
                }(e, i) + function (e, t) {
                    return e * e * e * t
                }(e, r)
            }
            Mo.prototype.isCatmullRomCurve3 = true;
            class Lo extends go {
                constructor(e = new ge, t = new ge, n = new ge, i = new ge) {
                    super(), this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i
                }
                getPoint(e, t = new ge) {
                    const n = t,
                        i = this.v0,
                        r = this.v1,
                        a = this.v2,
                        s = this.v3;
                    return n.set(Ao(e, i.x, r.x, a.x, s.x), Ao(e, i.y, r.y, a.y, s.y)), n
                }
                copy(e) {
                    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
                }
            }
            Lo.prototype.isCubicBezierCurve = true;
            class Ro extends go {
                constructor(e = new Fe, t = new Fe, n = new Fe, i = new Fe) {
                    super(), this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i
                }
                getPoint(e, t = new Fe) {
                    const n = t,
                        i = this.v0,
                        r = this.v1,
                        a = this.v2,
                        s = this.v3;
                    return n.set(Ao(e, i.x, r.x, a.x, s.x), Ao(e, i.y, r.y, a.y, s.y), Ao(e, i.z, r.z, a.z, s.z)), n
                }
                copy(e) {
                    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
                }
            }
            Ro.prototype.isCubicBezierCurve3 = true;
            class Po extends go {
                constructor(e = new ge, t = new ge) {
                    super(), this.type = "LineCurve", this.v1 = e, this.v2 = t
                }
                getPoint(e, t = new ge) {
                    const n = t;
                    return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
                }
                getPointAt(e, t) {
                    return this.getPoint(e, t)
                }
                getTangent(e, t) {
                    const n = t || new ge;
                    return n.copy(this.v2).sub(this.v1).normalize(), n
                }
                copy(e) {
                    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                }
            }
            Po.prototype.isLineCurve = true;
            class Co extends go {
                constructor(e = new Fe, t = new Fe) {
                    super(), this.type = "LineCurve3", this.isLineCurve3 = true, this.v1 = e, this.v2 = t
                }
                getPoint(e, t = new Fe) {
                    const n = t;
                    return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
                }
                getPointAt(e, t) {
                    return this.getPoint(e, t)
                }
                copy(e) {
                    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                }
            }
            class Io extends go {
                constructor(e = new ge, t = new ge, n = new ge) {
                    super(), this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n
                }
                getPoint(e, t = new ge) {
                    const n = t,
                        i = this.v0,
                        r = this.v1,
                        a = this.v2;
                    return n.set(So(e, i.x, r.x, a.x), So(e, i.y, r.y, a.y)), n
                }
                copy(e) {
                    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                }
            }
            Io.prototype.isQuadraticBezierCurve = true;
            class Fo extends go {
                constructor(e = new Fe, t = new Fe, n = new Fe) {
                    super(), this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n
                }
                getPoint(e, t = new Fe) {
                    const n = t,
                        i = this.v0,
                        r = this.v1,
                        a = this.v2;
                    return n.set(So(e, i.x, r.x, a.x), So(e, i.y, r.y, a.y), So(e, i.z, r.z, a.z)), n
                }
                copy(e) {
                    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
                }
            }
            Fo.prototype.isQuadraticBezierCurve3 = true;
            class Do extends go {
                constructor(e = []) {
                    super(), this.type = "SplineCurve", this.points = e
                }
                getPoint(e, t = new ge) {
                    const n = t,
                        i = this.points,
                        r = (i.length - 1) * e,
                        a = Math.floor(r),
                        s = r - a,
                        o = i[0 === a ? a : a - 1],
                        l = i[a],
                        c = i[a > i.length - 2 ? i.length - 1 : a + 1],
                        u = i[a > i.length - 3 ? i.length - 1 : a + 2];
                    return n.set(To(s, o.x, l.x, c.x, u.x), To(s, o.y, l.y, c.y, u.y)), n
                }
                copy(e) {
                    super.copy(e), this.points = [];
                    for (let t = 0, n = e.points.length; t < n; t++) {
                        const n = e.points[t];
                        this.points.push(n.clone())
                    }
                    return this
                }
                toJSON() {
                    const e = super.toJSON();
                    e.points = [];
                    for (let t = 0, n = this.points.length; t < n; t++) {
                        const n = this.points[t];
                        e.points.push(n.toArray())
                    }
                    return e
                }
                fromJSON(e) {
                    super.fromJSON(e), this.points = [];
                    for (let t = 0, n = e.points.length; t < n; t++) {
                        const n = e.points[t];
                        this.points.push((new ge).fromArray(n))
                    }
                    return this
                }
            }
            Do.prototype.isSplineCurve = true;
            var No = Object.freeze({
                __proto__: null,
                ArcCurve: yo,
                CatmullRomCurve3: Mo,
                CubicBezierCurve: Lo,
                CubicBezierCurve3: Ro,
                EllipseCurve: vo,
                LineCurve: Po,
                LineCurve3: Co,
                QuadraticBezierCurve: Io,
                QuadraticBezierCurve3: Fo,
                SplineCurve: Do
            });
            class Oo extends go {
                constructor() {
                    super(), this.type = "CurvePath", this.curves = [], this.autoClose = false
                }
                add(e) {
                    this.curves.push(e)
                }
                closePath() {
                    const e = this.curves[0].getPoint(0),
                        t = this.curves[this.curves.length - 1].getPoint(1);
                    e.equals(t) || this.curves.push(new Po(t, e))
                }
                getPoint(e, t) {
                    const n = e * this.getLength(),
                        i = this.getCurveLengths();
                    let r = 0;
                    for (; r < i.length;) {
                        if (i[r] >= n) {
                            const e = i[r] - n,
                                a = this.curves[r],
                                s = a.getLength(),
                                o = 0 === s ? 0 : 1 - e / s;
                            return a.getPointAt(o, t)
                        }
                        r++
                    }
                    return null
                }
                getLength() {
                    const e = this.getCurveLengths();
                    return e[e.length - 1]
                }
                updateArcLengths() {
                    this.needsUpdate = true, this.cacheLengths = null, this.getCurveLengths()
                }
                getCurveLengths() {
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                    const e = [];
                    let t = 0;
                    for (let n = 0, i = this.curves.length; n < i; n++) t += this.curves[n].getLength(), e.push(t);
                    return this.cacheLengths = e, e
                }
                getSpacedPoints(e = 40) {
                    const t = [];
                    for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                    return this.autoClose && t.push(t[0]), t
                }
                getPoints(e = 12) {
                    const t = [];
                    let n;
                    for (let i = 0, r = this.curves; i < r.length; i++) {
                        const a = r[i],
                            s = a && a.isEllipseCurve ? 2 * e : a && (a.isLineCurve || a.isLineCurve3) ? 1 : a && a.isSplineCurve ? e * a.points.length : e,
                            o = a.getPoints(s);
                        for (let e = 0; e < o.length; e++) {
                            const i = o[e];
                            n && n.equals(i) || (t.push(i), n = i)
                        }
                    }
                    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t
                }
                copy(e) {
                    super.copy(e), this.curves = [];
                    for (let t = 0, n = e.curves.length; t < n; t++) {
                        const n = e.curves[t];
                        this.curves.push(n.clone())
                    }
                    return this.autoClose = e.autoClose, this
                }
                toJSON() {
                    const e = super.toJSON();
                    e.autoClose = this.autoClose, e.curves = [];
                    for (let t = 0, n = this.curves.length; t < n; t++) {
                        const n = this.curves[t];
                        e.curves.push(n.toJSON())
                    }
                    return e
                }
                fromJSON(e) {
                    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
                    for (let t = 0, n = e.curves.length; t < n; t++) {
                        const n = e.curves[t];
                        this.curves.push((new No[n.type]).fromJSON(n))
                    }
                    return this
                }
            }
            class Ho extends Oo {
                constructor(e) {
                    super(), this.type = "Path", this.currentPoint = new ge, e && this.setFromPoints(e)
                }
                setFromPoints(e) {
                    this.moveTo(e[0].x, e[0].y);
                    for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
                    return this
                }
                moveTo(e, t) {
                    return this.currentPoint.set(e, t), this
                }
                lineTo(e, t) {
                    const n = new Po(this.currentPoint.clone(), new ge(e, t));
                    return this.curves.push(n), this.currentPoint.set(e, t), this
                }
                quadraticCurveTo(e, t, n, i) {
                    const r = new Io(this.currentPoint.clone(), new ge(e, t), new ge(n, i));
                    return this.curves.push(r), this.currentPoint.set(n, i), this
                }
                bezierCurveTo(e, t, n, i, r, a) {
                    const s = new Lo(this.currentPoint.clone(), new ge(e, t), new ge(n, i), new ge(r, a));
                    return this.curves.push(s), this.currentPoint.set(r, a), this
                }
                splineThru(e) {
                    const t = [this.currentPoint.clone()].concat(e),
                        n = new Do(t);
                    return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this
                }
                arc(e, t, n, i, r, a) {
                    const s = this.currentPoint.x,
                        o = this.currentPoint.y;
                    return this.absarc(e + s, t + o, n, i, r, a), this
                }
                absarc(e, t, n, i, r, a) {
                    return this.absellipse(e, t, n, n, i, r, a), this
                }
                ellipse(e, t, n, i, r, a, s, o) {
                    const l = this.currentPoint.x,
                        c = this.currentPoint.y;
                    return this.absellipse(e + l, t + c, n, i, r, a, s, o), this
                }
                absellipse(e, t, n, i, r, a, s, o) {
                    const l = new vo(e, t, n, i, r, a, s, o);
                    if (this.curves.length > 0) {
                        const e = l.getPoint(0);
                        e.equals(this.currentPoint) || this.lineTo(e.x, e.y)
                    }
                    this.curves.push(l);
                    const c = l.getPoint(1);
                    return this.currentPoint.copy(c), this
                }
                copy(e) {
                    return super.copy(e), this.currentPoint.copy(e.currentPoint), this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.currentPoint = this.currentPoint.toArray(), e
                }
                fromJSON(e) {
                    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
                }
            }
            class Uo extends Ho {
                constructor(e) {
                    super(e), this.uuid = le(), this.type = "Shape", this.holes = []
                }
                getPointsHoles(e) {
                    const t = [];
                    for (let n = 0, i = this.holes.length; n < i; n++) t[n] = this.holes[n].getPoints(e);
                    return t
                }
                extractPoints(e) {
                    return {
                        shape: this.getPoints(e),
                        holes: this.getPointsHoles(e)
                    }
                }
                copy(e) {
                    super.copy(e), this.holes = [];
                    for (let t = 0, n = e.holes.length; t < n; t++) {
                        const n = e.holes[t];
                        this.holes.push(n.clone())
                    }
                    return this
                }
                toJSON() {
                    const e = super.toJSON();
                    e.uuid = this.uuid, e.holes = [];
                    for (let t = 0, n = this.holes.length; t < n; t++) {
                        const n = this.holes[t];
                        e.holes.push(n.toJSON())
                    }
                    return e
                }
                fromJSON(e) {
                    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
                    for (let t = 0, n = e.holes.length; t < n; t++) {
                        const n = e.holes[t];
                        this.holes.push((new Ho).fromJSON(n))
                    }
                    return this
                }
            }
            function Bo(e, t, n, i, r) {
                let a, s;
                if (r === function (e, t, n, i) {
                        let r = 0;
                        for (let a = t, s = n - i; a < n; a += i) r += (e[s] - e[a]) * (e[a + 1] + e[s + 1]), s = a;
                        return r
                    }(e, t, n, i) > 0)
                    for (a = t; a < n; a += i) s = sl(a, e[a], e[a + 1], s);
                else
                    for (a = n - i; a >= t; a -= i) s = sl(a, e[a], e[a + 1], s);
                return s && el(s, s.next) && (ol(s), s = s.next), s
            }
            function zo(e, t) {
                if (!e) return e;
                t || (t = e);
                let n, i = e;
                do {
                    if (n = false, i.steiner || !el(i, i.next) && 0 !== $o(i.prev, i, i.next)) i = i.next;
                    else {
                        if (ol(i), i = t = i.prev, i === i.next) break;
                        n = true
                    }
                } while (n || i !== t);
                return t
            }
            function ko(e, t, n, i, r, a, s) {
                if (!e) return;
                !s && a && function (e, t, n, i) {
                    let r = e;
                    do {
                        null === r.z && (r.z = Qo(r.x, r.y, t, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
                    } while (r !== e);
                    r.prevZ.nextZ = null, r.prevZ = null,
                        function (e) {
                            let t, n, i, r, a, s, o, l, c = 1;
                            do {
                                for (n = e, e = null, a = null, s = 0; n;) {
                                    for (s++, i = n, o = 0, t = 0; t < c && (o++, i = i.nextZ, i); t++);
                                    for (l = c; o > 0 || l > 0 && i;) 0 !== o && (0 === l || !i || n.z <= i.z) ? (r = n, n = n.nextZ, o--) : (r = i, i = i.nextZ, l--), a ? a.nextZ = r : e = r, r.prevZ = a, a = r;
                                    n = i
                                }
                                a.nextZ = null, c *= 2
                            } while (s > 1)
                        }(r)
                }(e, i, r, a);
                let o, l, c = e;
                for (; e.prev !== e.next;)
                    if (o = e.prev, l = e.next, a ? Vo(e, i, r, a) : Go(e)) t.push(o.i / n), t.push(e.i / n), t.push(l.i / n), ol(e), e = l.next, c = l.next;
                    else if ((e = l) === c) {
                    s ? 1 === s ? ko(e = jo(zo(e), t, n), t, n, i, r, a, 2) : 2 === s && Wo(e, t, n, i, r, a) : ko(zo(e), t, n, i, r, a, 1);
                    break
                }
            }
            function Go(e) {
                const t = e.prev,
                    n = e,
                    i = e.next;
                if ($o(t, n, i) >= 0) return false;
                let r = e.next.next;
                for (; r !== e.prev;) {
                    if (Zo(t.x, t.y, n.x, n.y, i.x, i.y, r.x, r.y) && $o(r.prev, r, r.next) >= 0) return false;
                    r = r.next
                }
                return true
            }
            function Vo(e, t, n, i) {
                const r = e.prev,
                    a = e,
                    s = e.next;
                if ($o(r, a, s) >= 0) return false;
                const o = r.x < a.x ? r.x < s.x ? r.x : s.x : a.x < s.x ? a.x : s.x,
                    l = r.y < a.y ? r.y < s.y ? r.y : s.y : a.y < s.y ? a.y : s.y,
                    c = r.x > a.x ? r.x > s.x ? r.x : s.x : a.x > s.x ? a.x : s.x,
                    u = r.y > a.y ? r.y > s.y ? r.y : s.y : a.y > s.y ? a.y : s.y,
                    h = Qo(o, l, t, n, i),
                    d = Qo(c, u, t, n, i);
                let p = e.prevZ,
                    f = e.nextZ;
                for (; p && p.z >= h && f && f.z <= d;) {
                    if (p !== e.prev && p !== e.next && Zo(r.x, r.y, a.x, a.y, s.x, s.y, p.x, p.y) && $o(p.prev, p, p.next) >= 0) return false;
                    if (p = p.prevZ, f !== e.prev && f !== e.next && Zo(r.x, r.y, a.x, a.y, s.x, s.y, f.x, f.y) && $o(f.prev, f, f.next) >= 0) return false;
                    f = f.nextZ
                }
                for (; p && p.z >= h;) {
                    if (p !== e.prev && p !== e.next && Zo(r.x, r.y, a.x, a.y, s.x, s.y, p.x, p.y) && $o(p.prev, p, p.next) >= 0) return false;
                    p = p.prevZ
                }
                for (; f && f.z <= d;) {
                    if (f !== e.prev && f !== e.next && Zo(r.x, r.y, a.x, a.y, s.x, s.y, f.x, f.y) && $o(f.prev, f, f.next) >= 0) return false;
                    f = f.nextZ
                }
                return true
            }
            function jo(e, t, n) {
                let i = e;
                do {
                    const r = i.prev,
                        a = i.next.next;
                    !el(r, a) && tl(r, i, i.next, a) && rl(r, a) && rl(a, r) && (t.push(r.i / n), t.push(i.i / n), t.push(a.i / n), ol(i), ol(i.next), i = e = a), i = i.next
                } while (i !== e);
                return zo(i)
            }
            function Wo(e, t, n, i, r, a) {
                let s = e;
                do {
                    let e = s.next.next;
                    for (; e !== s.prev;) {
                        if (s.i !== e.i && Ko(s, e)) {
                            let o = al(s, e);
                            return s = zo(s, s.next), o = zo(o, o.next), ko(s, t, n, i, r, a), void ko(o, t, n, i, r, a)
                        }
                        e = e.next
                    }
                    s = s.next
                } while (s !== e)
            }
            function Xo(e, t) {
                return e.x - t.x
            }
            function Yo(e, t) {
                if (t = function (e, t) {
                        let n = t;
                        const i = e.x,
                            r = e.y;
                        let a, s = -1 / 0;
                        do {
                            if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
                                const e = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                                if (e <= i && e > s) {
                                    if (s = e, e === i) {
                                        if (r === n.y) return n;
                                        if (r === n.next.y) return n.next
                                    }
                                    a = n.x < n.next.x ? n : n.next
                                }
                            }
                            n = n.next
                        } while (n !== t);
                        if (!a) return null;
                        if (i === s) return a;
                        const o = a,
                            l = a.x,
                            c = a.y;
                        let u, h = 1 / 0;
                        n = a;
                        do {
                            i >= n.x && n.x >= l && i !== n.x && Zo(r < c ? i : s, r, l, c, r < c ? s : i, r, n.x, n.y) && (u = Math.abs(r - n.y) / (i - n.x), rl(n, e) && (u < h || u === h && (n.x > a.x || n.x === a.x && qo(a, n))) && (a = n, h = u)), n = n.next
                        } while (n !== o);
                        return a
                    }(e, t), t) {
                    const n = al(t, e);
                    zo(t, t.next), zo(n, n.next)
                }
            }
            function qo(e, t) {
                return $o(e.prev, e, t.prev) < 0 && $o(t.next, e, e.next) < 0
            }
            function Qo(e, t, n, i, r) {
                return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
            }
            function Jo(e) {
                let t = e,
                    n = e;
                do {
                    (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next
                } while (t !== e);
                return n
            }
            function Zo(e, t, n, i, r, a, s, o) {
                return (r - s) * (t - o) - (e - s) * (a - o) >= 0 && (e - s) * (i - o) - (n - s) * (t - o) >= 0 && (n - s) * (a - o) - (r - s) * (i - o) >= 0
            }
            function Ko(e, t) {
                return e.next.i !== t.i && e.prev.i !== t.i && ! function (e, t) {
                    let n = e;
                    do {
                        if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && tl(n, n.next, e, t)) return true;
                        n = n.next
                    } while (n !== e);
                    return false
                }(e, t) && (rl(e, t) && rl(t, e) && function (e, t) {
                    let n = e,
                        i = false;
                    const r = (e.x + t.x) / 2,
                        a = (e.y + t.y) / 2;
                    do {
                        n.y > a != n.next.y > a && n.next.y !== n.y && r < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next
                    } while (n !== e);
                    return i
                }(e, t) && ($o(e.prev, e, t.prev) || $o(e, t.prev, t)) || el(e, t) && $o(e.prev, e, e.next) > 0 && $o(t.prev, t, t.next) > 0)
            }
            function $o(e, t, n) {
                return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
            }
            function el(e, t) {
                return e.x === t.x && e.y === t.y
            }
            function tl(e, t, n, i) {
                const r = il($o(e, t, n)),
                    a = il($o(e, t, i)),
                    s = il($o(n, i, e)),
                    o = il($o(n, i, t));
                return r !== a && s !== o || !(0 !== r || !nl(e, n, t)) || !(0 !== a || !nl(e, i, t)) || !(0 !== s || !nl(n, e, i)) || !(0 !== o || !nl(n, t, i))
            }
            function nl(e, t, n) {
                return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y)
            }
            function il(e) {
                return e > 0 ? 1 : e < 0 ? -1 : 0
            }
            function rl(e, t) {
                return $o(e.prev, e, e.next) < 0 ? $o(e, t, e.next) >= 0 && $o(e, e.prev, t) >= 0 : $o(e, t, e.prev) < 0 || $o(e, e.next, t) < 0
            }
            function al(e, t) {
                const n = new ll(e.i, e.x, e.y),
                    i = new ll(t.i, t.x, t.y),
                    r = e.next,
                    a = t.prev;
                return e.next = t, t.prev = e, n.next = r, r.prev = n, i.next = n, n.prev = i, a.next = i, i.prev = a, i
            }
            function sl(e, t, n, i) {
                const r = new ll(e, t, n);
                return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r
            }
            function ol(e) {
                e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
            }
            function ll(e, t, n) {
                this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false
            }
            class cl {
                static area(e) {
                    const t = e.length;
                    let n = 0;
                    for (let i = t - 1, r = 0; r < t; i = r++) n += e[i].x * e[r].y - e[r].x * e[i].y;
                    return .5 * n
                }
                static isClockWise(e) {
                    return cl.area(e) < 0
                }
                static triangulateShape(e, t) {
                    const n = [],
                        i = [],
                        r = [];
                    ul(e), hl(n, e);
                    let a = e.length;
                    t.forEach(ul);
                    for (let e = 0; e < t.length; e++) i.push(a), a += t[e].length, hl(n, t[e]);
                    const s = function (e, t, n = 2) {
                        const i = t && t.length,
                            r = i ? t[0] * n : e.length;
                        let a = Bo(e, 0, r, n, true);
                        const s = [];
                        if (!a || a.next === a.prev) return s;
                        let o, l, c, u, h, d, p;
                        if (i && (a = function (e, t, n, i) {
                                const r = [];
                                let a, s, o, l, c;
                                for (a = 0, s = t.length; a < s; a++) o = t[a] * i, l = a < s - 1 ? t[a + 1] * i : e.length, c = Bo(e, o, l, i, false), c === c.next && (c.steiner = true), r.push(Jo(c));
                                for (r.sort(Xo), a = 0; a < r.length; a++) Yo(r[a], n), n = zo(n, n.next);
                                return n
                            }(e, t, a, n)), e.length > 80 * n) {
                            o = c = e[0], l = u = e[1];
                            for (let t = n; t < r; t += n) h = e[t], d = e[t + 1], h < o && (o = h), d < l && (l = d), h > c && (c = h), d > u && (u = d);
                            p = Math.max(c - o, u - l), p = 0 !== p ? 1 / p : 0
                        }
                        return ko(a, s, n, o, l, p), s
                    }(n, i);
                    for (let e = 0; e < s.length; e += 3) r.push(s.slice(e, e + 3));
                    return r
                }
            }
            function ul(e) {
                const t = e.length;
                t > 2 && e[t - 1].equals(e[0]) && e.pop()
            }
            function hl(e, t) {
                for (let n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y)
            }
            class dl extends Mn {
                constructor(e = new Uo([new ge(.5, .5), new ge(-.5, .5), new ge(-.5, -.5), new ge(.5, -.5)]), t = {}) {
                    super(), this.type = "ExtrudeGeometry", this.parameters = {
                        shapes: e,
                        options: t
                    }, e = Array.isArray(e) ? e : [e];
                    const n = this,
                        i = [],
                        r = [];
                    for (let t = 0, n = e.length; t < n; t++) a(e[t]);
                    function a(e) {
                        const a = [],
                            s = void 0 !== t.curveSegments ? t.curveSegments : 12,
                            o = void 0 !== t.steps ? t.steps : 1;
                        let l = void 0 !== t.depth ? t.depth : 1,
                            c = void 0 === t.bevelEnabled || t.bevelEnabled,
                            u = void 0 !== t.bevelThickness ? t.bevelThickness : .2,
                            h = void 0 !== t.bevelSize ? t.bevelSize : u - .1,
                            d = void 0 !== t.bevelOffset ? t.bevelOffset : 0,
                            p = void 0 !== t.bevelSegments ? t.bevelSegments : 3;
                        const f = t.extrudePath,
                            m = void 0 !== t.UVGenerator ? t.UVGenerator : pl;
                        void 0 !== t.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l = t.amount);
                        let g, v, y, x, b, _ = false;
                        f && (g = f.getSpacedPoints(o), _ = true, c = false, v = f.computeFrenetFrames(o, false), y = new Fe, x = new Fe, b = new Fe), c || (p = 0, u = 0, h = 0, d = 0);
                        const w = e.extractPoints(s);
                        let E = w.shape;
                        const M = w.holes;
                        if (!cl.isClockWise(E)) {
                            E = E.reverse();
                            for (let e = 0, t = M.length; e < t; e++) {
                                const t = M[e];
                                cl.isClockWise(t) && (M[e] = t.reverse())
                            }
                        }
                        const T = cl.triangulateShape(E, M),
                            S = E;
                        for (let e = 0, t = M.length; e < t; e++) {
                            const t = M[e];
                            E = E.concat(t)
                        }
                        function A(e, t, n) {
                            return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(n).add(e)
                        }
                        const L = E.length,
                            R = T.length;
                        function P(e, t, n) {
                            let i, r, a;
                            const s = e.x - t.x,
                                o = e.y - t.y,
                                l = n.x - e.x,
                                c = n.y - e.y,
                                u = s * s + o * o,
                                h = s * c - o * l;
                            if (Math.abs(h) > Number.EPSILON) {
                                const h = Math.sqrt(u),
                                    d = Math.sqrt(l * l + c * c),
                                    p = t.x - o / h,
                                    f = t.y + s / h,
                                    m = ((n.x - c / d - p) * c - (n.y + l / d - f) * l) / (s * c - o * l);
                                i = p + s * m - e.x, r = f + o * m - e.y;
                                const g = i * i + r * r;
                                if (g <= 2) return new ge(i, r);
                                a = Math.sqrt(g / 2)
                            } else {
                                let e = false;
                                s > Number.EPSILON ? l > Number.EPSILON && (e = true) : s < -Number.EPSILON ? l < -Number.EPSILON && (e = true) : Math.sign(o) === Math.sign(c) && (e = true), e ? (i = -o, r = s, a = Math.sqrt(u)) : (i = s, r = o, a = Math.sqrt(u / 2))
                            }
                            return new ge(i / a, r / a)
                        }
                        const C = [];
                        for (let e = 0, t = S.length, n = t - 1, i = e + 1; e < t; e++, n++, i++) n === t && (n = 0), i === t && (i = 0), C[e] = P(S[e], S[n], S[i]);
                        const I = [];
                        let F, D = C.concat();
                        for (let e = 0, t = M.length; e < t; e++) {
                            const t = M[e];
                            F = [];
                            for (let e = 0, n = t.length, i = n - 1, r = e + 1; e < n; e++, i++, r++) i === n && (i = 0), r === n && (r = 0), F[e] = P(t[e], t[i], t[r]);
                            I.push(F), D = D.concat(F)
                        }
                        for (let e = 0; e < p; e++) {
                            const t = e / p,
                                n = u * Math.cos(t * Math.PI / 2),
                                i = h * Math.sin(t * Math.PI / 2) + d;
                            for (let e = 0, t = S.length; e < t; e++) {
                                const t = A(S[e], C[e], i);
                                H(t.x, t.y, -n)
                            }
                            for (let e = 0, t = M.length; e < t; e++) {
                                const t = M[e];
                                F = I[e];
                                for (let e = 0, r = t.length; e < r; e++) {
                                    const r = A(t[e], F[e], i);
                                    H(r.x, r.y, -n)
                                }
                            }
                        }
                        const N = h + d;
                        for (let e = 0; e < L; e++) {
                            const t = c ? A(E[e], D[e], N) : E[e];
                            _ ? (x.copy(v.normals[0]).multiplyScalar(t.x), y.copy(v.binormals[0]).multiplyScalar(t.y), b.copy(g[0]).add(x).add(y), H(b.x, b.y, b.z)) : H(t.x, t.y, 0)
                        }
                        for (let e = 1; e <= o; e++)
                            for (let t = 0; t < L; t++) {
                                const n = c ? A(E[t], D[t], N) : E[t];
                                _ ? (x.copy(v.normals[e]).multiplyScalar(n.x), y.copy(v.binormals[e]).multiplyScalar(n.y), b.copy(g[e]).add(x).add(y), H(b.x, b.y, b.z)) : H(n.x, n.y, l / o * e)
                            }
                        for (let e = p - 1; e >= 0; e--) {
                            const t = e / p,
                                n = u * Math.cos(t * Math.PI / 2),
                                i = h * Math.sin(t * Math.PI / 2) + d;
                            for (let e = 0, t = S.length; e < t; e++) {
                                const t = A(S[e], C[e], i);
                                H(t.x, t.y, l + n)
                            }
                            for (let e = 0, t = M.length; e < t; e++) {
                                const t = M[e];
                                F = I[e];
                                for (let e = 0, r = t.length; e < r; e++) {
                                    const r = A(t[e], F[e], i);
                                    _ ? H(r.x, r.y + g[o - 1].y, g[o - 1].x + n) : H(r.x, r.y, l + n)
                                }
                            }
                        }
                        function O(e, t) {
                            let n = e.length;
                            for (; --n >= 0;) {
                                const i = n;
                                let r = n - 1;
                                r < 0 && (r = e.length - 1);
                                for (let e = 0, n = o + 2 * p; e < n; e++) {
                                    const n = L * e,
                                        a = L * (e + 1);
                                    B(t + i + n, t + r + n, t + r + a, t + i + a)
                                }
                            }
                        }
                        function H(e, t, n) {
                            a.push(e), a.push(t), a.push(n)
                        }
                        function U(e, t, r) {
                            z(e), z(t), z(r);
                            const a = i.length / 3,
                                s = m.generateTopUV(n, i, a - 3, a - 2, a - 1);
                            k(s[0]), k(s[1]), k(s[2])
                        }
                        function B(e, t, r, a) {
                            z(e), z(t), z(a), z(t), z(r), z(a);
                            const s = i.length / 3,
                                o = m.generateSideWallUV(n, i, s - 6, s - 3, s - 2, s - 1);
                            k(o[0]), k(o[1]), k(o[3]), k(o[1]), k(o[2]), k(o[3])
                        }
                        function z(e) {
                            i.push(a[3 * e + 0]), i.push(a[3 * e + 1]), i.push(a[3 * e + 2])
                        }
                        function k(e) {
                            r.push(e.x), r.push(e.y)
                        }! function () {
                            const e = i.length / 3;
                            if (c) {
                                let e = 0,
                                    t = L * e;
                                for (let e = 0; e < R; e++) {
                                    const n = T[e];
                                    U(n[2] + t, n[1] + t, n[0] + t)
                                }
                                e = o + 2 * p, t = L * e;
                                for (let e = 0; e < R; e++) {
                                    const n = T[e];
                                    U(n[0] + t, n[1] + t, n[2] + t)
                                }
                            } else {
                                for (let e = 0; e < R; e++) {
                                    const t = T[e];
                                    U(t[2], t[1], t[0])
                                }
                                for (let e = 0; e < R; e++) {
                                    const t = T[e];
                                    U(t[0] + L * o, t[1] + L * o, t[2] + L * o)
                                }
                            }
                            n.addGroup(e, i.length / 3 - e, 0)
                        }(),
                        function () {
                            const e = i.length / 3;
                            let t = 0;
                            O(S, t), t += S.length;
                            for (let e = 0, n = M.length; e < n; e++) {
                                const n = M[e];
                                O(n, t), t += n.length
                            }
                            n.addGroup(e, i.length / 3 - e, 1)
                        }()
                    }
                    this.setAttribute("position", new mn(i, 3)), this.setAttribute("uv", new mn(r, 2)), this.computeVertexNormals()
                }
                toJSON() {
                    const e = super.toJSON();
                    return function (e, t, n) {
                        if (n.shapes = [], Array.isArray(e))
                            for (let t = 0, i = e.length; t < i; t++) {
                                const i = e[t];
                                n.shapes.push(i.uuid)
                            } else n.shapes.push(e.uuid);
                        return void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON()), n
                    }(this.parameters.shapes, this.parameters.options, e)
                }
                static fromJSON(e, t) {
                    const n = [];
                    for (let i = 0, r = e.shapes.length; i < r; i++) {
                        const r = t[e.shapes[i]];
                        n.push(r)
                    }
                    const i = e.options.extrudePath;
                    return void 0 !== i && (e.options.extrudePath = (new No[i.type]).fromJSON(i)), new dl(n, e.options)
                }
            }
            const pl = {
                generateTopUV: function (e, t, n, i, r) {
                    const a = t[3 * n],
                        s = t[3 * n + 1],
                        o = t[3 * i],
                        l = t[3 * i + 1],
                        c = t[3 * r],
                        u = t[3 * r + 1];
                    return [new ge(a, s), new ge(o, l), new ge(c, u)]
                },
                generateSideWallUV: function (e, t, n, i, r, a) {
                    const s = t[3 * n],
                        o = t[3 * n + 1],
                        l = t[3 * n + 2],
                        c = t[3 * i],
                        u = t[3 * i + 1],
                        h = t[3 * i + 2],
                        d = t[3 * r],
                        p = t[3 * r + 1],
                        f = t[3 * r + 2],
                        m = t[3 * a],
                        g = t[3 * a + 1],
                        v = t[3 * a + 2];
                    return Math.abs(o - u) < Math.abs(s - c) ? [new ge(s, 1 - l), new ge(c, 1 - h), new ge(d, 1 - f), new ge(m, 1 - v)] : [new ge(o, 1 - l), new ge(u, 1 - h), new ge(p, 1 - f), new ge(g, 1 - v)]
                }
            };
            class fl extends lo {
                constructor(e = 1, t = 0) {
                    const n = (1 + Math.sqrt(5)) / 2;
                    super([-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronGeometry", this.parameters = {
                        radius: e,
                        detail: t
                    }
                }
                static fromJSON(e) {
                    return new fl(e.radius, e.detail)
                }
            }
            class ml extends Mn {
                constructor(e = [new ge(0, .5), new ge(.5, 0), new ge(0, -.5)], t = 12, n = 0, i = 2 * Math.PI) {
                    super(), this.type = "LatheGeometry", this.parameters = {
                        points: e,
                        segments: t,
                        phiStart: n,
                        phiLength: i
                    }, t = Math.floor(t), i = ce(i, 0, 2 * Math.PI);
                    const r = [],
                        a = [],
                        s = [],
                        o = 1 / t,
                        l = new Fe,
                        c = new ge;
                    for (let r = 0; r <= t; r++) {
                        const u = n + r * o * i,
                            h = Math.sin(u),
                            d = Math.cos(u);
                        for (let n = 0; n <= e.length - 1; n++) l.x = e[n].x * h, l.y = e[n].y, l.z = e[n].x * d, a.push(l.x, l.y, l.z), c.x = r / t, c.y = n / (e.length - 1), s.push(c.x, c.y)
                    }
                    for (let n = 0; n < t; n++)
                        for (let t = 0; t < e.length - 1; t++) {
                            const i = t + n * e.length,
                                a = i,
                                s = i + e.length,
                                o = i + e.length + 1,
                                l = i + 1;
                            r.push(a, s, l), r.push(s, o, l)
                        }
                    if (this.setIndex(r), this.setAttribute("position", new mn(a, 3)), this.setAttribute("uv", new mn(s, 2)), this.computeVertexNormals(), i === 2 * Math.PI) {
                        const n = this.attributes.normal.array,
                            i = new Fe,
                            r = new Fe,
                            a = new Fe,
                            s = t * e.length * 3;
                        for (let t = 0, o = 0; t < e.length; t++, o += 3) i.x = n[o + 0], i.y = n[o + 1], i.z = n[o + 2], r.x = n[s + o + 0], r.y = n[s + o + 1], r.z = n[s + o + 2], a.addVectors(i, r).normalize(), n[o + 0] = n[s + o + 0] = a.x, n[o + 1] = n[s + o + 1] = a.y, n[o + 2] = n[s + o + 2] = a.z
                    }
                }
                static fromJSON(e) {
                    return new ml(e.points, e.segments, e.phiStart, e.phiLength)
                }
            }
            class gl extends lo {
                constructor(e = 1, t = 0) {
                    super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronGeometry", this.parameters = {
                        radius: e,
                        detail: t
                    }
                }
                static fromJSON(e) {
                    return new gl(e.radius, e.detail)
                }
            }
            class vl extends Mn {
                constructor(e = .5, t = 1, n = 8, i = 1, r = 0, a = 2 * Math.PI) {
                    super(), this.type = "RingGeometry", this.parameters = {
                        innerRadius: e,
                        outerRadius: t,
                        thetaSegments: n,
                        phiSegments: i,
                        thetaStart: r,
                        thetaLength: a
                    }, n = Math.max(3, n);
                    const s = [],
                        o = [],
                        l = [],
                        c = [];
                    let u = e;
                    const h = (t - e) / (i = Math.max(1, i)),
                        d = new Fe,
                        p = new ge;
                    for (let e = 0; e <= i; e++) {
                        for (let e = 0; e <= n; e++) {
                            const i = r + e / n * a;
                            d.x = u * Math.cos(i), d.y = u * Math.sin(i), o.push(d.x, d.y, d.z), l.push(0, 0, 1), p.x = (d.x / t + 1) / 2, p.y = (d.y / t + 1) / 2, c.push(p.x, p.y)
                        }
                        u += h
                    }
                    for (let e = 0; e < i; e++) {
                        const t = e * (n + 1);
                        for (let e = 0; e < n; e++) {
                            const i = e + t,
                                r = i,
                                a = i + n + 1,
                                o = i + n + 2,
                                l = i + 1;
                            s.push(r, a, l), s.push(a, o, l)
                        }
                    }
                    this.setIndex(s), this.setAttribute("position", new mn(o, 3)), this.setAttribute("normal", new mn(l, 3)), this.setAttribute("uv", new mn(c, 2))
                }
                static fromJSON(e) {
                    return new vl(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength)
                }
            }
            class yl extends Mn {
                constructor(e = new Uo([new ge(0, .5), new ge(-.5, -.5), new ge(.5, -.5)]), t = 12) {
                    super(), this.type = "ShapeGeometry", this.parameters = {
                        shapes: e,
                        curveSegments: t
                    };
                    const n = [],
                        i = [],
                        r = [],
                        a = [];
                    let s = 0,
                        o = 0;
                    if (!1 === Array.isArray(e)) l(e);
                    else
                        for (let t = 0; t < e.length; t++) l(e[t]), this.addGroup(s, o, t), s += o, o = 0;
                    function l(e) {
                        const s = i.length / 3,
                            l = e.extractPoints(t);
                        let c = l.shape;
                        const u = l.holes;
                        !1 === cl.isClockWise(c) && (c = c.reverse());
                        for (let e = 0, t = u.length; e < t; e++) {
                            const t = u[e];
                            !0 === cl.isClockWise(t) && (u[e] = t.reverse())
                        }
                        const h = cl.triangulateShape(c, u);
                        for (let e = 0, t = u.length; e < t; e++) {
                            const t = u[e];
                            c = c.concat(t)
                        }
                        for (let e = 0, t = c.length; e < t; e++) {
                            const t = c[e];
                            i.push(t.x, t.y, 0), r.push(0, 0, 1), a.push(t.x, t.y)
                        }
                        for (let e = 0, t = h.length; e < t; e++) {
                            const t = h[e],
                                i = t[0] + s,
                                r = t[1] + s,
                                a = t[2] + s;
                            n.push(i, r, a), o += 3
                        }
                    }
                    this.setIndex(n), this.setAttribute("position", new mn(i, 3)), this.setAttribute("normal", new mn(r, 3)), this.setAttribute("uv", new mn(a, 2))
                }
                toJSON() {
                    const e = super.toJSON();
                    return function (e, t) {
                        if (t.shapes = [], Array.isArray(e))
                            for (let n = 0, i = e.length; n < i; n++) {
                                const i = e[n];
                                t.shapes.push(i.uuid)
                            } else t.shapes.push(e.uuid);
                        return t
                    }(this.parameters.shapes, e)
                }
                static fromJSON(e, t) {
                    const n = [];
                    for (let i = 0, r = e.shapes.length; i < r; i++) {
                        const r = t[e.shapes[i]];
                        n.push(r)
                    }
                    return new yl(n, e.curveSegments)
                }
            }
            class xl extends Mn {
                constructor(e = 1, t = 32, n = 16, i = 0, r = 2 * Math.PI, a = 0, s = Math.PI) {
                    super(), this.type = "SphereGeometry", this.parameters = {
                        radius: e,
                        widthSegments: t,
                        heightSegments: n,
                        phiStart: i,
                        phiLength: r,
                        thetaStart: a,
                        thetaLength: s
                    }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
                    const o = Math.min(a + s, Math.PI);
                    let l = 0;
                    const c = [],
                        u = new Fe,
                        h = new Fe,
                        d = [],
                        p = [],
                        f = [],
                        m = [];
                    for (let d = 0; d <= n; d++) {
                        const g = [],
                            v = d / n;
                        let y = 0;
                        0 == d && 0 == a ? y = .5 / t : d == n && o == Math.PI && (y = -.5 / t);
                        for (let n = 0; n <= t; n++) {
                            const o = n / t;
                            u.x = -e * Math.cos(i + o * r) * Math.sin(a + v * s), u.y = e * Math.cos(a + v * s), u.z = e * Math.sin(i + o * r) * Math.sin(a + v * s), p.push(u.x, u.y, u.z), h.copy(u).normalize(), f.push(h.x, h.y, h.z), m.push(o + y, 1 - v), g.push(l++)
                        }
                        c.push(g)
                    }
                    for (let e = 0; e < n; e++)
                        for (let i = 0; i < t; i++) {
                            const t = c[e][i + 1],
                                r = c[e][i],
                                s = c[e + 1][i],
                                l = c[e + 1][i + 1];
                            (0 !== e || a > 0) && d.push(t, r, l), (e !== n - 1 || o < Math.PI) && d.push(r, s, l)
                        }
                    this.setIndex(d), this.setAttribute("position", new mn(p, 3)), this.setAttribute("normal", new mn(f, 3)), this.setAttribute("uv", new mn(m, 2))
                }
                static fromJSON(e) {
                    return new xl(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength)
                }
            }
            class bl extends lo {
                constructor(e = 1, t = 0) {
                    super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronGeometry", this.parameters = {
                        radius: e,
                        detail: t
                    }
                }
                static fromJSON(e) {
                    return new bl(e.radius, e.detail)
                }
            }
            class _l extends Mn {
                constructor(e = 1, t = .4, n = 8, i = 6, r = 2 * Math.PI) {
                    super(), this.type = "TorusGeometry", this.parameters = {
                        radius: e,
                        tube: t,
                        radialSegments: n,
                        tubularSegments: i,
                        arc: r
                    }, n = Math.floor(n), i = Math.floor(i);
                    const a = [],
                        s = [],
                        o = [],
                        l = [],
                        c = new Fe,
                        u = new Fe,
                        h = new Fe;
                    for (let a = 0; a <= n; a++)
                        for (let d = 0; d <= i; d++) {
                            const p = d / i * r,
                                f = a / n * Math.PI * 2;
                            u.x = (e + t * Math.cos(f)) * Math.cos(p), u.y = (e + t * Math.cos(f)) * Math.sin(p), u.z = t * Math.sin(f), s.push(u.x, u.y, u.z), c.x = e * Math.cos(p), c.y = e * Math.sin(p), h.subVectors(u, c).normalize(), o.push(h.x, h.y, h.z), l.push(d / i), l.push(a / n)
                        }
                    for (let e = 1; e <= n; e++)
                        for (let t = 1; t <= i; t++) {
                            const n = (i + 1) * e + t - 1,
                                r = (i + 1) * (e - 1) + t - 1,
                                s = (i + 1) * (e - 1) + t,
                                o = (i + 1) * e + t;
                            a.push(n, r, o), a.push(r, s, o)
                        }
                    this.setIndex(a), this.setAttribute("position", new mn(s, 3)), this.setAttribute("normal", new mn(o, 3)), this.setAttribute("uv", new mn(l, 2))
                }
                static fromJSON(e) {
                    return new _l(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc)
                }
            }
            class wl extends Mn {
                constructor(e = 1, t = .4, n = 64, i = 8, r = 2, a = 3) {
                    super(), this.type = "TorusKnotGeometry", this.parameters = {
                        radius: e,
                        tube: t,
                        tubularSegments: n,
                        radialSegments: i,
                        p: r,
                        q: a
                    }, n = Math.floor(n), i = Math.floor(i);
                    const s = [],
                        o = [],
                        l = [],
                        c = [],
                        u = new Fe,
                        h = new Fe,
                        d = new Fe,
                        p = new Fe,
                        f = new Fe,
                        m = new Fe,
                        g = new Fe;
                    for (let s = 0; s <= n; ++s) {
                        const y = s / n * r * Math.PI * 2;
                        v(y, r, a, e, d), v(y + .01, r, a, e, p), m.subVectors(p, d), g.addVectors(p, d), f.crossVectors(m, g), g.crossVectors(f, m), f.normalize(), g.normalize();
                        for (let e = 0; e <= i; ++e) {
                            const r = e / i * Math.PI * 2,
                                a = -t * Math.cos(r),
                                p = t * Math.sin(r);
                            u.x = d.x + (a * g.x + p * f.x), u.y = d.y + (a * g.y + p * f.y), u.z = d.z + (a * g.z + p * f.z), o.push(u.x, u.y, u.z), h.subVectors(u, d).normalize(), l.push(h.x, h.y, h.z), c.push(s / n), c.push(e / i)
                        }
                    }
                    for (let e = 1; e <= n; e++)
                        for (let t = 1; t <= i; t++) {
                            const n = (i + 1) * (e - 1) + (t - 1),
                                r = (i + 1) * e + (t - 1),
                                a = (i + 1) * e + t,
                                o = (i + 1) * (e - 1) + t;
                            s.push(n, r, o), s.push(r, a, o)
                        }
                    function v(e, t, n, i, r) {
                        const a = Math.cos(e),
                            s = Math.sin(e),
                            o = n / t * e,
                            l = Math.cos(o);
                        r.x = i * (2 + l) * .5 * a, r.y = i * (2 + l) * s * .5, r.z = i * Math.sin(o) * .5
                    }
                    this.setIndex(s), this.setAttribute("position", new mn(o, 3)), this.setAttribute("normal", new mn(l, 3)), this.setAttribute("uv", new mn(c, 2))
                }
                static fromJSON(e) {
                    return new wl(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q)
                }
            }
            class El extends Mn {
                constructor(e = new Fo(new Fe(-1, -1, 0), new Fe(-1, 1, 0), new Fe(1, 1, 0)), t = 64, n = 1, i = 8, r = false) {
                    super(), this.type = "TubeGeometry", this.parameters = {
                        path: e,
                        tubularSegments: t,
                        radius: n,
                        radialSegments: i,
                        closed: r
                    };
                    const a = e.computeFrenetFrames(t, r);
                    this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals;
                    const s = new Fe,
                        o = new Fe,
                        l = new ge;
                    let c = new Fe;
                    const u = [],
                        h = [],
                        d = [],
                        p = [];
                    function f(r) {
                        c = e.getPointAt(r / t, c);
                        const l = a.normals[r],
                            d = a.binormals[r];
                        for (let e = 0; e <= i; e++) {
                            const t = e / i * Math.PI * 2,
                                r = Math.sin(t),
                                a = -Math.cos(t);
                            o.x = a * l.x + r * d.x, o.y = a * l.y + r * d.y, o.z = a * l.z + r * d.z, o.normalize(), h.push(o.x, o.y, o.z), s.x = c.x + n * o.x, s.y = c.y + n * o.y, s.z = c.z + n * o.z, u.push(s.x, s.y, s.z)
                        }
                    }! function () {
                        for (let e = 0; e < t; e++) f(e);
                        f(!1 === r ? t : 0),
                            function () {
                                for (let e = 0; e <= t; e++)
                                    for (let n = 0; n <= i; n++) l.x = e / t, l.y = n / i, d.push(l.x, l.y)
                            }(),
                            function () {
                                for (let e = 1; e <= t; e++)
                                    for (let t = 1; t <= i; t++) {
                                        const n = (i + 1) * (e - 1) + (t - 1),
                                            r = (i + 1) * e + (t - 1),
                                            a = (i + 1) * e + t,
                                            s = (i + 1) * (e - 1) + t;
                                        p.push(n, r, s), p.push(r, a, s)
                                    }
                            }()
                    }(), this.setIndex(p), this.setAttribute("position", new mn(u, 3)), this.setAttribute("normal", new mn(h, 3)), this.setAttribute("uv", new mn(d, 2))
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.path = this.parameters.path.toJSON(), e
                }
                static fromJSON(e) {
                    return new El((new No[e.path.type]).fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed)
                }
            }
            class Ml extends Mn {
                constructor(e = null) {
                    if (super(), this.type = "WireframeGeometry", this.parameters = {
                            geometry: e
                        }, null !== e) {
                        const t = [],
                            n = new Set,
                            i = new Fe,
                            r = new Fe;
                        if (null !== e.index) {
                            const a = e.attributes.position,
                                s = e.index;
                            let o = e.groups;
                            0 === o.length && (o = [{
                                start: 0,
                                count: s.count,
                                materialIndex: 0
                            }]);
                            for (let e = 0, l = o.length; e < l; ++e) {
                                const l = o[e],
                                    c = l.start;
                                for (let e = c, o = c + l.count; e < o; e += 3)
                                    for (let o = 0; o < 3; o++) {
                                        const l = s.getX(e + o),
                                            c = s.getX(e + (o + 1) % 3);
                                        i.fromBufferAttribute(a, l), r.fromBufferAttribute(a, c), !0 === Tl(i, r, n) && (t.push(i.x, i.y, i.z), t.push(r.x, r.y, r.z))
                                    }
                            }
                        } else {
                            const a = e.attributes.position;
                            for (let e = 0, s = a.count / 3; e < s; e++)
                                for (let s = 0; s < 3; s++) {
                                    const o = 3 * e + s,
                                        l = 3 * e + (s + 1) % 3;
                                    i.fromBufferAttribute(a, o), r.fromBufferAttribute(a, l), !0 === Tl(i, r, n) && (t.push(i.x, i.y, i.z), t.push(r.x, r.y, r.z))
                                }
                        }
                        this.setAttribute("position", new mn(t, 3))
                    }
                }
            }
            function Tl(e, t, n) {
                const i = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`,
                    r = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`;
                return !0 !== n.has(i) && !0 !== n.has(r) && (n.add(i, r), true)
            }
            var Sl = Object.freeze({
                __proto__: null,
                BoxGeometry: jn,
                BoxBufferGeometry: jn,
                CircleGeometry: ao,
                CircleBufferGeometry: ao,
                ConeGeometry: oo,
                ConeBufferGeometry: oo,
                CylinderGeometry: so,
                CylinderBufferGeometry: so,
                DodecahedronGeometry: co,
                DodecahedronBufferGeometry: co,
                EdgesGeometry: mo,
                ExtrudeGeometry: dl,
                ExtrudeBufferGeometry: dl,
                IcosahedronGeometry: fl,
                IcosahedronBufferGeometry: fl,
                LatheGeometry: ml,
                LatheBufferGeometry: ml,
                OctahedronGeometry: gl,
                OctahedronBufferGeometry: gl,
                PlaneGeometry: ui,
                PlaneBufferGeometry: ui,
                PolyhedronGeometry: lo,
                PolyhedronBufferGeometry: lo,
                RingGeometry: vl,
                RingBufferGeometry: vl,
                ShapeGeometry: yl,
                ShapeBufferGeometry: yl,
                SphereGeometry: xl,
                SphereBufferGeometry: xl,
                TetrahedronGeometry: bl,
                TetrahedronBufferGeometry: bl,
                TorusGeometry: _l,
                TorusBufferGeometry: _l,
                TorusKnotGeometry: wl,
                TorusKnotBufferGeometry: wl,
                TubeGeometry: El,
                TubeBufferGeometry: El,
                WireframeGeometry: Ml
            });
            class Al extends qt {
                constructor(e) {
                    super(), this.type = "ShadowMaterial", this.color = new tn(0), this.transparent = true, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this
                }
            }
            Al.prototype.isShadowMaterial = true;
            class Ll extends qt {
                constructor(e) {
                    super(), this.defines = {
                        STANDARD: ""
                    }, this.type = "MeshStandardMaterial", this.color = new tn(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new tn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new ge(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.defines = {
                        STANDARD: ""
                    }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this
                }
            }
            Ll.prototype.isMeshStandardMaterial = true;
            class Rl extends Ll {
                constructor(e) {
                    super(), this.defines = {
                        STANDARD: "",
                        PHYSICAL: ""
                    }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new ge(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                        get: function () {
                            return ce(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                        },
                        set: function (e) {
                            this.ior = (1 + .4 * e) / (1 - .4 * e)
                        }
                    }), this.sheenColor = new tn(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new tn(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new tn(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._transmission = 0, this.setValues(e)
                }
                get sheen() {
                    return this._sheen
                }
                set sheen(e) {
                    this._sheen > 0 != e > 0 && this.version++, this._sheen = e
                }
                get clearcoat() {
                    return this._clearcoat
                }
                set clearcoat(e) {
                    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e
                }
                get transmission() {
                    return this._transmission
                }
                set transmission(e) {
                    this._transmission > 0 != e > 0 && this.version++, this._transmission = e
                }
                copy(e) {
                    return super.copy(e), this.defines = {
                        STANDARD: "",
                        PHYSICAL: ""
                    }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this
                }
            }
            Rl.prototype.isMeshPhysicalMaterial = true;
            class Pl extends qt {
                constructor(e) {
                    super(), this.type = "MeshPhongMaterial", this.color = new tn(16777215), this.specular = new tn(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new tn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new ge(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this
                }
            }
            Pl.prototype.isMeshPhongMaterial = true;
            class Cl extends qt {
                constructor(e) {
                    super(), this.defines = {
                        TOON: ""
                    }, this.type = "MeshToonMaterial", this.color = new tn(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new tn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new ge(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this
                }
            }
            Cl.prototype.isMeshToonMaterial = true;
            class Il extends qt {
                constructor(e) {
                    super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new ge(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.flatShading = false, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this
                }
            }
            Il.prototype.isMeshNormalMaterial = true;
            class Fl extends qt {
                constructor(e) {
                    super(), this.type = "MeshLambertMaterial", this.color = new tn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new tn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this
                }
            }
            Fl.prototype.isMeshLambertMaterial = true;
            class Dl extends qt {
                constructor(e) {
                    super(), this.defines = {
                        MATCAP: ""
                    }, this.type = "MeshMatcapMaterial", this.color = new tn(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new ge(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = false, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.defines = {
                        MATCAP: ""
                    }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this
                }
            }
            Dl.prototype.isMeshMatcapMaterial = true;
            class Nl extends Us {
                constructor(e) {
                    super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
                }
                copy(e) {
                    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
                }
            }
            Nl.prototype.isLineDashedMaterial = true;
            var Ol = Object.freeze({
                __proto__: null,
                ShadowMaterial: Al,
                SpriteMaterial: ns,
                RawShaderMaterial: _i,
                ShaderMaterial: qn,
                PointsMaterial: Qs,
                MeshPhysicalMaterial: Rl,
                MeshStandardMaterial: Ll,
                MeshPhongMaterial: Pl,
                MeshToonMaterial: Cl,
                MeshNormalMaterial: Il,
                MeshLambertMaterial: Fl,
                MeshDepthMaterial: Na,
                MeshDistanceMaterial: Oa,
                MeshBasicMaterial: nn,
                MeshMatcapMaterial: Dl,
                LineDashedMaterial: Nl,
                LineBasicMaterial: Us,
                Material: qt
            });
            const Hl = {
                arraySlice: function (e, t, n) {
                    return Hl.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n)
                },
                convertArray: function (e, t, n) {
                    return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
                },
                isTypedArray: function (e) {
                    return ArrayBuffer.isView(e) && !(e instanceof DataView)
                },
                getKeyframeOrder: function (e) {
                    const t = e.length,
                        n = new Array(t);
                    for (let e = 0; e !== t; ++e) n[e] = e;
                    return n.sort((function (t, n) {
                        return e[t] - e[n]
                    })), n
                },
                sortedArray: function (e, t, n) {
                    const i = e.length,
                        r = new e.constructor(i);
                    for (let a = 0, s = 0; s !== i; ++a) {
                        const i = n[a] * t;
                        for (let n = 0; n !== t; ++n) r[s++] = e[i + n]
                    }
                    return r
                },
                flattenJSON: function (e, t, n, i) {
                    let r = 1,
                        a = e[0];
                    for (; void 0 !== a && void 0 === a[i];) a = e[r++];
                    if (void 0 === a) return;
                    let s = a[i];
                    if (void 0 !== s)
                        if (Array.isArray(s))
                            do {
                                s = a[i], void 0 !== s && (t.push(a.time), n.push.apply(n, s)), a = e[r++]
                            } while (void 0 !== a);
                        else if (void 0 !== s.toArray)
                        do {
                            s = a[i], void 0 !== s && (t.push(a.time), s.toArray(n, n.length)), a = e[r++]
                        } while (void 0 !== a);
                    else
                        do {
                            s = a[i], void 0 !== s && (t.push(a.time), n.push(s)), a = e[r++]
                        } while (void 0 !== a)
                },
                subclip: function (e, t, n, i, r = 30) {
                    const a = e.clone();
                    a.name = t;
                    const s = [];
                    for (let e = 0; e < a.tracks.length; ++e) {
                        const t = a.tracks[e],
                            o = t.getValueSize(),
                            l = [],
                            c = [];
                        for (let e = 0; e < t.times.length; ++e) {
                            const a = t.times[e] * r;
                            if (!(a < n || a >= i)) {
                                l.push(t.times[e]);
                                for (let n = 0; n < o; ++n) c.push(t.values[e * o + n])
                            }
                        }
                        0 !== l.length && (t.times = Hl.convertArray(l, t.times.constructor), t.values = Hl.convertArray(c, t.values.constructor), s.push(t))
                    }
                    a.tracks = s;
                    let o = 1 / 0;
                    for (let e = 0; e < a.tracks.length; ++e) o > a.tracks[e].times[0] && (o = a.tracks[e].times[0]);
                    for (let e = 0; e < a.tracks.length; ++e) a.tracks[e].shift(-1 * o);
                    return a.resetDuration(), a
                },
                makeClipAdditive: function (e, t = 0, n = e, i = 30) {
                    i <= 0 && (i = 30);
                    const r = n.tracks.length,
                        a = t / i;
                    for (let t = 0; t < r; ++t) {
                        const i = n.tracks[t],
                            r = i.ValueTypeName;
                        if ("bool" === r || "string" === r) continue;
                        const s = e.tracks.find((function (e) {
                            return e.name === i.name && e.ValueTypeName === r
                        }));
                        if (void 0 === s) continue;
                        let o = 0;
                        const l = i.getValueSize();
                        i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (o = l / 3);
                        let c = 0;
                        const u = s.getValueSize();
                        s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = u / 3);
                        const h = i.times.length - 1;
                        let d;
                        if (a <= i.times[0]) {
                            const e = o,
                                t = l - o;
                            d = Hl.arraySlice(i.values, e, t)
                        } else if (a >= i.times[h]) {
                            const e = h * l + o,
                                t = e + l - o;
                            d = Hl.arraySlice(i.values, e, t)
                        } else {
                            const e = i.createInterpolant(),
                                t = o,
                                n = l - o;
                            e.evaluate(a), d = Hl.arraySlice(e.resultBuffer, t, n)
                        }
                        "quaternion" === r && (new Ie).fromArray(d).normalize().conjugate().toArray(d);
                        const p = s.times.length;
                        for (let e = 0; e < p; ++e) {
                            const t = e * u + c;
                            if ("quaternion" === r) Ie.multiplyQuaternionsFlat(s.values, t, d, 0, s.values, t);
                            else {
                                const e = u - 2 * c;
                                for (let n = 0; n < e; ++n) s.values[t + n] -= d[n]
                            }
                        }
                    }
                    return e.blendMode = W, e
                }
            };
            class Ul {
                constructor(e, t, n, i) {
                    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
                }
                evaluate(e) {
                    const t = this.parameterPositions;
                    let n = this._cachedIndex,
                        i = t[n],
                        r = t[n - 1];
                    e: {
                        t: {
                            let a;n: {
                                i: if (!(e < i)) {
                                    for (let a = n + 2;;) {
                                        if (void 0 === i) {
                                            if (e < r) break i;
                                            return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, e, r)
                                        }
                                        if (n === a) break;
                                        if (r = i, i = t[++n], e < i) break t
                                    }
                                    a = t.length;
                                    break n
                                }if (e >= r) break e; {
                                    const s = t[1];
                                    e < s && (n = 2, r = s);
                                    for (let a = n - 2;;) {
                                        if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, e, i);
                                        if (n === a) break;
                                        if (i = r, r = t[--n - 1], e >= r) break t
                                    }
                                    a = n, n = 0
                                }
                            }
                            for (; n < a;) {
                                const i = n + a >>> 1;
                                e < t[i] ? a = i : n = i + 1
                            }
                            if (i = t[n], r = t[n - 1], void 0 === r) return this._cachedIndex = 0,
                            this.beforeStart_(0, e, i);
                            if (void 0 === i) return n = t.length,
                            this._cachedIndex = n,
                            this.afterEnd_(n - 1, r, e)
                        }
                        this._cachedIndex = n,
                        this.intervalChanged_(n, r, i)
                    }
                    return this.interpolate_(n, r, e, i)
                }
                getSettings_() {
                    return this.settings || this.DefaultSettings_
                }
                copySampleValue_(e) {
                    const t = this.resultBuffer,
                        n = this.sampleValues,
                        i = this.valueSize,
                        r = e * i;
                    for (let e = 0; e !== i; ++e) t[e] = n[r + e];
                    return t
                }
                interpolate_() {
                    throw new Error("call to abstract method")
                }
                intervalChanged_() {}
            }
            Ul.prototype.beforeStart_ = Ul.prototype.copySampleValue_, Ul.prototype.afterEnd_ = Ul.prototype.copySampleValue_;
            class Bl extends Ul {
                constructor(e, t, n, i) {
                    super(e, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                        endingStart: G,
                        endingEnd: G
                    }
                }
                intervalChanged_(e, t, n) {
                    const i = this.parameterPositions;
                    let r = e - 2,
                        a = e + 1,
                        s = i[r],
                        o = i[a];
                    if (void 0 === s) switch (this.getSettings_().endingStart) {
                    case V:
                        r = e, s = 2 * t - n;
                        break;
                    case j:
                        r = i.length - 2, s = t + i[r] - i[r + 1];
                        break;
                    default:
                        r = e, s = n
                    }
                    if (void 0 === o) switch (this.getSettings_().endingEnd) {
                    case V:
                        a = e, o = 2 * n - t;
                        break;
                    case j:
                        a = 1, o = n + i[1] - i[0];
                        break;
                    default:
                        a = e - 1, o = t
                    }
                    const l = .5 * (n - t),
                        c = this.valueSize;
                    this._weightPrev = l / (t - s), this._weightNext = l / (o - n), this._offsetPrev = r * c, this._offsetNext = a * c
                }
                interpolate_(e, t, n, i) {
                    const r = this.resultBuffer,
                        a = this.sampleValues,
                        s = this.valueSize,
                        o = e * s,
                        l = o - s,
                        c = this._offsetPrev,
                        u = this._offsetNext,
                        h = this._weightPrev,
                        d = this._weightNext,
                        p = (n - t) / (i - t),
                        f = p * p,
                        m = f * p,
                        g = -h * m + 2 * h * f - h * p,
                        v = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1,
                        y = (-1 - d) * m + (1.5 + d) * f + .5 * p,
                        x = d * m - d * f;
                    for (let e = 0; e !== s; ++e) r[e] = g * a[c + e] + v * a[l + e] + y * a[o + e] + x * a[u + e];
                    return r
                }
            }
            class zl extends Ul {
                constructor(e, t, n, i) {
                    super(e, t, n, i)
                }
                interpolate_(e, t, n, i) {
                    const r = this.resultBuffer,
                        a = this.sampleValues,
                        s = this.valueSize,
                        o = e * s,
                        l = o - s,
                        c = (n - t) / (i - t),
                        u = 1 - c;
                    for (let e = 0; e !== s; ++e) r[e] = a[l + e] * u + a[o + e] * c;
                    return r
                }
            }
            class kl extends Ul {
                constructor(e, t, n, i) {
                    super(e, t, n, i)
                }
                interpolate_(e) {
                    return this.copySampleValue_(e - 1)
                }
            }
            class Gl {
                constructor(e, t, n, i) {
                    if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined");
                    if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                    this.name = e, this.times = Hl.convertArray(t, this.TimeBufferType), this.values = Hl.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
                }
                static toJSON(e) {
                    const t = e.constructor;
                    let n;
                    if (t.toJSON !== this.toJSON) n = t.toJSON(e);
                    else {
                        n = {
                            name: e.name,
                            times: Hl.convertArray(e.times, Array),
                            values: Hl.convertArray(e.values, Array)
                        };
                        const t = e.getInterpolation();
                        t !== e.DefaultInterpolation && (n.interpolation = t)
                    }
                    return n.type = e.ValueTypeName, n
                }
                InterpolantFactoryMethodDiscrete(e) {
                    return new kl(this.times, this.values, this.getValueSize(), e)
                }
                InterpolantFactoryMethodLinear(e) {
                    return new zl(this.times, this.values, this.getValueSize(), e)
                }
                InterpolantFactoryMethodSmooth(e) {
                    return new Bl(this.times, this.values, this.getValueSize(), e)
                }
                setInterpolation(e) {
                    let t;
                    switch (e) {
                    case B:
                        t = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case z:
                        t = this.InterpolantFactoryMethodLinear;
                        break;
                    case k:
                        t = this.InterpolantFactoryMethodSmooth
                    }
                    if (void 0 === t) {
                        const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                        if (void 0 === this.createInterpolant) {
                            if (e === this.DefaultInterpolation) throw new Error(t);
                            this.setInterpolation(this.DefaultInterpolation)
                        }
                        return console.warn("THREE.KeyframeTrack:", t), this
                    }
                    return this.createInterpolant = t, this
                }
                getInterpolation() {
                    switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return B;
                    case this.InterpolantFactoryMethodLinear:
                        return z;
                    case this.InterpolantFactoryMethodSmooth:
                        return k
                    }
                }
                getValueSize() {
                    return this.values.length / this.times.length
                }
                shift(e) {
                    if (0 !== e) {
                        const t = this.times;
                        for (let n = 0, i = t.length; n !== i; ++n) t[n] += e
                    }
                    return this
                }
                scale(e) {
                    if (1 !== e) {
                        const t = this.times;
                        for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e
                    }
                    return this
                }
                trim(e, t) {
                    const n = this.times,
                        i = n.length;
                    let r = 0,
                        a = i - 1;
                    for (; r !== i && n[r] < e;) ++r;
                    for (; - 1 !== a && n[a] > t;) --a;
                    if (++a, 0 !== r || a !== i) {
                        r >= a && (a = Math.max(a, 1), r = a - 1);
                        const e = this.getValueSize();
                        this.times = Hl.arraySlice(n, r, a), this.values = Hl.arraySlice(this.values, r * e, a * e)
                    }
                    return this
                }
                validate() {
                    let e = true;
                    const t = this.getValueSize();
                    t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = false);
                    const n = this.times,
                        i = this.values,
                        r = n.length;
                    0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = false);
                    let a = null;
                    for (let t = 0; t !== r; t++) {
                        const i = n[t];
                        if ("number" == typeof i && isNaN(i)) {
                            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, t, i), e = false;
                            break
                        }
                        if (null !== a && a > i) {
                            console.error("THREE.KeyframeTrack: Out of order keys.", this, t, i, a), e = false;
                            break
                        }
                        a = i
                    }
                    if (void 0 !== i && Hl.isTypedArray(i))
                        for (let t = 0, n = i.length; t !== n; ++t) {
                            const n = i[t];
                            if (isNaN(n)) {
                                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, t, n), e = false;
                                break
                            }
                        }
                    return e
                }
                optimize() {
                    const e = Hl.arraySlice(this.times),
                        t = Hl.arraySlice(this.values),
                        n = this.getValueSize(),
                        i = this.getInterpolation() === k,
                        r = e.length - 1;
                    let a = 1;
                    for (let s = 1; s < r; ++s) {
                        let r = false;
                        const o = e[s];
                        if (o !== e[s + 1] && (1 !== s || o !== e[0]))
                            if (i) r = true;
                            else {
                                const e = s * n,
                                    i = e - n,
                                    a = e + n;
                                for (let s = 0; s !== n; ++s) {
                                    const n = t[e + s];
                                    if (n !== t[i + s] || n !== t[a + s]) {
                                        r = true;
                                        break
                                    }
                                }
                            } if (r) {
                            if (s !== a) {
                                e[a] = e[s];
                                const i = s * n,
                                    r = a * n;
                                for (let e = 0; e !== n; ++e) t[r + e] = t[i + e]
                            }++a
                        }
                    }
                    if (r > 0) {
                        e[a] = e[r];
                        for (let e = r * n, i = a * n, s = 0; s !== n; ++s) t[i + s] = t[e + s];
                        ++a
                    }
                    return a !== e.length ? (this.times = Hl.arraySlice(e, 0, a), this.values = Hl.arraySlice(t, 0, a * n)) : (this.times = e, this.values = t), this
                }
                clone() {
                    const e = Hl.arraySlice(this.times, 0),
                        t = Hl.arraySlice(this.values, 0),
                        n = new(0, this.constructor)(this.name, e, t);
                    return n.createInterpolant = this.createInterpolant, n
                }
            }
            Gl.prototype.TimeBufferType = Float32Array, Gl.prototype.ValueBufferType = Float32Array, Gl.prototype.DefaultInterpolation = z;
            class Vl extends Gl {}
            Vl.prototype.ValueTypeName = "bool", Vl.prototype.ValueBufferType = Array, Vl.prototype.DefaultInterpolation = B, Vl.prototype.InterpolantFactoryMethodLinear = void 0, Vl.prototype.InterpolantFactoryMethodSmooth = void 0;
            class jl extends Gl {}
            jl.prototype.ValueTypeName = "color";
            class Wl extends Gl {}
            Wl.prototype.ValueTypeName = "number";
            class Xl extends Ul {
                constructor(e, t, n, i) {
                    super(e, t, n, i)
                }
                interpolate_(e, t, n, i) {
                    const r = this.resultBuffer,
                        a = this.sampleValues,
                        s = this.valueSize,
                        o = (n - t) / (i - t);
                    let l = e * s;
                    for (let e = l + s; l !== e; l += 4) Ie.slerpFlat(r, 0, a, l - s, a, l, o);
                    return r
                }
            }
            class Yl extends Gl {
                InterpolantFactoryMethodLinear(e) {
                    return new Xl(this.times, this.values, this.getValueSize(), e)
                }
            }
            Yl.prototype.ValueTypeName = "quaternion", Yl.prototype.DefaultInterpolation = z, Yl.prototype.InterpolantFactoryMethodSmooth = void 0;
            class ql extends Gl {}
            ql.prototype.ValueTypeName = "string", ql.prototype.ValueBufferType = Array, ql.prototype.DefaultInterpolation = B, ql.prototype.InterpolantFactoryMethodLinear = void 0, ql.prototype.InterpolantFactoryMethodSmooth = void 0;
            class Ql extends Gl {}
            Ql.prototype.ValueTypeName = "vector";
            class Jl {
                constructor(e, t = -1, n, i = 2500) {
                    this.name = e, this.tracks = n, this.duration = t, this.blendMode = i, this.uuid = le(), this.duration < 0 && this.resetDuration()
                }
                static parse(e) {
                    const t = [],
                        n = e.tracks,
                        i = 1 / (e.fps || 1);
                    for (let e = 0, r = n.length; e !== r; ++e) t.push(Zl(n[e]).scale(i));
                    const r = new this(e.name, e.duration, t, e.blendMode);
                    return r.uuid = e.uuid, r
                }
                static toJSON(e) {
                    const t = [],
                        n = e.tracks,
                        i = {
                            name: e.name,
                            duration: e.duration,
                            tracks: t,
                            uuid: e.uuid,
                            blendMode: e.blendMode
                        };
                    for (let e = 0, i = n.length; e !== i; ++e) t.push(Gl.toJSON(n[e]));
                    return i
                }
                static CreateFromMorphTargetSequence(e, t, n, i) {
                    const r = t.length,
                        a = [];
                    for (let e = 0; e < r; e++) {
                        let s = [],
                            o = [];
                        s.push((e + r - 1) % r, e, (e + 1) % r), o.push(0, 1, 0);
                        const l = Hl.getKeyframeOrder(s);
                        s = Hl.sortedArray(s, 1, l), o = Hl.sortedArray(o, 1, l), i || 0 !== s[0] || (s.push(r), o.push(o[0])), a.push(new Wl(".morphTargetInfluences[" + t[e].name + "]", s, o).scale(1 / n))
                    }
                    return new this(e, -1, a)
                }
                static findByName(e, t) {
                    let n = e;
                    if (!Array.isArray(e)) {
                        const t = e;
                        n = t.geometry && t.geometry.animations || t.animations
                    }
                    for (let e = 0; e < n.length; e++)
                        if (n[e].name === t) return n[e];
                    return null
                }
                static CreateClipsFromMorphTargetSequences(e, t, n) {
                    const i = {},
                        r = /^([\w-]*?)([\d]+)$/;
                    for (let t = 0, n = e.length; t < n; t++) {
                        const n = e[t],
                            a = n.name.match(r);
                        if (a && a.length > 1) {
                            const e = a[1];
                            let t = i[e];
                            t || (i[e] = t = []), t.push(n)
                        }
                    }
                    const a = [];
                    for (const e in i) a.push(this.CreateFromMorphTargetSequence(e, i[e], t, n));
                    return a
                }
                static parseAnimation(e, t) {
                    if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                    const n = function (e, t, n, i, r) {
                            if (0 !== n.length) {
                                const a = [],
                                    s = [];
                                Hl.flattenJSON(n, a, s, i), 0 !== a.length && r.push(new e(t, a, s))
                            }
                        },
                        i = [],
                        r = e.name || "default",
                        a = e.fps || 30,
                        s = e.blendMode;
                    let o = e.length || -1;
                    const l = e.hierarchy || [];
                    for (let e = 0; e < l.length; e++) {
                        const r = l[e].keys;
                        if (r && 0 !== r.length)
                            if (r[0].morphTargets) {
                                const e = {};
                                let t;
                                for (t = 0; t < r.length; t++)
                                    if (r[t].morphTargets)
                                        for (let n = 0; n < r[t].morphTargets.length; n++) e[r[t].morphTargets[n]] = -1;
                                for (const n in e) {
                                    const e = [],
                                        a = [];
                                    for (let i = 0; i !== r[t].morphTargets.length; ++i) {
                                        const i = r[t];
                                        e.push(i.time), a.push(i.morphTarget === n ? 1 : 0)
                                    }
                                    i.push(new Wl(".morphTargetInfluence[" + n + "]", e, a))
                                }
                                o = e.length * (a || 1)
                            } else {
                                const a = ".bones[" + t[e].name + "]";
                                n(Ql, a + ".position", r, "pos", i), n(Yl, a + ".quaternion", r, "rot", i), n(Ql, a + ".scale", r, "scl", i)
                            }
                    }
                    return 0 === i.length ? null : new this(r, o, i, s)
                }
                resetDuration() {
                    let e = 0;
                    for (let t = 0, n = this.tracks.length; t !== n; ++t) {
                        const n = this.tracks[t];
                        e = Math.max(e, n.times[n.times.length - 1])
                    }
                    return this.duration = e, this
                }
                trim() {
                    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
                    return this
                }
                validate() {
                    let e = true;
                    for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
                    return e
                }
                optimize() {
                    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
                    return this
                }
                clone() {
                    const e = [];
                    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
                    return new this.constructor(this.name, this.duration, e, this.blendMode)
                }
                toJSON() {
                    return this.constructor.toJSON(this)
                }
            }
            function Zl(e) {
                if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                const t = function (e) {
                    switch (e.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                        return Wl;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                        return Ql;
                    case "color":
                        return jl;
                    case "quaternion":
                        return Yl;
                    case "bool":
                    case "boolean":
                        return Vl;
                    case "string":
                        return ql
                    }
                    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
                }(e.type);
                if (void 0 === e.times) {
                    const t = [],
                        n = [];
                    Hl.flattenJSON(e.keys, t, n, "value"), e.times = t, e.values = n
                }
                return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
            }
            const Kl = {
                enabled: false,
                files: {},
                add: function (e, t) {
                    !1 !== this.enabled && (this.files[e] = t)
                },
                get: function (e) {
                    if (!1 !== this.enabled) return this.files[e]
                },
                remove: function (e) {
                    delete this.files[e]
                },
                clear: function () {
                    this.files = {}
                }
            };
            class $l {
                constructor(e, t, n) {
                    const i = this;
                    let r, a = false,
                        s = 0,
                        o = 0;
                    const l = [];
                    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function (e) {
                        o++, !1 === a && void 0 !== i.onStart && i.onStart(e, s, o), a = true
                    }, this.itemEnd = function (e) {
                        s++, void 0 !== i.onProgress && i.onProgress(e, s, o), s === o && (a = false, void 0 !== i.onLoad && i.onLoad())
                    }, this.itemError = function (e) {
                        void 0 !== i.onError && i.onError(e)
                    }, this.resolveURL = function (e) {
                        return r ? r(e) : e
                    }, this.setURLModifier = function (e) {
                        return r = e, this
                    }, this.addHandler = function (e, t) {
                        return l.push(e, t), this
                    }, this.removeHandler = function (e) {
                        const t = l.indexOf(e);
                        return -1 !== t && l.splice(t, 2), this
                    }, this.getHandler = function (e) {
                        for (let t = 0, n = l.length; t < n; t += 2) {
                            const n = l[t],
                                i = l[t + 1];
                            if (n.global && (n.lastIndex = 0), n.test(e)) return i
                        }
                        return null
                    }
                }
            }
            const ec = new $l;
            class tc {
                constructor(e) {
                    this.manager = void 0 !== e ? e : ec, this.crossOrigin = "anonymous", this.withCredentials = false, this.path = "", this.resourcePath = "", this.requestHeader = {}
                }
                load() {}
                loadAsync(e, t) {
                    const n = this;
                    return new Promise((function (i, r) {
                        n.load(e, i, t, r)
                    }))
                }
                parse() {}
                setCrossOrigin(e) {
                    return this.crossOrigin = e, this
                }
                setWithCredentials(e) {
                    return this.withCredentials = e, this
                }
                setPath(e) {
                    return this.path = e, this
                }
                setResourcePath(e) {
                    return this.resourcePath = e, this
                }
                setRequestHeader(e) {
                    return this.requestHeader = e, this
                }
            }
            const nc = {};
            class ic extends tc {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, i) {
                    void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    const r = Kl.get(e);
                    if (void 0 !== r) return this.manager.itemStart(e), setTimeout((() => {
                        t && t(r), this.manager.itemEnd(e)
                    }), 0), r;
                    if (void 0 !== nc[e]) return void nc[e].push({
                        onLoad: t,
                        onProgress: n,
                        onError: i
                    });
                    nc[e] = [], nc[e].push({
                        onLoad: t,
                        onProgress: n,
                        onError: i
                    });
                    const a = new Request(e, {
                        headers: new Headers(this.requestHeader),
                        credentials: this.withCredentials ? "include" : "same-origin"
                    });
                    fetch(a).then((t => {
                        if (200 === t.status || 0 === t.status) {
                            0 === t.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                            const n = nc[e],
                                i = t.body.getReader(),
                                r = t.headers.get("Content-Length"),
                                a = r ? parseInt(r) : 0,
                                s = 0 !== a;
                            let o = 0;
                            return new ReadableStream({
                                start(e) {
                                    ! function t() {
                                        i.read().then((({
                                            done: i,
                                            value: r
                                        }) => {
                                            if (i) e.close();
                                            else {
                                                o += r.byteLength;
                                                const i = new ProgressEvent("progress", {
                                                    lengthComputable: s,
                                                    loaded: o,
                                                    total: a
                                                });
                                                for (let e = 0, t = n.length; e < t; e++) {
                                                    const t = n[e];
                                                    t.onProgress && t.onProgress(i)
                                                }
                                                e.enqueue(r), t()
                                            }
                                        }))
                                    }()
                                }
                            })
                        }
                        throw Error(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`)
                    })).then((e => {
                        const t = new Response(e);
                        switch (this.responseType) {
                        case "arraybuffer":
                            return t.arrayBuffer();
                        case "blob":
                            return t.blob();
                        case "document":
                            return t.text().then((e => (new DOMParser).parseFromString(e, this.mimeType)));
                        case "json":
                            return t.json();
                        default:
                            return t.text()
                        }
                    })).then((t => {
                        Kl.add(e, t);
                        const n = nc[e];
                        delete nc[e];
                        for (let e = 0, i = n.length; e < i; e++) {
                            const i = n[e];
                            i.onLoad && i.onLoad(t)
                        }
                        this.manager.itemEnd(e)
                    })).catch((t => {
                        const n = nc[e];
                        delete nc[e];
                        for (let e = 0, i = n.length; e < i; e++) {
                            const i = n[e];
                            i.onError && i.onError(t)
                        }
                        this.manager.itemError(e), this.manager.itemEnd(e)
                    })), this.manager.itemStart(e)
                }
                setResponseType(e) {
                    return this.responseType = e, this
                }
                setMimeType(e) {
                    return this.mimeType = e, this
                }
            }
            class rc extends tc {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, i) {
                    void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    const r = this,
                        a = Kl.get(e);
                    if (void 0 !== a) return r.manager.itemStart(e), setTimeout((function () {
                        t && t(a), r.manager.itemEnd(e)
                    }), 0), a;
                    const s = _e("img");
                    function o() {
                        c(), Kl.add(e, this), t && t(this), r.manager.itemEnd(e)
                    }
                    function l(t) {
                        c(), i && i(t), r.manager.itemError(e), r.manager.itemEnd(e)
                    }
                    function c() {
                        s.removeEventListener("load", o, false), s.removeEventListener("error", l, false)
                    }
                    return s.addEventListener("load", o, false), s.addEventListener("error", l, false), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin), r.manager.itemStart(e), s.src = e, s
                }
            }
            class ac extends tc {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, i) {
                    const r = new $n,
                        a = new rc(this.manager);
                    a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
                    let s = 0;
                    function o(n) {
                        a.load(e[n], (function (e) {
                            r.images[n] = e, s++, 6 === s && (r.needsUpdate = true, t && t(r))
                        }), void 0, i)
                    }
                    for (let t = 0; t < e.length; ++t) o(t);
                    return r
                }
            }
            class sc extends tc {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, i) {
                    const r = this,
                        a = new Ls,
                        s = new ic(this.manager);
                    return s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setPath(this.path), s.setWithCredentials(r.withCredentials), s.load(e, (function (e) {
                        const n = r.parse(e);
                        n && (void 0 !== n.image ? a.image = n.image : void 0 !== n.data && (a.image.width = n.width, a.image.height = n.height, a.image.data = n.data), a.wrapS = void 0 !== n.wrapS ? n.wrapS : h, a.wrapT = void 0 !== n.wrapT ? n.wrapT : h, a.magFilter = void 0 !== n.magFilter ? n.magFilter : g, a.minFilter = void 0 !== n.minFilter ? n.minFilter : g, a.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.encoding && (a.encoding = n.encoding), void 0 !== n.flipY && (a.flipY = n.flipY), void 0 !== n.format && (a.format = n.format), void 0 !== n.type && (a.type = n.type), void 0 !== n.mipmaps && (a.mipmaps = n.mipmaps, a.minFilter = y), 1 === n.mipmapCount && (a.minFilter = g), void 0 !== n.generateMipmaps && (a.generateMipmaps = n.generateMipmaps), a.needsUpdate = true, t && t(a, n))
                    }), n, i), a
                }
            }
            class oc extends tc {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, i) {
                    const r = new Se,
                        a = new rc(this.manager);
                    return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, (function (e) {
                        r.image = e, r.needsUpdate = true, void 0 !== t && t(r)
                    }), n, i), r
                }
            }
            class lc extends Nt {
                constructor(e, t = 1) {
                    super(), this.type = "Light", this.color = new tn(e), this.intensity = t
                }
                dispose() {}
                copy(e) {
                    return super.copy(e), this.color.copy(e.color), this.intensity = e.intensity, this
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t
                }
            }
            lc.prototype.isLight = true;
            class cc extends lc {
                constructor(e, t, n) {
                    super(e, n), this.type = "HemisphereLight", this.position.copy(Nt.DefaultUp), this.updateMatrix(), this.groundColor = new tn(t)
                }
                copy(e) {
                    return lc.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this
                }
            }
            cc.prototype.isHemisphereLight = true;
            const uc = new ut,
                hc = new Fe,
                dc = new Fe;
            class pc {
                constructor(e) {
                    this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new ge(512, 512), this.map = null, this.mapPass = null, this.matrix = new ut, this.autoUpdate = true, this.needsUpdate = false, this._frustum = new oi, this._frameExtents = new ge(1, 1), this._viewportCount = 1, this._viewports = [new Le(0, 0, 1, 1)]
                }
                getViewportCount() {
                    return this._viewportCount
                }
                getFrustum() {
                    return this._frustum
                }
                updateMatrices(e) {
                    const t = this.camera,
                        n = this.matrix;
                    hc.setFromMatrixPosition(e.matrixWorld), t.position.copy(hc), dc.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(dc), t.updateMatrixWorld(), uc.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(uc), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(t.projectionMatrix), n.multiply(t.matrixWorldInverse)
                }
                getViewport(e) {
                    return this._viewports[e]
                }
                getFrameExtents() {
                    return this._frameExtents
                }
                dispose() {
                    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
                }
                copy(e) {
                    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                toJSON() {
                    const e = {};
                    return 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(false).object, delete e.camera.matrix, e
                }
            }
            class fc extends pc {
                constructor() {
                    super(new Jn(50, 1, .5, 500)), this.focus = 1
                }
                updateMatrices(e) {
                    const t = this.camera,
                        n = 2 * oe * e.angle * this.focus,
                        i = this.mapSize.width / this.mapSize.height,
                        r = e.distance || t.far;
                    n === t.fov && i === t.aspect && r === t.far || (t.fov = n, t.aspect = i, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e)
                }
                copy(e) {
                    return super.copy(e), this.focus = e.focus, this
                }
            }
            fc.prototype.isSpotLightShadow = true;
            class mc extends lc {
                constructor(e, t, n = 0, i = Math.PI / 3, r = 0, a = 1) {
                    super(e, t), this.type = "SpotLight", this.position.copy(Nt.DefaultUp), this.updateMatrix(), this.target = new Nt, this.distance = n, this.angle = i, this.penumbra = r, this.decay = a, this.shadow = new fc
                }
                get power() {
                    return this.intensity * Math.PI
                }
                set power(e) {
                    this.intensity = e / Math.PI
                }
                dispose() {
                    this.shadow.dispose()
                }
                copy(e) {
                    return super.copy(e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
                }
            }
            mc.prototype.isSpotLight = true;
            const gc = new ut,
                vc = new Fe,
                yc = new Fe;
            class xc extends pc {
                constructor() {
                    super(new Jn(90, 1, .5, 500)), this._frameExtents = new ge(4, 2), this._viewportCount = 6, this._viewports = [new Le(2, 1, 1, 1), new Le(0, 1, 1, 1), new Le(3, 1, 1, 1), new Le(1, 1, 1, 1), new Le(3, 0, 1, 1), new Le(1, 0, 1, 1)], this._cubeDirections = [new Fe(1, 0, 0), new Fe(-1, 0, 0), new Fe(0, 0, 1), new Fe(0, 0, -1), new Fe(0, 1, 0), new Fe(0, -1, 0)], this._cubeUps = [new Fe(0, 1, 0), new Fe(0, 1, 0), new Fe(0, 1, 0), new Fe(0, 1, 0), new Fe(0, 0, 1), new Fe(0, 0, -1)]
                }
                updateMatrices(e, t = 0) {
                    const n = this.camera,
                        i = this.matrix,
                        r = e.distance || n.far;
                    r !== n.far && (n.far = r, n.updateProjectionMatrix()), vc.setFromMatrixPosition(e.matrixWorld), n.position.copy(vc), yc.copy(n.position), yc.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(yc), n.updateMatrixWorld(), i.makeTranslation(-vc.x, -vc.y, -vc.z), gc.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(gc)
                }
            }
            xc.prototype.isPointLightShadow = true;
            class bc extends lc {
                constructor(e, t, n = 0, i = 1) {
                    super(e, t), this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new xc
                }
                get power() {
                    return 4 * this.intensity * Math.PI
                }
                set power(e) {
                    this.intensity = e / (4 * Math.PI)
                }
                dispose() {
                    this.shadow.dispose()
                }
                copy(e) {
                    return super.copy(e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
                }
            }
            bc.prototype.isPointLight = true;
            class _c extends pc {
                constructor() {
                    super(new bi(-5, 5, 5, -5, .5, 500))
                }
            }
            _c.prototype.isDirectionalLightShadow = true;
            class wc extends lc {
                constructor(e, t) {
                    super(e, t), this.type = "DirectionalLight", this.position.copy(Nt.DefaultUp), this.updateMatrix(), this.target = new Nt, this.shadow = new _c
                }
                dispose() {
                    this.shadow.dispose()
                }
                copy(e) {
                    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
                }
            }
            wc.prototype.isDirectionalLight = true;
            class Ec extends lc {
                constructor(e, t) {
                    super(e, t), this.type = "AmbientLight"
                }
            }
            Ec.prototype.isAmbientLight = true;
            class Mc extends lc {
                constructor(e, t, n = 10, i = 10) {
                    super(e, t), this.type = "RectAreaLight", this.width = n, this.height = i
                }
                get power() {
                    return this.intensity * this.width * this.height * Math.PI
                }
                set power(e) {
                    this.intensity = e / (this.width * this.height * Math.PI)
                }
                copy(e) {
                    return super.copy(e), this.width = e.width, this.height = e.height, this
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return t.object.width = this.width, t.object.height = this.height, t
                }
            }
            Mc.prototype.isRectAreaLight = true;
            class Tc {
                constructor() {
                    this.coefficients = [];
                    for (let e = 0; e < 9; e++) this.coefficients.push(new Fe)
                }
                set(e) {
                    for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
                    return this
                }
                zero() {
                    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
                    return this
                }
                getAt(e, t) {
                    const n = e.x,
                        i = e.y,
                        r = e.z,
                        a = this.coefficients;
                    return t.copy(a[0]).multiplyScalar(.282095), t.addScaledVector(a[1], .488603 * i), t.addScaledVector(a[2], .488603 * r), t.addScaledVector(a[3], .488603 * n), t.addScaledVector(a[4], n * i * 1.092548), t.addScaledVector(a[5], i * r * 1.092548), t.addScaledVector(a[6], .315392 * (3 * r * r - 1)), t.addScaledVector(a[7], n * r * 1.092548), t.addScaledVector(a[8], .546274 * (n * n - i * i)), t
                }
                getIrradianceAt(e, t) {
                    const n = e.x,
                        i = e.y,
                        r = e.z,
                        a = this.coefficients;
                    return t.copy(a[0]).multiplyScalar(.886227), t.addScaledVector(a[1], 1.023328 * i), t.addScaledVector(a[2], 1.023328 * r), t.addScaledVector(a[3], 1.023328 * n), t.addScaledVector(a[4], .858086 * n * i), t.addScaledVector(a[5], .858086 * i * r), t.addScaledVector(a[6], .743125 * r * r - .247708), t.addScaledVector(a[7], .858086 * n * r), t.addScaledVector(a[8], .429043 * (n * n - i * i)), t
                }
                add(e) {
                    for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
                    return this
                }
                addScaledSH(e, t) {
                    for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(e.coefficients[n], t);
                    return this
                }
                scale(e) {
                    for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
                    return this
                }
                lerp(e, t) {
                    for (let n = 0; n < 9; n++) this.coefficients[n].lerp(e.coefficients[n], t);
                    return this
                }
                equals(e) {
                    for (let t = 0; t < 9; t++)
                        if (!this.coefficients[t].equals(e.coefficients[t])) return false;
                    return true
                }
                copy(e) {
                    return this.set(e.coefficients)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                fromArray(e, t = 0) {
                    const n = this.coefficients;
                    for (let i = 0; i < 9; i++) n[i].fromArray(e, t + 3 * i);
                    return this
                }
                toArray(e = [], t = 0) {
                    const n = this.coefficients;
                    for (let i = 0; i < 9; i++) n[i].toArray(e, t + 3 * i);
                    return e
                }
                static getBasisAt(e, t) {
                    const n = e.x,
                        i = e.y,
                        r = e.z;
                    t[0] = .282095, t[1] = .488603 * i, t[2] = .488603 * r, t[3] = .488603 * n, t[4] = 1.092548 * n * i, t[5] = 1.092548 * i * r, t[6] = .315392 * (3 * r * r - 1), t[7] = 1.092548 * n * r, t[8] = .546274 * (n * n - i * i)
                }
            }
            Tc.prototype.isSphericalHarmonics3 = true;
            class Sc extends lc {
                constructor(e = new Tc, t = 1) {
                    super(void 0, t), this.sh = e
                }
                copy(e) {
                    return super.copy(e), this.sh.copy(e.sh), this
                }
                fromJSON(e) {
                    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return t.object.sh = this.sh.toArray(), t
                }
            }
            Sc.prototype.isLightProbe = true;
            class Ac extends tc {
                constructor(e) {
                    super(e), this.textures = {}
                }
                load(e, t, n, i) {
                    const r = this,
                        a = new ic(r.manager);
                    a.setPath(r.path), a.setRequestHeader(r.requestHeader), a.setWithCredentials(r.withCredentials), a.load(e, (function (n) {
                        try {
                            t(r.parse(JSON.parse(n)))
                        } catch (t) {
                            i ? i(t) : console.error(t), r.manager.itemError(e)
                        }
                    }), n, i)
                }
                parse(e) {
                    const t = this.textures;
                    function n(e) {
                        return void 0 === t[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), t[e]
                    }
                    const i = new Ol[e.type];
                    if (void 0 !== e.uuid && (i.uuid = e.uuid), void 0 !== e.name && (i.name = e.name), void 0 !== e.color && void 0 !== i.color && i.color.setHex(e.color), void 0 !== e.roughness && (i.roughness = e.roughness), void 0 !== e.metalness && (i.metalness = e.metalness), void 0 !== e.sheen && (i.sheen = e.sheen), void 0 !== e.sheenColor && (i.sheenColor = (new tn).setHex(e.sheenColor)), void 0 !== e.sheenRoughness && (i.sheenRoughness = e.sheenRoughness), void 0 !== e.emissive && void 0 !== i.emissive && i.emissive.setHex(e.emissive), void 0 !== e.specular && void 0 !== i.specular && i.specular.setHex(e.specular), void 0 !== e.specularIntensity && (i.specularIntensity = e.specularIntensity), void 0 !== e.specularColor && void 0 !== i.specularColor && i.specularColor.setHex(e.specularColor), void 0 !== e.shininess && (i.shininess = e.shininess), void 0 !== e.clearcoat && (i.clearcoat = e.clearcoat), void 0 !== e.clearcoatRoughness && (i.clearcoatRoughness = e.clearcoatRoughness), void 0 !== e.transmission && (i.transmission = e.transmission), void 0 !== e.thickness && (i.thickness = e.thickness), void 0 !== e.attenuationDistance && (i.attenuationDistance = e.attenuationDistance), void 0 !== e.attenuationColor && void 0 !== i.attenuationColor && i.attenuationColor.setHex(e.attenuationColor), void 0 !== e.fog && (i.fog = e.fog), void 0 !== e.flatShading && (i.flatShading = e.flatShading), void 0 !== e.blending && (i.blending = e.blending), void 0 !== e.combine && (i.combine = e.combine), void 0 !== e.side && (i.side = e.side), void 0 !== e.shadowSide && (i.shadowSide = e.shadowSide), void 0 !== e.opacity && (i.opacity = e.opacity), void 0 !== e.format && (i.format = e.format), void 0 !== e.transparent && (i.transparent = e.transparent), void 0 !== e.alphaTest && (i.alphaTest = e.alphaTest), void 0 !== e.depthTest && (i.depthTest = e.depthTest), void 0 !== e.depthWrite && (i.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (i.colorWrite = e.colorWrite), void 0 !== e.stencilWrite && (i.stencilWrite = e.stencilWrite), void 0 !== e.stencilWriteMask && (i.stencilWriteMask = e.stencilWriteMask), void 0 !== e.stencilFunc && (i.stencilFunc = e.stencilFunc), void 0 !== e.stencilRef && (i.stencilRef = e.stencilRef), void 0 !== e.stencilFuncMask && (i.stencilFuncMask = e.stencilFuncMask), void 0 !== e.stencilFail && (i.stencilFail = e.stencilFail), void 0 !== e.stencilZFail && (i.stencilZFail = e.stencilZFail), void 0 !== e.stencilZPass && (i.stencilZPass = e.stencilZPass), void 0 !== e.wireframe && (i.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (i.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (i.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (i.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (i.rotation = e.rotation), 1 !== e.linewidth && (i.linewidth = e.linewidth), void 0 !== e.dashSize && (i.dashSize = e.dashSize), void 0 !== e.gapSize && (i.gapSize = e.gapSize), void 0 !== e.scale && (i.scale = e.scale), void 0 !== e.polygonOffset && (i.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (i.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (i.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.dithering && (i.dithering = e.dithering), void 0 !== e.alphaToCoverage && (i.alphaToCoverage = e.alphaToCoverage), void 0 !== e.premultipliedAlpha && (i.premultipliedAlpha = e.premultipliedAlpha), void 0 !== e.visible && (i.visible = e.visible), void 0 !== e.toneMapped && (i.toneMapped = e.toneMapped), void 0 !== e.userData && (i.userData = e.userData), void 0 !== e.vertexColors && ("number" == typeof e.vertexColors ? i.vertexColors = e.vertexColors > 0 : i.vertexColors = e.vertexColors), void 0 !== e.uniforms)
                        for (const t in e.uniforms) {
                            const r = e.uniforms[t];
                            switch (i.uniforms[t] = {}, r.type) {
                            case "t":
                                i.uniforms[t].value = n(r.value);
                                break;
                            case "c":
                                i.uniforms[t].value = (new tn).setHex(r.value);
                                break;
                            case "v2":
                                i.uniforms[t].value = (new ge).fromArray(r.value);
                                break;
                            case "v3":
                                i.uniforms[t].value = (new Fe).fromArray(r.value);
                                break;
                            case "v4":
                                i.uniforms[t].value = (new Le).fromArray(r.value);
                                break;
                            case "m3":
                                i.uniforms[t].value = (new ve).fromArray(r.value);
                                break;
                            case "m4":
                                i.uniforms[t].value = (new ut).fromArray(r.value);
                                break;
                            default:
                                i.uniforms[t].value = r.value
                            }
                        }
                    if (void 0 !== e.defines && (i.defines = e.defines), void 0 !== e.vertexShader && (i.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (i.fragmentShader = e.fragmentShader), void 0 !== e.extensions)
                        for (const t in e.extensions) i.extensions[t] = e.extensions[t];
                    if (void 0 !== e.shading && (i.flatShading = 1 === e.shading), void 0 !== e.size && (i.size = e.size), void 0 !== e.sizeAttenuation && (i.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (i.map = n(e.map)), void 0 !== e.matcap && (i.matcap = n(e.matcap)), void 0 !== e.alphaMap && (i.alphaMap = n(e.alphaMap)), void 0 !== e.bumpMap && (i.bumpMap = n(e.bumpMap)), void 0 !== e.bumpScale && (i.bumpScale = e.bumpScale), void 0 !== e.normalMap && (i.normalMap = n(e.normalMap)), void 0 !== e.normalMapType && (i.normalMapType = e.normalMapType), void 0 !== e.normalScale) {
                        let t = e.normalScale;
                        !1 === Array.isArray(t) && (t = [t, t]), i.normalScale = (new ge).fromArray(t)
                    }
                    return void 0 !== e.displacementMap && (i.displacementMap = n(e.displacementMap)), void 0 !== e.displacementScale && (i.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (i.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (i.roughnessMap = n(e.roughnessMap)), void 0 !== e.metalnessMap && (i.metalnessMap = n(e.metalnessMap)), void 0 !== e.emissiveMap && (i.emissiveMap = n(e.emissiveMap)), void 0 !== e.emissiveIntensity && (i.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (i.specularMap = n(e.specularMap)), void 0 !== e.specularIntensityMap && (i.specularIntensityMap = n(e.specularIntensityMap)), void 0 !== e.specularColorMap && (i.specularColorMap = n(e.specularColorMap)), void 0 !== e.envMap && (i.envMap = n(e.envMap)), void 0 !== e.envMapIntensity && (i.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (i.reflectivity = e.reflectivity), void 0 !== e.refractionRatio && (i.refractionRatio = e.refractionRatio), void 0 !== e.lightMap && (i.lightMap = n(e.lightMap)), void 0 !== e.lightMapIntensity && (i.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (i.aoMap = n(e.aoMap)), void 0 !== e.aoMapIntensity && (i.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (i.gradientMap = n(e.gradientMap)), void 0 !== e.clearcoatMap && (i.clearcoatMap = n(e.clearcoatMap)), void 0 !== e.clearcoatRoughnessMap && (i.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)), void 0 !== e.clearcoatNormalMap && (i.clearcoatNormalMap = n(e.clearcoatNormalMap)), void 0 !== e.clearcoatNormalScale && (i.clearcoatNormalScale = (new ge).fromArray(e.clearcoatNormalScale)), void 0 !== e.transmissionMap && (i.transmissionMap = n(e.transmissionMap)), void 0 !== e.thicknessMap && (i.thicknessMap = n(e.thicknessMap)), void 0 !== e.sheenColorMap && (i.sheenColorMap = n(e.sheenColorMap)), void 0 !== e.sheenRoughnessMap && (i.sheenRoughnessMap = n(e.sheenRoughnessMap)), i
                }
                setTextures(e) {
                    return this.textures = e, this
                }
            }
            class Lc {
                static decodeText(e) {
                    if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e);
                    let t = "";
                    for (let n = 0, i = e.length; n < i; n++) t += String.fromCharCode(e[n]);
                    try {
                        return decodeURIComponent(escape(t))
                    } catch (e) {
                        return t
                    }
                }
                static extractUrlBase(e) {
                    const t = e.lastIndexOf("/");
                    return -1 === t ? "./" : e.substr(0, t + 1)
                }
                static resolveURL(e, t) {
                    return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
                }
            }
            class Rc extends Mn {
                constructor() {
                    super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
                }
                copy(e) {
                    return super.copy(e), this.instanceCount = e.instanceCount, this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                toJSON() {
                    const e = super.toJSON(this);
                    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = true, e
                }
            }
            Rc.prototype.isInstancedBufferGeometry = true;
            class Pc extends tc {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, i) {
                    const r = this,
                        a = new ic(r.manager);
                    a.setPath(r.path), a.setRequestHeader(r.requestHeader), a.setWithCredentials(r.withCredentials), a.load(e, (function (n) {
                        try {
                            t(r.parse(JSON.parse(n)))
                        } catch (t) {
                            i ? i(t) : console.error(t), r.manager.itemError(e)
                        }
                    }), n, i)
                }
                parse(e) {
                    const t = {},
                        n = {};
                    function i(e, i) {
                        if (void 0 !== t[i]) return t[i];
                        const r = e.interleavedBuffers[i],
                            a = function (e, t) {
                                if (void 0 !== n[t]) return n[t];
                                const i = e.arrayBuffers[t],
                                    r = new Uint32Array(i).buffer;
                                return n[t] = r, r
                            }(e, r.buffer),
                            s = be(r.type, a),
                            o = new $a(s, r.stride);
                        return o.uuid = r.uuid, t[i] = o, o
                    }
                    const r = e.isInstancedBufferGeometry ? new Rc : new Mn,
                        a = e.data.index;
                    if (void 0 !== a) {
                        const e = be(a.type, a.array);
                        r.setIndex(new sn(e, 1))
                    }
                    const s = e.data.attributes;
                    for (const t in s) {
                        const n = s[t];
                        let a;
                        if (n.isInterleavedBufferAttribute) {
                            const t = i(e.data, n.data);
                            a = new ts(t, n.itemSize, n.offset, n.normalized)
                        } else {
                            const e = be(n.type, n.array);
                            a = new(n.isInstancedBufferAttribute ? Is : sn)(e, n.itemSize, n.normalized)
                        }
                        void 0 !== n.name && (a.name = n.name), void 0 !== n.usage && a.setUsage(n.usage), void 0 !== n.updateRange && (a.updateRange.offset = n.updateRange.offset, a.updateRange.count = n.updateRange.count), r.setAttribute(t, a)
                    }
                    const o = e.data.morphAttributes;
                    if (o)
                        for (const t in o) {
                            const n = o[t],
                                a = [];
                            for (let t = 0, r = n.length; t < r; t++) {
                                const r = n[t];
                                let s;
                                if (r.isInterleavedBufferAttribute) {
                                    const t = i(e.data, r.data);
                                    s = new ts(t, r.itemSize, r.offset, r.normalized)
                                } else {
                                    const e = be(r.type, r.array);
                                    s = new sn(e, r.itemSize, r.normalized)
                                }
                                void 0 !== r.name && (s.name = r.name), a.push(s)
                            }
                            r.morphAttributes[t] = a
                        }
                    e.data.morphTargetsRelative && (r.morphTargetsRelative = true);
                    const l = e.data.groups || e.data.drawcalls || e.data.offsets;
                    if (void 0 !== l)
                        for (let e = 0, t = l.length; e !== t; ++e) {
                            const t = l[e];
                            r.addGroup(t.start, t.count, t.materialIndex)
                        }
                    const c = e.data.boundingSphere;
                    if (void 0 !== c) {
                        const e = new Fe;
                        void 0 !== c.center && e.fromArray(c.center), r.boundingSphere = new tt(e, c.radius)
                    }
                    return e.name && (r.name = e.name), e.userData && (r.userData = e.userData), r
                }
            }
            const Cc = {
                    UVMapping: i,
                    CubeReflectionMapping: r,
                    CubeRefractionMapping: a,
                    EquirectangularReflectionMapping: s,
                    EquirectangularRefractionMapping: o,
                    CubeUVReflectionMapping: l,
                    CubeUVRefractionMapping: c
                },
                Ic = {
                    RepeatWrapping: u,
                    ClampToEdgeWrapping: h,
                    MirroredRepeatWrapping: d
                },
                Fc = {
                    NearestFilter: p,
                    NearestMipmapNearestFilter: f,
                    NearestMipmapLinearFilter: m,
                    LinearFilter: g,
                    LinearMipmapNearestFilter: v,
                    LinearMipmapLinearFilter: y
                };
            class Dc extends tc {
                constructor(e) {
                    super(e), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
                        premultiplyAlpha: "none"
                    }
                }
                setOptions(e) {
                    return this.options = e, this
                }
                load(e, t, n, i) {
                    void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    const r = this,
                        a = Kl.get(e);
                    if (void 0 !== a) return r.manager.itemStart(e), setTimeout((function () {
                        t && t(a), r.manager.itemEnd(e)
                    }), 0), a;
                    const s = {};
                    s.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", s.headers = this.requestHeader, fetch(e, s).then((function (e) {
                        return e.blob()
                    })).then((function (e) {
                        return createImageBitmap(e, Object.assign(r.options, {
                            colorSpaceConversion: "none"
                        }))
                    })).then((function (n) {
                        Kl.add(e, n), t && t(n), r.manager.itemEnd(e)
                    })).catch((function (t) {
                        i && i(t), r.manager.itemError(e), r.manager.itemEnd(e)
                    })), r.manager.itemStart(e)
                }
            }
            let Nc;
            Dc.prototype.isImageBitmapLoader = true;
            const Oc = {
                getContext: function () {
                    return void 0 === Nc && (Nc = new(window.AudioContext || window.webkitAudioContext)), Nc
                },
                setContext: function (e) {
                    Nc = e
                }
            };
            class Hc extends tc {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, i) {
                    const r = this,
                        a = new ic(this.manager);
                    a.setResponseType("arraybuffer"), a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, (function (n) {
                        try {
                            const e = n.slice(0);
                            Oc.getContext().decodeAudioData(e, (function (e) {
                                t(e)
                            }))
                        } catch (t) {
                            i ? i(t) : console.error(t), r.manager.itemError(e)
                        }
                    }), n, i)
                }
            }
            class Uc extends Sc {
                constructor(e, t, n = 1) {
                    super(void 0, n);
                    const i = (new tn).set(e),
                        r = (new tn).set(t),
                        a = new Fe(i.r, i.g, i.b),
                        s = new Fe(r.r, r.g, r.b),
                        o = Math.sqrt(Math.PI),
                        l = o * Math.sqrt(.75);
                    this.sh.coefficients[0].copy(a).add(s).multiplyScalar(o), this.sh.coefficients[1].copy(a).sub(s).multiplyScalar(l)
                }
            }
            Uc.prototype.isHemisphereLightProbe = true;
            class Bc extends Sc {
                constructor(e, t = 1) {
                    super(void 0, t);
                    const n = (new tn).set(e);
                    this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
                }
            }
            Bc.prototype.isAmbientLightProbe = true;
            const zc = new ut,
                kc = new ut,
                Gc = new ut;
            class Vc {
                constructor(e = true) {
                    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = false
                }
                start() {
                    this.startTime = jc(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = true
                }
                stop() {
                    this.getElapsedTime(), this.running = false, this.autoStart = false
                }
                getElapsedTime() {
                    return this.getDelta(), this.elapsedTime
                }
                getDelta() {
                    let e = 0;
                    if (this.autoStart && !this.running) return this.start(), 0;
                    if (this.running) {
                        const t = jc();
                        e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
                    }
                    return e
                }
            }
            function jc() {
                return ("undefined" == typeof performance ? Date : performance).now()
            }
            const Wc = new Fe,
                Xc = new Ie,
                Yc = new Fe,
                qc = new Fe;
            class Qc extends Nt {
                constructor(e) {
                    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = false, this.buffer = null, this.detune = 0, this.loop = false, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = false, this.hasPlaybackControl = true, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = false, this.filters = []
                }
                getOutput() {
                    return this.gain
                }
                setNodeSource(e) {
                    return this.hasPlaybackControl = false, this.sourceType = "audioNode", this.source = e, this.connect(), this
                }
                setMediaElementSource(e) {
                    return this.hasPlaybackControl = false, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
                }
                setMediaStreamSource(e) {
                    return this.hasPlaybackControl = false, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this
                }
                setBuffer(e) {
                    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
                }
                play(e = 0) {
                    if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
                    if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
                    this._startedAt = this.context.currentTime + e;
                    const t = this.context.createBufferSource();
                    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = true, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                }
                pause() {
                    if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = false), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                stop() {
                    if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = false, this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                connect() {
                    if (this.filters.length > 0) {
                        this.source.connect(this.filters[0]);
                        for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
                        this.filters[this.filters.length - 1].connect(this.getOutput())
                    } else this.source.connect(this.getOutput());
                    return this._connected = true, this
                }
                disconnect() {
                    if (this.filters.length > 0) {
                        this.source.disconnect(this.filters[0]);
                        for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput())
                    } else this.source.disconnect(this.getOutput());
                    return this._connected = false, this
                }
                getFilters() {
                    return this.filters
                }
                setFilters(e) {
                    return e || (e = []), !0 === this._connected ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this
                }
                setDetune(e) {
                    if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
                }
                getDetune() {
                    return this.detune
                }
                getFilter() {
                    return this.getFilters()[0]
                }
                setFilter(e) {
                    return this.setFilters(e ? [e] : [])
                }
                setPlaybackRate(e) {
                    if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                getPlaybackRate() {
                    return this.playbackRate
                }
                onEnded() {
                    this.isPlaying = false
                }
                getLoop() {
                    return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), false) : this.loop
                }
                setLoop(e) {
                    if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                setLoopStart(e) {
                    return this.loopStart = e, this
                }
                setLoopEnd(e) {
                    return this.loopEnd = e, this
                }
                getVolume() {
                    return this.gain.gain.value
                }
                setVolume(e) {
                    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
                }
            }
            const Jc = new Fe,
                Zc = new Ie,
                Kc = new Fe,
                $c = new Fe;
            class eu {
                constructor(e, t = 2048) {
                    this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
                }
                getFrequencyData() {
                    return this.analyser.getByteFrequencyData(this.data), this.data
                }
                getAverageFrequency() {
                    let e = 0;
                    const t = this.getFrequencyData();
                    for (let n = 0; n < t.length; n++) e += t[n];
                    return e / t.length
                }
            }
            class tu {
                constructor(e, t, n) {
                    let i, r, a;
                    switch (this.binding = e, this.valueSize = n, t) {
                    case "quaternion":
                        i = this._slerp, r = this._slerpAdditive, a = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
                        break;
                    case "string":
                    case "bool":
                        i = this._select, r = this._select, a = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
                        break;
                    default:
                        i = this._lerp, r = this._lerpAdditive, a = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n)
                    }
                    this._mixBufferRegion = i, this._mixBufferRegionAdditive = r, this._setIdentity = a, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
                }
                accumulate(e, t) {
                    const n = this.buffer,
                        i = this.valueSize,
                        r = e * i + i;
                    let a = this.cumulativeWeight;
                    if (0 === a) {
                        for (let e = 0; e !== i; ++e) n[r + e] = n[e];
                        a = t
                    } else {
                        a += t;
                        const e = t / a;
                        this._mixBufferRegion(n, r, 0, e, i)
                    }
                    this.cumulativeWeight = a
                }
                accumulateAdditive(e) {
                    const t = this.buffer,
                        n = this.valueSize,
                        i = n * this._addIndex;
                    0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t, i, 0, e, n), this.cumulativeWeightAdditive += e
                }
                apply(e) {
                    const t = this.valueSize,
                        n = this.buffer,
                        i = e * t + t,
                        r = this.cumulativeWeight,
                        a = this.cumulativeWeightAdditive,
                        s = this.binding;
                    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
                        const e = t * this._origIndex;
                        this._mixBufferRegion(n, i, e, 1 - r, t)
                    }
                    a > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
                    for (let e = t, r = t + t; e !== r; ++e)
                        if (n[e] !== n[e + t]) {
                            s.setValue(n, i);
                            break
                        }
                }
                saveOriginalState() {
                    const e = this.binding,
                        t = this.buffer,
                        n = this.valueSize,
                        i = n * this._origIndex;
                    e.getValue(t, i);
                    for (let e = n, r = i; e !== r; ++e) t[e] = t[i + e % n];
                    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
                }
                restoreOriginalState() {
                    const e = 3 * this.valueSize;
                    this.binding.setValue(this.buffer, e)
                }
                _setAdditiveIdentityNumeric() {
                    const e = this._addIndex * this.valueSize,
                        t = e + this.valueSize;
                    for (let n = e; n < t; n++) this.buffer[n] = 0
                }
                _setAdditiveIdentityQuaternion() {
                    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
                }
                _setAdditiveIdentityOther() {
                    const e = this._origIndex * this.valueSize,
                        t = this._addIndex * this.valueSize;
                    for (let n = 0; n < this.valueSize; n++) this.buffer[t + n] = this.buffer[e + n]
                }
                _select(e, t, n, i, r) {
                    if (i >= .5)
                        for (let i = 0; i !== r; ++i) e[t + i] = e[n + i]
                }
                _slerp(e, t, n, i) {
                    Ie.slerpFlat(e, t, e, t, e, n, i)
                }
                _slerpAdditive(e, t, n, i, r) {
                    const a = this._workIndex * r;
                    Ie.multiplyQuaternionsFlat(e, a, e, t, e, n), Ie.slerpFlat(e, t, e, t, e, a, i)
                }
                _lerp(e, t, n, i, r) {
                    const a = 1 - i;
                    for (let s = 0; s !== r; ++s) {
                        const r = t + s;
                        e[r] = e[r] * a + e[n + s] * i
                    }
                }
                _lerpAdditive(e, t, n, i, r) {
                    for (let a = 0; a !== r; ++a) {
                        const r = t + a;
                        e[r] = e[r] + e[n + a] * i
                    }
                }
            }
            const nu = new RegExp("[\\[\\]\\.:\\/]", "g"),
                iu = "[^\\[\\]\\.:\\/]",
                ru = "[^\\[\\]\\.:\\/".replace("\\.", "") + "]",
                au = /((?:WC+[\/:])*)/.source.replace("WC", iu),
                su = /(WCOD+)?/.source.replace("WCOD", ru),
                ou = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", iu),
                lu = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", iu),
                cu = new RegExp("^" + au + su + ou + lu + "$"),
                uu = ["material", "materials", "bones"];
            class hu {
                constructor(e, t, n) {
                    this.path = t, this.parsedPath = n || hu.parseTrackName(t), this.node = hu.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
                static create(e, t, n) {
                    return e && e.isAnimationObjectGroup ? new hu.Composite(e, t, n) : new hu(e, t, n)
                }
                static sanitizeNodeName(e) {
                    return e.replace(/\s/g, "_").replace(nu, "")
                }
                static parseTrackName(e) {
                    const t = cu.exec(e);
                    if (!t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                    const n = {
                            nodeName: t[2],
                            objectName: t[3],
                            objectIndex: t[4],
                            propertyName: t[5],
                            propertyIndex: t[6]
                        },
                        i = n.nodeName && n.nodeName.lastIndexOf(".");
                    if (void 0 !== i && -1 !== i) {
                        const e = n.nodeName.substring(i + 1); - 1 !== uu.indexOf(e) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = e)
                    }
                    if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                    return n
                }
                static findNode(e, t) {
                    if (!t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
                    if (e.skeleton) {
                        const n = e.skeleton.getBoneByName(t);
                        if (void 0 !== n) return n
                    }
                    if (e.children) {
                        const n = function (e) {
                                for (let i = 0; i < e.length; i++) {
                                    const r = e[i];
                                    if (r.name === t || r.uuid === t) return r;
                                    const a = n(r.children);
                                    if (a) return a
                                }
                                return null
                            },
                            i = n(e.children);
                        if (i) return i
                    }
                    return null
                }
                _getValue_unavailable() {}
                _setValue_unavailable() {}
                _getValue_direct(e, t) {
                    e[t] = this.targetObject[this.propertyName]
                }
                _getValue_array(e, t) {
                    const n = this.resolvedProperty;
                    for (let i = 0, r = n.length; i !== r; ++i) e[t++] = n[i]
                }
                _getValue_arrayElement(e, t) {
                    e[t] = this.resolvedProperty[this.propertyIndex]
                }
                _getValue_toArray(e, t) {
                    this.resolvedProperty.toArray(e, t)
                }
                _setValue_direct(e, t) {
                    this.targetObject[this.propertyName] = e[t]
                }
                _setValue_direct_setNeedsUpdate(e, t) {
                    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = true
                }
                _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
                    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = true
                }
                _setValue_array(e, t) {
                    const n = this.resolvedProperty;
                    for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++]
                }
                _setValue_array_setNeedsUpdate(e, t) {
                    const n = this.resolvedProperty;
                    for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
                    this.targetObject.needsUpdate = true
                }
                _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
                    const n = this.resolvedProperty;
                    for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
                    this.targetObject.matrixWorldNeedsUpdate = true
                }
                _setValue_arrayElement(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t]
                }
                _setValue_arrayElement_setNeedsUpdate(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = true
                }
                _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = true
                }
                _setValue_fromArray(e, t) {
                    this.resolvedProperty.fromArray(e, t)
                }
                _setValue_fromArray_setNeedsUpdate(e, t) {
                    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = true
                }
                _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
                    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = true
                }
                _getValue_unbound(e, t) {
                    this.bind(), this.getValue(e, t)
                }
                _setValue_unbound(e, t) {
                    this.bind(), this.setValue(e, t)
                }
                bind() {
                    let e = this.node;
                    const t = this.parsedPath,
                        n = t.objectName,
                        i = t.propertyName;
                    let r = t.propertyIndex;
                    if (e || (e = hu.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                    if (n) {
                        let i = t.objectIndex;
                        switch (n) {
                        case "materials":
                            if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            e = e.material.materials;
                            break;
                        case "bones":
                            if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            e = e.skeleton.bones;
                            for (let t = 0; t < e.length; t++)
                                if (e[t].name === i) {
                                    i = t;
                                    break
                                } break;
                        default:
                            if (void 0 === e[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            e = e[n]
                        }
                        if (void 0 !== i) {
                            if (void 0 === e[i]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                            e = e[i]
                        }
                    }
                    const a = e[i];
                    if (void 0 === a) {
                        const n = t.nodeName;
                        return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", e)
                    }
                    let s = this.Versioning.None;
                    this.targetObject = e, void 0 !== e.needsUpdate ? s = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (s = this.Versioning.MatrixWorldNeedsUpdate);
                    let o = this.BindingType.Direct;
                    if (void 0 !== r) {
                        if ("morphTargetInfluences" === i) {
                            if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            if (!e.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                            if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                            void 0 !== e.morphTargetDictionary[r] && (r = e.morphTargetDictionary[r])
                        }
                        o = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = r
                    } else void 0 !== a.fromArray && void 0 !== a.toArray ? (o = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (o = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = i;
                    this.getValue = this.GetterByBindingType[o], this.setValue = this.SetterByBindingTypeAndVersioning[o][s]
                }
                unbind() {
                    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
            }
            hu.Composite = class {
                constructor(e, t, n) {
                    const i = n || hu.parseTrackName(t);
                    this._targetGroup = e, this._bindings = e.subscribe_(t, i)
                }
                getValue(e, t) {
                    this.bind();
                    const n = this._targetGroup.nCachedObjects_,
                        i = this._bindings[n];
                    void 0 !== i && i.getValue(e, t)
                }
                setValue(e, t) {
                    const n = this._bindings;
                    for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(e, t)
                }
                bind() {
                    const e = this._bindings;
                    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
                }
                unbind() {
                    const e = this._bindings;
                    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
                }
            }, hu.prototype.BindingType = {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            }, hu.prototype.Versioning = {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            }, hu.prototype.GetterByBindingType = [hu.prototype._getValue_direct, hu.prototype._getValue_array, hu.prototype._getValue_arrayElement, hu.prototype._getValue_toArray], hu.prototype.SetterByBindingTypeAndVersioning = [
                [hu.prototype._setValue_direct, hu.prototype._setValue_direct_setNeedsUpdate, hu.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
                [hu.prototype._setValue_array, hu.prototype._setValue_array_setNeedsUpdate, hu.prototype._setValue_array_setMatrixWorldNeedsUpdate],
                [hu.prototype._setValue_arrayElement, hu.prototype._setValue_arrayElement_setNeedsUpdate, hu.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
                [hu.prototype._setValue_fromArray, hu.prototype._setValue_fromArray_setNeedsUpdate, hu.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
            ];
            class du {
                constructor() {
                    this.uuid = le(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                    const e = {};
                    this._indicesByUUID = e;
                    for (let t = 0, n = arguments.length; t !== n; ++t) e[arguments[t].uuid] = t;
                    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                    const t = this;
                    this.stats = {
                        objects: {
                            get total() {
                                return t._objects.length
                            },
                            get inUse() {
                                return this.total - t.nCachedObjects_
                            }
                        },
                        get bindingsPerObject() {
                            return t._bindings.length
                        }
                    }
                }
                add() {
                    const e = this._objects,
                        t = this._indicesByUUID,
                        n = this._paths,
                        i = this._parsedPaths,
                        r = this._bindings,
                        a = r.length;
                    let s, o = e.length,
                        l = this.nCachedObjects_;
                    for (let c = 0, u = arguments.length; c !== u; ++c) {
                        const u = arguments[c],
                            h = u.uuid;
                        let d = t[h];
                        if (void 0 === d) {
                            d = o++, t[h] = d, e.push(u);
                            for (let e = 0, t = a; e !== t; ++e) r[e].push(new hu(u, n[e], i[e]))
                        } else if (d < l) {
                            s = e[d];
                            const o = --l,
                                c = e[o];
                            t[c.uuid] = d, e[d] = c, t[h] = o, e[o] = u;
                            for (let e = 0, t = a; e !== t; ++e) {
                                const t = r[e],
                                    a = t[o];
                                let s = t[d];
                                t[d] = a, void 0 === s && (s = new hu(u, n[e], i[e])), t[o] = s
                            }
                        } else e[d] !== s && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                    }
                    this.nCachedObjects_ = l
                }
                remove() {
                    const e = this._objects,
                        t = this._indicesByUUID,
                        n = this._bindings,
                        i = n.length;
                    let r = this.nCachedObjects_;
                    for (let a = 0, s = arguments.length; a !== s; ++a) {
                        const s = arguments[a],
                            o = s.uuid,
                            l = t[o];
                        if (void 0 !== l && l >= r) {
                            const a = r++,
                                c = e[a];
                            t[c.uuid] = l, e[l] = c, t[o] = a, e[a] = s;
                            for (let e = 0, t = i; e !== t; ++e) {
                                const t = n[e],
                                    i = t[a],
                                    r = t[l];
                                t[l] = i, t[a] = r
                            }
                        }
                    }
                    this.nCachedObjects_ = r
                }
                uncache() {
                    const e = this._objects,
                        t = this._indicesByUUID,
                        n = this._bindings,
                        i = n.length;
                    let r = this.nCachedObjects_,
                        a = e.length;
                    for (let s = 0, o = arguments.length; s !== o; ++s) {
                        const o = arguments[s].uuid,
                            l = t[o];
                        if (void 0 !== l)
                            if (delete t[o], l < r) {
                                const s = --r,
                                    o = e[s],
                                    c = --a,
                                    u = e[c];
                                t[o.uuid] = l, e[l] = o, t[u.uuid] = s, e[s] = u, e.pop();
                                for (let e = 0, t = i; e !== t; ++e) {
                                    const t = n[e],
                                        i = t[s],
                                        r = t[c];
                                    t[l] = i, t[s] = r, t.pop()
                                }
                            } else {
                                const r = --a,
                                    s = e[r];
                                r > 0 && (t[s.uuid] = l), e[l] = s, e.pop();
                                for (let e = 0, t = i; e !== t; ++e) {
                                    const t = n[e];
                                    t[l] = t[r], t.pop()
                                }
                            }
                    }
                    this.nCachedObjects_ = r
                }
                subscribe_(e, t) {
                    const n = this._bindingsIndicesByPath;
                    let i = n[e];
                    const r = this._bindings;
                    if (void 0 !== i) return r[i];
                    const a = this._paths,
                        s = this._parsedPaths,
                        o = this._objects,
                        l = o.length,
                        c = this.nCachedObjects_,
                        u = new Array(l);
                    i = r.length, n[e] = i, a.push(e), s.push(t), r.push(u);
                    for (let n = c, i = o.length; n !== i; ++n) {
                        const i = o[n];
                        u[n] = new hu(i, e, t)
                    }
                    return u
                }
                unsubscribe_(e) {
                    const t = this._bindingsIndicesByPath,
                        n = t[e];
                    if (void 0 !== n) {
                        const i = this._paths,
                            r = this._parsedPaths,
                            a = this._bindings,
                            s = a.length - 1,
                            o = a[s];
                        t[e[s]] = n, a[n] = o, a.pop(), r[n] = r[s], r.pop(), i[n] = i[s], i.pop()
                    }
                }
            }
            du.prototype.isAnimationObjectGroup = true;
            class pu {
                constructor(e, t, n = null, i = t.blendMode) {
                    this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = i;
                    const r = t.tracks,
                        a = r.length,
                        s = new Array(a),
                        o = {
                            endingStart: G,
                            endingEnd: G
                        };
                    for (let e = 0; e !== a; ++e) {
                        const t = r[e].createInterpolant(null);
                        s[e] = t, t.settings = o
                    }
                    this._interpolantSettings = o, this._interpolants = s, this._propertyBindings = new Array(a), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = false, this.enabled = true, this.clampWhenFinished = false, this.zeroSlopeAtStart = true, this.zeroSlopeAtEnd = true
                }
                play() {
                    return this._mixer._activateAction(this), this
                }
                stop() {
                    return this._mixer._deactivateAction(this), this.reset()
                }
                reset() {
                    return this.paused = false, this.enabled = true, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                }
                isRunning() {
                    return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                }
                isScheduled() {
                    return this._mixer._isActiveAction(this)
                }
                startAt(e) {
                    return this._startTime = e, this
                }
                setLoop(e, t) {
                    return this.loop = e, this.repetitions = t, this
                }
                setEffectiveWeight(e) {
                    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
                }
                getEffectiveWeight() {
                    return this._effectiveWeight
                }
                fadeIn(e) {
                    return this._scheduleFading(e, 0, 1)
                }
                fadeOut(e) {
                    return this._scheduleFading(e, 1, 0)
                }
                crossFadeFrom(e, t, n) {
                    if (e.fadeOut(t), this.fadeIn(t), n) {
                        const n = this._clip.duration,
                            i = e._clip.duration,
                            r = i / n,
                            a = n / i;
                        e.warp(1, r, t), this.warp(a, 1, t)
                    }
                    return this
                }
                crossFadeTo(e, t, n) {
                    return e.crossFadeFrom(this, t, n)
                }
                stopFading() {
                    const e = this._weightInterpolant;
                    return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
                }
                setEffectiveTimeScale(e) {
                    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
                }
                getEffectiveTimeScale() {
                    return this._effectiveTimeScale
                }
                setDuration(e) {
                    return this.timeScale = this._clip.duration / e, this.stopWarping()
                }
                syncWith(e) {
                    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
                }
                halt(e) {
                    return this.warp(this._effectiveTimeScale, 0, e)
                }
                warp(e, t, n) {
                    const i = this._mixer,
                        r = i.time,
                        a = this.timeScale;
                    let s = this._timeScaleInterpolant;
                    null === s && (s = i._lendControlInterpolant(), this._timeScaleInterpolant = s);
                    const o = s.parameterPositions,
                        l = s.sampleValues;
                    return o[0] = r, o[1] = r + n, l[0] = e / a, l[1] = t / a, this
                }
                stopWarping() {
                    const e = this._timeScaleInterpolant;
                    return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
                }
                getMixer() {
                    return this._mixer
                }
                getClip() {
                    return this._clip
                }
                getRoot() {
                    return this._localRoot || this._mixer._root
                }
                _update(e, t, n, i) {
                    if (!this.enabled) return void this._updateWeight(e);
                    const r = this._startTime;
                    if (null !== r) {
                        const i = (e - r) * n;
                        if (i < 0 || 0 === n) return;
                        this._startTime = null, t = n * i
                    }
                    t *= this._updateTimeScale(e);
                    const a = this._updateTime(t),
                        s = this._updateWeight(e);
                    if (s > 0) {
                        const e = this._interpolants,
                            t = this._propertyBindings;
                        if (this.blendMode === W)
                            for (let n = 0, i = e.length; n !== i; ++n) e[n].evaluate(a), t[n].accumulateAdditive(s);
                        else
                            for (let n = 0, r = e.length; n !== r; ++n) e[n].evaluate(a), t[n].accumulate(i, s)
                    }
                }
                _updateWeight(e) {
                    let t = 0;
                    if (this.enabled) {
                        t = this.weight;
                        const n = this._weightInterpolant;
                        if (null !== n) {
                            const i = n.evaluate(e)[0];
                            t *= i, e > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = false))
                        }
                    }
                    return this._effectiveWeight = t, t
                }
                _updateTimeScale(e) {
                    let t = 0;
                    if (!this.paused) {
                        t = this.timeScale;
                        const n = this._timeScaleInterpolant;
                        null !== n && (t *= n.evaluate(e)[0], e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t))
                    }
                    return this._effectiveTimeScale = t, t
                }
                _updateTime(e) {
                    const t = this._clip.duration,
                        n = this.loop;
                    let i = this.time + e,
                        r = this._loopCount;
                    const a = 2202 === n;
                    if (0 === e) return -1 === r ? i : a && 1 == (1 & r) ? t - i : i;
                    if (2200 === n) {
                        -1 === r && (this._loopCount = 0, this._setEndings(true, true, false));
                        e: {
                            if (i >= t) i = t;
                            else {
                                if (!(i < 0)) {
                                    this.time = i;
                                    break e
                                }
                                i = 0
                            }
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = false,
                            this.time = i,
                            this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: e < 0 ? -1 : 1
                            })
                        }
                    } else {
                        if (-1 === r && (e >= 0 ? (r = 0, this._setEndings(true, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, true, a)), i >= t || i < 0) {
                            const n = Math.floor(i / t);
                            i -= t * n, r += Math.abs(n);
                            const s = this.repetitions - r;
                            if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = false, i = e > 0 ? t : 0, this.time = i, this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: e > 0 ? 1 : -1
                            });
                            else {
                                if (1 === s) {
                                    const t = e < 0;
                                    this._setEndings(t, !t, a)
                                } else this._setEndings(false, false, a);
                                this._loopCount = r, this.time = i, this._mixer.dispatchEvent({
                                    type: "loop",
                                    action: this,
                                    loopDelta: n
                                })
                            }
                        } else this.time = i;
                        if (a && 1 == (1 & r)) return t - i
                    }
                    return i
                }
                _setEndings(e, t, n) {
                    const i = this._interpolantSettings;
                    n ? (i.endingStart = V, i.endingEnd = V) : (i.endingStart = e ? this.zeroSlopeAtStart ? V : G : j, i.endingEnd = t ? this.zeroSlopeAtEnd ? V : G : j)
                }
                _scheduleFading(e, t, n) {
                    const i = this._mixer,
                        r = i.time;
                    let a = this._weightInterpolant;
                    null === a && (a = i._lendControlInterpolant(), this._weightInterpolant = a);
                    const s = a.parameterPositions,
                        o = a.sampleValues;
                    return s[0] = r, o[0] = t, s[1] = r + e, o[1] = n, this
                }
            }
            class fu extends ie {
                constructor(e) {
                    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
                }
                _bindAction(e, t) {
                    const n = e._localRoot || this._root,
                        i = e._clip.tracks,
                        r = i.length,
                        a = e._propertyBindings,
                        s = e._interpolants,
                        o = n.uuid,
                        l = this._bindingsByRootAndName;
                    let c = l[o];
                    void 0 === c && (c = {}, l[o] = c);
                    for (let e = 0; e !== r; ++e) {
                        const r = i[e],
                            l = r.name;
                        let u = c[l];
                        if (void 0 !== u) a[e] = u;
                        else {
                            if (u = a[e], void 0 !== u) {
                                null === u._cacheIndex && (++u.referenceCount, this._addInactiveBinding(u, o, l));
                                continue
                            }
                            const i = t && t._propertyBindings[e].binding.parsedPath;
                            u = new tu(hu.create(n, l, i), r.ValueTypeName, r.getValueSize()), ++u.referenceCount, this._addInactiveBinding(u, o, l), a[e] = u
                        }
                        s[e].resultBuffer = u.buffer
                    }
                }
                _activateAction(e) {
                    if (!this._isActiveAction(e)) {
                        if (null === e._cacheIndex) {
                            const t = (e._localRoot || this._root).uuid,
                                n = e._clip.uuid,
                                i = this._actionsByClip[n];
                            this._bindAction(e, i && i.knownActions[0]), this._addInactiveAction(e, n, t)
                        }
                        const t = e._propertyBindings;
                        for (let e = 0, n = t.length; e !== n; ++e) {
                            const n = t[e];
                            0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState())
                        }
                        this._lendAction(e)
                    }
                }
                _deactivateAction(e) {
                    if (this._isActiveAction(e)) {
                        const t = e._propertyBindings;
                        for (let e = 0, n = t.length; e !== n; ++e) {
                            const n = t[e];
                            0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n))
                        }
                        this._takeBackAction(e)
                    }
                }
                _initMemoryManager() {
                    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                    const e = this;
                    this.stats = {
                        actions: {
                            get total() {
                                return e._actions.length
                            },
                            get inUse() {
                                return e._nActiveActions
                            }
                        },
                        bindings: {
                            get total() {
                                return e._bindings.length
                            },
                            get inUse() {
                                return e._nActiveBindings
                            }
                        },
                        controlInterpolants: {
                            get total() {
                                return e._controlInterpolants.length
                            },
                            get inUse() {
                                return e._nActiveControlInterpolants
                            }
                        }
                    }
                }
                _isActiveAction(e) {
                    const t = e._cacheIndex;
                    return null !== t && t < this._nActiveActions
                }
                _addInactiveAction(e, t, n) {
                    const i = this._actions,
                        r = this._actionsByClip;
                    let a = r[t];
                    if (void 0 === a) a = {
                        knownActions: [e],
                        actionByRoot: {}
                    }, e._byClipCacheIndex = 0, r[t] = a;
                    else {
                        const t = a.knownActions;
                        e._byClipCacheIndex = t.length, t.push(e)
                    }
                    e._cacheIndex = i.length, i.push(e), a.actionByRoot[n] = e
                }
                _removeInactiveAction(e) {
                    const t = this._actions,
                        n = t[t.length - 1],
                        i = e._cacheIndex;
                    n._cacheIndex = i, t[i] = n, t.pop(), e._cacheIndex = null;
                    const r = e._clip.uuid,
                        a = this._actionsByClip,
                        s = a[r],
                        o = s.knownActions,
                        l = o[o.length - 1],
                        c = e._byClipCacheIndex;
                    l._byClipCacheIndex = c, o[c] = l, o.pop(), e._byClipCacheIndex = null, delete s.actionByRoot[(e._localRoot || this._root).uuid], 0 === o.length && delete a[r], this._removeInactiveBindingsForAction(e)
                }
                _removeInactiveBindingsForAction(e) {
                    const t = e._propertyBindings;
                    for (let e = 0, n = t.length; e !== n; ++e) {
                        const n = t[e];
                        0 == --n.referenceCount && this._removeInactiveBinding(n)
                    }
                }
                _lendAction(e) {
                    const t = this._actions,
                        n = e._cacheIndex,
                        i = this._nActiveActions++,
                        r = t[i];
                    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
                }
                _takeBackAction(e) {
                    const t = this._actions,
                        n = e._cacheIndex,
                        i = --this._nActiveActions,
                        r = t[i];
                    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
                }
                _addInactiveBinding(e, t, n) {
                    const i = this._bindingsByRootAndName,
                        r = this._bindings;
                    let a = i[t];
                    void 0 === a && (a = {}, i[t] = a), a[n] = e, e._cacheIndex = r.length, r.push(e)
                }
                _removeInactiveBinding(e) {
                    const t = this._bindings,
                        n = e.binding,
                        i = n.rootNode.uuid,
                        r = n.path,
                        a = this._bindingsByRootAndName,
                        s = a[i],
                        o = t[t.length - 1],
                        l = e._cacheIndex;
                    o._cacheIndex = l, t[l] = o, t.pop(), delete s[r], 0 === Object.keys(s).length && delete a[i]
                }
                _lendBinding(e) {
                    const t = this._bindings,
                        n = e._cacheIndex,
                        i = this._nActiveBindings++,
                        r = t[i];
                    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
                }
                _takeBackBinding(e) {
                    const t = this._bindings,
                        n = e._cacheIndex,
                        i = --this._nActiveBindings,
                        r = t[i];
                    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
                }
                _lendControlInterpolant() {
                    const e = this._controlInterpolants,
                        t = this._nActiveControlInterpolants++;
                    let n = e[t];
                    return void 0 === n && (n = new zl(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = t, e[t] = n), n
                }
                _takeBackControlInterpolant(e) {
                    const t = this._controlInterpolants,
                        n = e.__cacheIndex,
                        i = --this._nActiveControlInterpolants,
                        r = t[i];
                    e.__cacheIndex = i, t[i] = e, r.__cacheIndex = n, t[n] = r
                }
                clipAction(e, t, n) {
                    const i = t || this._root,
                        r = i.uuid;
                    let a = "string" == typeof e ? Jl.findByName(i, e) : e;
                    const s = null !== a ? a.uuid : e,
                        o = this._actionsByClip[s];
                    let l = null;
                    if (void 0 === n && (n = null !== a ? a.blendMode : 2500), void 0 !== o) {
                        const e = o.actionByRoot[r];
                        if (void 0 !== e && e.blendMode === n) return e;
                        l = o.knownActions[0], null === a && (a = l._clip)
                    }
                    if (null === a) return null;
                    const c = new pu(this, a, t, n);
                    return this._bindAction(c, l), this._addInactiveAction(c, s, r), c
                }
                existingAction(e, t) {
                    const n = t || this._root,
                        i = n.uuid,
                        r = "string" == typeof e ? Jl.findByName(n, e) : e,
                        a = r ? r.uuid : e,
                        s = this._actionsByClip[a];
                    return void 0 !== s && s.actionByRoot[i] || null
                }
                stopAllAction() {
                    const e = this._actions;
                    for (let t = this._nActiveActions - 1; t >= 0; --t) e[t].stop();
                    return this
                }
                update(e) {
                    e *= this.timeScale;
                    const t = this._actions,
                        n = this._nActiveActions,
                        i = this.time += e,
                        r = Math.sign(e),
                        a = this._accuIndex ^= 1;
                    for (let s = 0; s !== n; ++s) t[s]._update(i, e, r, a);
                    const s = this._bindings,
                        o = this._nActiveBindings;
                    for (let e = 0; e !== o; ++e) s[e].apply(a);
                    return this
                }
                setTime(e) {
                    this.time = 0;
                    for (let e = 0; e < this._actions.length; e++) this._actions[e].time = 0;
                    return this.update(e)
                }
                getRoot() {
                    return this._root
                }
                uncacheClip(e) {
                    const t = this._actions,
                        n = e.uuid,
                        i = this._actionsByClip,
                        r = i[n];
                    if (void 0 !== r) {
                        const e = r.knownActions;
                        for (let n = 0, i = e.length; n !== i; ++n) {
                            const i = e[n];
                            this._deactivateAction(i);
                            const r = i._cacheIndex,
                                a = t[t.length - 1];
                            i._cacheIndex = null, i._byClipCacheIndex = null, a._cacheIndex = r, t[r] = a, t.pop(), this._removeInactiveBindingsForAction(i)
                        }
                        delete i[n]
                    }
                }
                uncacheRoot(e) {
                    const t = e.uuid,
                        n = this._actionsByClip;
                    for (const e in n) {
                        const i = n[e].actionByRoot[t];
                        void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
                    }
                    const i = this._bindingsByRootAndName[t];
                    if (void 0 !== i)
                        for (const e in i) {
                            const t = i[e];
                            t.restoreOriginalState(), this._removeInactiveBinding(t)
                        }
                }
                uncacheAction(e, t) {
                    const n = this.existingAction(e, t);
                    null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                }
            }
            fu.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
            class mu {
                constructor(e) {
                    "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e
                }
                clone() {
                    return new mu(void 0 === this.value.clone ? this.value : this.value.clone())
                }
            }
            class gu extends $a {
                constructor(e, t, n = 1) {
                    super(e, t), this.meshPerAttribute = n
                }
                copy(e) {
                    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
                }
                clone(e) {
                    const t = super.clone(e);
                    return t.meshPerAttribute = this.meshPerAttribute, t
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return t.isInstancedInterleavedBuffer = true, t.meshPerAttribute = this.meshPerAttribute, t
                }
            }
            gu.prototype.isInstancedInterleavedBuffer = true;
            class vu {
                constructor(e, t, n, i, r) {
                    this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = i, this.count = r, this.version = 0
                }
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
                setBuffer(e) {
                    return this.buffer = e, this
                }
                setType(e, t) {
                    return this.type = e, this.elementSize = t, this
                }
                setItemSize(e) {
                    return this.itemSize = e, this
                }
                setCount(e) {
                    return this.count = e, this
                }
            }
            function yu(e, t) {
                return e.distance - t.distance
            }
            function xu(e, t, n, i) {
                if (e.layers.test(t.layers) && e.raycast(t, n), !0 === i) {
                    const i = e.children;
                    for (let e = 0, r = i.length; e < r; e++) xu(i[e], t, n, true)
                }
            }
            vu.prototype.isGLBufferAttribute = true;
            const bu = new ge;
            class _u {
                constructor(e = new ge(1 / 0, 1 / 0), t = new ge(-1 / 0, -1 / 0)) {
                    this.min = e, this.max = t
                }
                set(e, t) {
                    return this.min.copy(e), this.max.copy(t), this
                }
                setFromPoints(e) {
                    this.makeEmpty();
                    for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                    return this
                }
                setFromCenterAndSize(e, t) {
                    const n = bu.copy(t).multiplyScalar(.5);
                    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.min.copy(e.min), this.max.copy(e.max), this
                }
                makeEmpty() {
                    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
                }
                isEmpty() {
                    return this.max.x < this.min.x || this.max.y < this.min.y
                }
                getCenter(e) {
                    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                }
                getSize(e) {
                    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
                }
                expandByPoint(e) {
                    return this.min.min(e), this.max.max(e), this
                }
                expandByVector(e) {
                    return this.min.sub(e), this.max.add(e), this
                }
                expandByScalar(e) {
                    return this.min.addScalar(-e), this.max.addScalar(e), this
                }
                containsPoint(e) {
                    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
                }
                containsBox(e) {
                    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
                }
                getParameter(e, t) {
                    return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
                }
                intersectsBox(e) {
                    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
                }
                clampPoint(e, t) {
                    return t.copy(e).clamp(this.min, this.max)
                }
                distanceToPoint(e) {
                    return bu.copy(e).clamp(this.min, this.max).sub(e).length()
                }
                intersect(e) {
                    return this.min.max(e.min), this.max.min(e.max), this
                }
                union(e) {
                    return this.min.min(e.min), this.max.max(e.max), this
                }
                translate(e) {
                    return this.min.add(e), this.max.add(e), this
                }
                equals(e) {
                    return e.min.equals(this.min) && e.max.equals(this.max)
                }
            }
            _u.prototype.isBox2 = true;
            const wu = new Fe,
                Eu = new Fe;
            class Mu {
                constructor(e = new Fe, t = new Fe) {
                    this.start = e, this.end = t
                }
                set(e, t) {
                    return this.start.copy(e), this.end.copy(t), this
                }
                copy(e) {
                    return this.start.copy(e.start), this.end.copy(e.end), this
                }
                getCenter(e) {
                    return e.addVectors(this.start, this.end).multiplyScalar(.5)
                }
                delta(e) {
                    return e.subVectors(this.end, this.start)
                }
                distanceSq() {
                    return this.start.distanceToSquared(this.end)
                }
                distance() {
                    return this.start.distanceTo(this.end)
                }
                at(e, t) {
                    return this.delta(t).multiplyScalar(e).add(this.start)
                }
                closestPointToPointParameter(e, t) {
                    wu.subVectors(e, this.start), Eu.subVectors(this.end, this.start);
                    const n = Eu.dot(Eu);
                    let i = Eu.dot(wu) / n;
                    return t && (i = ce(i, 0, 1)), i
                }
                closestPointToPoint(e, t, n) {
                    const i = this.closestPointToPointParameter(e, t);
                    return this.delta(n).multiplyScalar(i).add(this.start)
                }
                applyMatrix4(e) {
                    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
                }
                equals(e) {
                    return e.start.equals(this.start) && e.end.equals(this.end)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            const Tu = new Fe,
                Su = new Fe,
                Au = new ut,
                Lu = new ut;
            class Ru extends Ys {
                constructor(e) {
                    const t = Pu(e),
                        n = new Mn,
                        i = [],
                        r = [],
                        a = new tn(0, 0, 1),
                        s = new tn(0, 1, 0);
                    for (let e = 0; e < t.length; e++) {
                        const n = t[e];
                        n.parent && n.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(a.r, a.g, a.b), r.push(s.r, s.g, s.b))
                    }
                    n.setAttribute("position", new mn(i, 3)), n.setAttribute("color", new mn(r, 3)), super(n, new Us({
                        vertexColors: true,
                        depthTest: false,
                        depthWrite: false,
                        toneMapped: false,
                        transparent: true
                    })), this.type = "SkeletonHelper", this.isSkeletonHelper = true, this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = false
                }
                updateMatrixWorld(e) {
                    const t = this.bones,
                        n = this.geometry,
                        i = n.getAttribute("position");
                    Lu.copy(this.root.matrixWorld).invert();
                    for (let e = 0, n = 0; e < t.length; e++) {
                        const r = t[e];
                        r.parent && r.parent.isBone && (Au.multiplyMatrices(Lu, r.matrixWorld), Su.setFromMatrixPosition(Au), i.setXYZ(n, Su.x, Su.y, Su.z), Au.multiplyMatrices(Lu, r.parent.matrixWorld), Su.setFromMatrixPosition(Au), i.setXYZ(n + 1, Su.x, Su.y, Su.z), n += 2)
                    }
                    n.getAttribute("position").needsUpdate = true, super.updateMatrixWorld(e)
                }
            }
            function Pu(e) {
                const t = [];
                e && e.isBone && t.push(e);
                for (let n = 0; n < e.children.length; n++) t.push.apply(t, Pu(e.children[n]));
                return t
            }
            const Cu = new Fe,
                Iu = new tn,
                Fu = new tn;
            class Du extends Ys {
                constructor(e = 10, t = 10, n = 4473924, i = 8947848) {
                    n = new tn(n), i = new tn(i);
                    const r = t / 2,
                        a = e / t,
                        s = e / 2,
                        o = [],
                        l = [];
                    for (let e = 0, c = 0, u = -s; e <= t; e++, u += a) {
                        o.push(-s, 0, u, s, 0, u), o.push(u, 0, -s, u, 0, s);
                        const t = e === r ? n : i;
                        t.toArray(l, c), c += 3, t.toArray(l, c), c += 3, t.toArray(l, c), c += 3, t.toArray(l, c), c += 3
                    }
                    const c = new Mn;
                    c.setAttribute("position", new mn(o, 3)), c.setAttribute("color", new mn(l, 3)), super(c, new Us({
                        vertexColors: true,
                        toneMapped: false
                    })), this.type = "GridHelper"
                }
            }
            const Nu = new Fe,
                Ou = new Fe,
                Hu = new Fe,
                Uu = new Fe,
                Bu = new Qn;
            function zu(e, t, n, i, r, a, s) {
                Uu.set(r, a, s).unproject(i);
                const o = t[e];
                if (void 0 !== o) {
                    const e = n.getAttribute("position");
                    for (let t = 0, n = o.length; t < n; t++) e.setXYZ(o[t], Uu.x, Uu.y, Uu.z)
                }
            }
            const ku = new Oe;
            class Gu extends Ys {
                constructor(e, t = 16776960) {
                    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                        i = new Float32Array(24),
                        r = new Mn;
                    r.setIndex(new sn(n, 1)), r.setAttribute("position", new sn(i, 3)), super(r, new Us({
                        color: t,
                        toneMapped: false
                    })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = false, this.update()
                }
                update(e) {
                    if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && ku.setFromObject(this.object), ku.isEmpty()) return;
                    const t = ku.min,
                        n = ku.max,
                        i = this.geometry.attributes.position,
                        r = i.array;
                    r[0] = n.x, r[1] = n.y, r[2] = n.z, r[3] = t.x, r[4] = n.y, r[5] = n.z, r[6] = t.x, r[7] = t.y, r[8] = n.z, r[9] = n.x, r[10] = t.y, r[11] = n.z, r[12] = n.x, r[13] = n.y, r[14] = t.z, r[15] = t.x, r[16] = n.y, r[17] = t.z, r[18] = t.x, r[19] = t.y, r[20] = t.z, r[21] = n.x, r[22] = t.y, r[23] = t.z, i.needsUpdate = true, this.geometry.computeBoundingSphere()
                }
                setFromObject(e) {
                    return this.object = e, this.update(), this
                }
                copy(e) {
                    return Ys.prototype.copy.call(this, e), this.object = e.object, this
                }
            }
            const Vu = new Fe;
            let ju, Wu;
            class Xu extends Ys {
                constructor(e = 1) {
                    const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
                        n = new Mn;
                    n.setAttribute("position", new mn(t, 3)), n.setAttribute("color", new mn([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), super(n, new Us({
                        vertexColors: true,
                        toneMapped: false
                    })), this.type = "AxesHelper"
                }
                setColors(e, t, n) {
                    const i = new tn,
                        r = this.geometry.attributes.color.array;
                    return i.set(e), i.toArray(r, 0), i.toArray(r, 3), i.set(t), i.toArray(r, 6), i.toArray(r, 9), i.set(n), i.toArray(r, 12), i.toArray(r, 15), this.geometry.attributes.color.needsUpdate = true, this
                }
                dispose() {
                    this.geometry.dispose(), this.material.dispose()
                }
            }
            const Yu = new Float32Array(1),
                qu = new Int32Array(Yu.buffer);
            go.create = function (e, t) {
                return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(go.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e
            }, Ho.prototype.fromPoints = function (e) {
                return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e)
            }, Du.prototype.setColors = function () {
                console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
            }, Ru.prototype.update = function () {
                console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
            }, tc.prototype.extractUrlBase = function (e) {
                return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Lc.extractUrlBase(e)
            }, tc.Handlers = {
                add: function () {
                    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
                },
                get: function () {
                    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
                }
            }, _u.prototype.center = function (e) {
                return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e)
            }, _u.prototype.empty = function () {
                return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            }, _u.prototype.isIntersectionBox = function (e) {
                return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
            }, _u.prototype.size = function (e) {
                return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e)
            }, Oe.prototype.center = function (e) {
                return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e)
            }, Oe.prototype.empty = function () {
                return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            }, Oe.prototype.isIntersectionBox = function (e) {
                return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
            }, Oe.prototype.isIntersectionSphere = function (e) {
                return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
            }, Oe.prototype.size = function (e) {
                return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e)
            }, tt.prototype.empty = function () {
                return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            }, oi.prototype.setFromMatrix = function (e) {
                return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(e)
            }, Mu.prototype.center = function (e) {
                return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e)
            }, ve.prototype.flattenToArrayOffset = function (e, t) {
                return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
            }, ve.prototype.multiplyVector3 = function (e) {
                return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
            }, ve.prototype.multiplyVector3Array = function () {
                console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
            }, ve.prototype.applyToBufferAttribute = function (e) {
                return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
            }, ve.prototype.applyToVector3Array = function () {
                console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
            }, ve.prototype.getInverse = function (e) {
                return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(e).invert()
            }, ut.prototype.extractPosition = function (e) {
                return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e)
            }, ut.prototype.flattenToArrayOffset = function (e, t) {
                return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
            }, ut.prototype.getPosition = function () {
                return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new Fe).setFromMatrixColumn(this, 3)
            }, ut.prototype.setRotationFromQuaternion = function (e) {
                return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e)
            }, ut.prototype.multiplyToArray = function () {
                console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
            }, ut.prototype.multiplyVector3 = function (e) {
                return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
            }, ut.prototype.multiplyVector4 = function (e) {
                return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
            }, ut.prototype.multiplyVector3Array = function () {
                console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
            }, ut.prototype.rotateAxis = function (e) {
                console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this)
            }, ut.prototype.crossVector = function (e) {
                return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
            }, ut.prototype.translate = function () {
                console.error("THREE.Matrix4: .translate() has been removed.")
            }, ut.prototype.rotateX = function () {
                console.error("THREE.Matrix4: .rotateX() has been removed.")
            }, ut.prototype.rotateY = function () {
                console.error("THREE.Matrix4: .rotateY() has been removed.")
            }, ut.prototype.rotateZ = function () {
                console.error("THREE.Matrix4: .rotateZ() has been removed.")
            }, ut.prototype.rotateByAxis = function () {
                console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
            }, ut.prototype.applyToBufferAttribute = function (e) {
                return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
            }, ut.prototype.applyToVector3Array = function () {
                console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
            }, ut.prototype.makeFrustum = function (e, t, n, i, r, a) {
                return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, i, n, r, a)
            }, ut.prototype.getInverse = function (e) {
                return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(e).invert()
            }, ri.prototype.isIntersectionLine = function (e) {
                return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e)
            }, Ie.prototype.multiplyVector3 = function (e) {
                return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this)
            }, Ie.prototype.inverse = function () {
                return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert()
            }, ct.prototype.isIntersectionBox = function (e) {
                return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
            }, ct.prototype.isIntersectionPlane = function (e) {
                return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e)
            }, ct.prototype.isIntersectionSphere = function (e) {
                return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
            }, Xt.prototype.area = function () {
                return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
            }, Xt.prototype.barycoordFromPoint = function (e, t) {
                return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t)
            }, Xt.prototype.midpoint = function (e) {
                return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e)
            }, Xt.prototypenormal = function (e) {
                return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e)
            }, Xt.prototype.plane = function (e) {
                return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e)
            }, Xt.barycoordFromPoint = function (e, t, n, i, r) {
                return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Xt.getBarycoord(e, t, n, i, r)
            }, Xt.normal = function (e, t, n, i) {
                return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Xt.getNormal(e, t, n, i)
            }, Uo.prototype.extractAllPoints = function (e) {
                return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e)
            }, Uo.prototype.extrude = function (e) {
                return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new dl(this, e)
            }, Uo.prototype.makeGeometry = function (e) {
                return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new yl(this, e)
            }, ge.prototype.fromAttribute = function (e, t, n) {
                return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
            }, ge.prototype.distanceToManhattan = function (e) {
                return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
            }, ge.prototype.lengthManhattan = function () {
                return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }, Fe.prototype.setEulerFromRotationMatrix = function () {
                console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
            }, Fe.prototype.setEulerFromQuaternion = function () {
                console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
            }, Fe.prototype.getPositionFromMatrix = function (e) {
                return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e)
            }, Fe.prototype.getScaleFromMatrix = function (e) {
                return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e)
            }, Fe.prototype.getColumnFromMatrix = function (e, t) {
                return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e)
            }, Fe.prototype.applyProjection = function (e) {
                return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e)
            }, Fe.prototype.fromAttribute = function (e, t, n) {
                return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
            }, Fe.prototype.distanceToManhattan = function (e) {
                return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
            }, Fe.prototype.lengthManhattan = function () {
                return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }, Le.prototype.fromAttribute = function (e, t, n) {
                return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
            }, Le.prototype.lengthManhattan = function () {
                return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }, Nt.prototype.getChildByName = function (e) {
                return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e)
            }, Nt.prototype.renderDepth = function () {
                console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
            }, Nt.prototype.translate = function (e, t) {
                return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e)
            }, Nt.prototype.getWorldRotation = function () {
                console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
            }, Nt.prototype.applyMatrix = function (e) {
                return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e)
            }, Object.defineProperties(Nt.prototype, {
                eulerOrder: {
                    get: function () {
                        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                    },
                    set: function (e) {
                        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e
                    }
                },
                useQuaternion: {
                    get: function () {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    },
                    set: function () {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    }
                }
            }), Gn.prototype.setDrawMode = function () {
                console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
            }, Object.defineProperties(Gn.prototype, {
                drawMode: {
                    get: function () {
                        return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0
                    },
                    set: function () {
                        console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                    }
                }
            }), Ss.prototype.initBones = function () {
                console.error("THREE.SkinnedMesh: initBones() has been removed.")
            }, Jn.prototype.setLens = function (e, t) {
                console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e)
            }, Object.defineProperties(lc.prototype, {
                onlyShadow: {
                    set: function () {
                        console.warn("THREE.Light: .onlyShadow has been removed.")
                    }
                },
                shadowCameraFov: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e
                    }
                },
                shadowCameraLeft: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e
                    }
                },
                shadowCameraRight: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e
                    }
                },
                shadowCameraTop: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e
                    }
                },
                shadowCameraBottom: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e
                    }
                },
                shadowCameraNear: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e
                    }
                },
                shadowCameraFar: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e
                    }
                },
                shadowCameraVisible: {
                    set: function () {
                        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                    }
                },
                shadowBias: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e
                    }
                },
                shadowDarkness: {
                    set: function () {
                        console.warn("THREE.Light: .shadowDarkness has been removed.")
                    }
                },
                shadowMapWidth: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e
                    }
                },
                shadowMapHeight: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e
                    }
                }
            }), Object.defineProperties(sn.prototype, {
                length: {
                    get: function () {
                        return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                    }
                },
                dynamic: {
                    get: function () {
                        return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === te
                    },
                    set: function () {
                        console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(te)
                    }
                }
            }), sn.prototype.setDynamic = function (e) {
                return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? te : ee), this
            }, sn.prototype.copyIndicesArray = function () {
                console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
            }, sn.prototype.setArray = function () {
                console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
            }, Mn.prototype.addIndex = function (e) {
                console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e)
            }, Mn.prototype.addAttribute = function (e, t) {
                return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this) : this.setAttribute(e, t) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(e, new sn(arguments[1], arguments[2])))
            }, Mn.prototype.addDrawCall = function (e, t, n) {
                void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t)
            }, Mn.prototype.clearDrawCalls = function () {
                console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
            }, Mn.prototype.computeOffsets = function () {
                console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
            }, Mn.prototype.removeAttribute = function (e) {
                return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(e)
            }, Mn.prototype.applyMatrix = function (e) {
                return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e)
            }, Object.defineProperties(Mn.prototype, {
                drawcalls: {
                    get: function () {
                        return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                    }
                },
                offsets: {
                    get: function () {
                        return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                    }
                }
            }), $a.prototype.setDynamic = function (e) {
                return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? te : ee), this
            }, $a.prototype.setArray = function () {
                console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
            }, dl.prototype.getArrays = function () {
                console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
            }, dl.prototype.addShapeList = function () {
                console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
            }, dl.prototype.addShape = function () {
                console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
            }, Ka.prototype.dispose = function () {
                console.error("THREE.Scene: .dispose() has been removed.")
            }, mu.prototype.onUpdate = function () {
                return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
            }, Object.defineProperties(qt.prototype, {
                wrapAround: {
                    get: function () {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    },
                    set: function () {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    }
                },
                overdraw: {
                    get: function () {
                        console.warn("THREE.Material: .overdraw has been removed.")
                    },
                    set: function () {
                        console.warn("THREE.Material: .overdraw has been removed.")
                    }
                },
                wrapRGB: {
                    get: function () {
                        return console.warn("THREE.Material: .wrapRGB has been removed."), new tn
                    }
                },
                shading: {
                    get: function () {
                        console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                    },
                    set: function (e) {
                        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === e
                    }
                },
                stencilMask: {
                    get: function () {
                        return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
                    },
                    set: function (e) {
                        console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = e
                    }
                },
                vertexTangents: {
                    get: function () {
                        console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
                    },
                    set: function () {
                        console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
                    }
                }
            }), Object.defineProperties(qn.prototype, {
                derivatives: {
                    get: function () {
                        return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                    },
                    set: function (e) {
                        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e
                    }
                }
            }), qa.prototype.clearTarget = function (e, t, n, i) {
                console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e), this.clear(t, n, i)
            }, qa.prototype.animate = function (e) {
                console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e)
            }, qa.prototype.getCurrentRenderTarget = function () {
                return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
            }, qa.prototype.getMaxAnisotropy = function () {
                return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
            }, qa.prototype.getPrecision = function () {
                return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
            }, qa.prototype.resetGLState = function () {
                return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
            }, qa.prototype.supportsFloatTextures = function () {
                return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
            }, qa.prototype.supportsHalfFloatTextures = function () {
                return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
            }, qa.prototype.supportsStandardDerivatives = function () {
                return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
            }, qa.prototype.supportsCompressedTextureS3TC = function () {
                return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
            }, qa.prototype.supportsCompressedTexturePVRTC = function () {
                return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
            }, qa.prototype.supportsBlendMinMax = function () {
                return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
            }, qa.prototype.supportsVertexTextures = function () {
                return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
            }, qa.prototype.supportsInstancedArrays = function () {
                return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
            }, qa.prototype.enableScissorTest = function (e) {
                console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e)
            }, qa.prototype.initMaterial = function () {
                console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
            }, qa.prototype.addPrePlugin = function () {
                console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
            }, qa.prototype.addPostPlugin = function () {
                console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
            }, qa.prototype.updateShadowMap = function () {
                console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
            }, qa.prototype.setFaceCulling = function () {
                console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
            }, qa.prototype.allocTextureUnit = function () {
                console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
            }, qa.prototype.setTexture = function () {
                console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
            }, qa.prototype.setTexture2D = function () {
                console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
            }, qa.prototype.setTextureCube = function () {
                console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
            }, qa.prototype.getActiveMipMapLevel = function () {
                return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
            }, Object.defineProperties(qa.prototype, {
                shadowMapEnabled: {
                    get: function () {
                        return this.shadowMap.enabled
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e
                    }
                },
                shadowMapType: {
                    get: function () {
                        return this.shadowMap.type
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e
                    }
                },
                shadowMapCullFace: {
                    get: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    }
                },
                context: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
                    }
                },
                vr: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr
                    }
                },
                gammaInput: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), false
                    },
                    set: function () {
                        console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
                    }
                },
                gammaOutput: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), false
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === e ? Y : X
                    }
                },
                toneMappingWhitePoint: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1
                    },
                    set: function () {
                        console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
                    }
                }
            }), Object.defineProperties(Ha.prototype, {
                cullFace: {
                    get: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderReverseSided: {
                    get: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderSingleSided: {
                    get: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    }
                }
            }), Object.defineProperties(Re.prototype, {
                wrapS: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e
                    }
                },
                wrapT: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e
                    }
                },
                magFilter: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e
                    }
                },
                minFilter: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e
                    }
                },
                anisotropy: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e
                    }
                },
                offset: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e
                    }
                },
                repeat: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e
                    }
                },
                format: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e
                    }
                },
                type: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e
                    }
                },
                generateMipmaps: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e
                    }
                }
            }), Qc.prototype.load = function (e) {
                console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                const t = this;
                return (new Hc).load(e, (function (e) {
                    t.setBuffer(e)
                })), this
            }, eu.prototype.getData = function () {
                return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
            }, Kn.prototype.updateCubeMap = function (e, t) {
                return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t)
            }, Kn.prototype.clear = function (e, t, n, i) {
                return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(e, t, n, i)
            }, Me.crossOrigin = void 0, Me.loadTexture = function (e, t, n, i) {
                console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                const r = new oc;
                r.setCrossOrigin(this.crossOrigin);
                const a = r.load(e, n, void 0, i);
                return t && (a.mapping = t), a
            }, Me.loadTextureCube = function (e, t, n, i) {
                console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                const r = new ac;
                r.setCrossOrigin(this.crossOrigin);
                const a = r.load(e, n, void 0, i);
                return t && (a.mapping = t), a
            }, Me.loadCompressedTexture = function () {
                console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
            }, Me.loadCompressedTextureCube = function () {
                console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
            };
            const Qu = {
                createMultiMaterialObject: function () {
                    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")
                },
                detach: function () {
                    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")
                },
                attach: function () {
                    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")
                }
            };
            "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
                detail: {
                    revision: t
                }
            })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = t), e.ACESFilmicToneMapping = 4, e.AddEquation = n, e.AddOperation = 2, e.AdditiveAnimationBlendMode = W, e.AdditiveBlending = 2, e.AlphaFormat = 1021, e.AlwaysDepth = 1, e.AlwaysStencilFunc = 519, e.AmbientLight = Ec, e.AmbientLightProbe = Bc, e.AnimationClip = Jl, e.AnimationLoader = class extends tc {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, i) {
                    const r = this,
                        a = new ic(this.manager);
                    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, (function (n) {
                        try {
                            t(r.parse(JSON.parse(n)))
                        } catch (t) {
                            i ? i(t) : console.error(t), r.manager.itemError(e)
                        }
                    }), n, i)
                }
                parse(e) {
                    const t = [];
                    for (let n = 0; n < e.length; n++) {
                        const i = Jl.parse(e[n]);
                        t.push(i)
                    }
                    return t
                }
            }, e.AnimationMixer = fu, e.AnimationObjectGroup = du, e.AnimationUtils = Hl, e.ArcCurve = yo, e.ArrayCamera = ka, e.ArrowHelper = class extends Nt {
                constructor(e = new Fe(0, 0, 1), t = new Fe(0, 0, 0), n = 1, i = 16776960, r = .2 * n, a = .2 * r) {
                    super(), this.type = "ArrowHelper", void 0 === ju && (ju = new Mn, ju.setAttribute("position", new mn([0, 0, 0, 0, 1, 0], 3)), Wu = new so(0, .5, 1, 5, 1), Wu.translate(0, -.5, 0)), this.position.copy(t), this.line = new js(ju, new Us({
                        color: i,
                        toneMapped: false
                    })), this.line.matrixAutoUpdate = false, this.add(this.line), this.cone = new Gn(Wu, new nn({
                        color: i,
                        toneMapped: false
                    })), this.cone.matrixAutoUpdate = false, this.add(this.cone), this.setDirection(e), this.setLength(n, r, a)
                }
                setDirection(e) {
                    if (e.y > .99999) this.quaternion.set(0, 0, 0, 1);
                    else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0);
                    else {
                        Vu.set(e.z, 0, -e.x).normalize();
                        const t = Math.acos(e.y);
                        this.quaternion.setFromAxisAngle(Vu, t)
                    }
                }
                setLength(e, t = .2 * e, n = .2 * t) {
                    this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix()
                }
                setColor(e) {
                    this.line.material.color.set(e), this.cone.material.color.set(e)
                }
                copy(e) {
                    return super.copy(e, false), this.line.copy(e.line), this.cone.copy(e.cone), this
                }
            }, e.Audio = Qc, e.AudioAnalyser = eu, e.AudioContext = Oc, e.AudioListener = class extends Nt {
                constructor() {
                    super(), this.type = "AudioListener", this.context = Oc.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Vc
                }
                getInput() {
                    return this.gain
                }
                removeFilter() {
                    return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
                }
                getFilter() {
                    return this.filter
                }
                setFilter(e) {
                    return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
                }
                getMasterVolume() {
                    return this.gain.gain.value
                }
                setMasterVolume(e) {
                    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
                }
                updateMatrixWorld(e) {
                    super.updateMatrixWorld(e);
                    const t = this.context.listener,
                        n = this.up;
                    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Wc, Xc, Yc), qc.set(0, 0, -1).applyQuaternion(Xc), t.positionX) {
                        const e = this.context.currentTime + this.timeDelta;
                        t.positionX.linearRampToValueAtTime(Wc.x, e), t.positionY.linearRampToValueAtTime(Wc.y, e), t.positionZ.linearRampToValueAtTime(Wc.z, e), t.forwardX.linearRampToValueAtTime(qc.x, e), t.forwardY.linearRampToValueAtTime(qc.y, e), t.forwardZ.linearRampToValueAtTime(qc.z, e), t.upX.linearRampToValueAtTime(n.x, e), t.upY.linearRampToValueAtTime(n.y, e), t.upZ.linearRampToValueAtTime(n.z, e)
                    } else t.setPosition(Wc.x, Wc.y, Wc.z), t.setOrientation(qc.x, qc.y, qc.z, n.x, n.y, n.z)
                }
            }, e.AudioLoader = Hc, e.AxesHelper = Xu, e.AxisHelper = function (e) {
                return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new Xu(e)
            }, e.BackSide = 1, e.BasicDepthPacking = 3200, e.BasicShadowMap = 0, e.BinaryTextureLoader = function (e) {
                return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new sc(e)
            }, e.Bone = As, e.BooleanKeyframeTrack = Vl, e.BoundingBoxHelper = function (e, t) {
                return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new Gu(e, t)
            }, e.Box2 = _u, e.Box3 = Oe, e.Box3Helper = class extends Ys {
                constructor(e, t = 16776960) {
                    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                        i = new Mn;
                    i.setIndex(new sn(n, 1)), i.setAttribute("position", new mn([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(i, new Us({
                        color: t,
                        toneMapped: false
                    })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere()
                }
                updateMatrixWorld(e) {
                    const t = this.box;
                    t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(e))
                }
            }, e.BoxBufferGeometry = jn, e.BoxGeometry = jn, e.BoxHelper = Gu, e.BufferAttribute = sn, e.BufferGeometry = Mn, e.BufferGeometryLoader = Pc, e.ByteType = 1010, e.Cache = Kl, e.Camera = Qn, e.CameraHelper = class extends Ys {
                constructor(e) {
                    const t = new Mn,
                        n = new Us({
                            color: 16777215,
                            vertexColors: true,
                            toneMapped: false
                        }),
                        i = [],
                        r = [],
                        a = {},
                        s = new tn(16755200),
                        o = new tn(16711680),
                        l = new tn(43775),
                        c = new tn(16777215),
                        u = new tn(3355443);
                    function h(e, t, n) {
                        d(e, n), d(t, n)
                    }
                    function d(e, t) {
                        i.push(0, 0, 0), r.push(t.r, t.g, t.b), void 0 === a[e] && (a[e] = []), a[e].push(i.length / 3 - 1)
                    }
                    h("n1", "n2", s), h("n2", "n4", s), h("n4", "n3", s), h("n3", "n1", s), h("f1", "f2", s), h("f2", "f4", s), h("f4", "f3", s), h("f3", "f1", s), h("n1", "f1", s), h("n2", "f2", s), h("n3", "f3", s), h("n4", "f4", s), h("p", "n1", o), h("p", "n2", o), h("p", "n3", o), h("p", "n4", o), h("u1", "u2", l), h("u2", "u3", l), h("u3", "u1", l), h("c", "t", c), h("p", "c", u), h("cn1", "cn2", u), h("cn3", "cn4", u), h("cf1", "cf2", u), h("cf3", "cf4", u), t.setAttribute("position", new mn(i, 3)), t.setAttribute("color", new mn(r, 3)), super(t, n), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = false, this.pointMap = a, this.update()
                }
                update() {
                    const e = this.geometry,
                        t = this.pointMap;
                    Bu.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), zu("c", t, e, Bu, 0, 0, -1), zu("t", t, e, Bu, 0, 0, 1), zu("n1", t, e, Bu, -1, -1, -1), zu("n2", t, e, Bu, 1, -1, -1), zu("n3", t, e, Bu, -1, 1, -1), zu("n4", t, e, Bu, 1, 1, -1), zu("f1", t, e, Bu, -1, -1, 1), zu("f2", t, e, Bu, 1, -1, 1), zu("f3", t, e, Bu, -1, 1, 1), zu("f4", t, e, Bu, 1, 1, 1), zu("u1", t, e, Bu, .7, 1.1, -1), zu("u2", t, e, Bu, -.7, 1.1, -1), zu("u3", t, e, Bu, 0, 2, -1), zu("cf1", t, e, Bu, -1, 0, 1), zu("cf2", t, e, Bu, 1, 0, 1), zu("cf3", t, e, Bu, 0, -1, 1), zu("cf4", t, e, Bu, 0, 1, 1), zu("cn1", t, e, Bu, -1, 0, -1), zu("cn2", t, e, Bu, 1, 0, -1), zu("cn3", t, e, Bu, 0, -1, -1), zu("cn4", t, e, Bu, 0, 1, -1), e.getAttribute("position").needsUpdate = true
                }
                dispose() {
                    this.geometry.dispose(), this.material.dispose()
                }
            }, e.CanvasRenderer = function () {
                console.error("THREE.CanvasRenderer has been removed")
            }, e.CanvasTexture = ro, e.CatmullRomCurve3 = Mo, e.CineonToneMapping = 3, e.CircleBufferGeometry = ao, e.CircleGeometry = ao, e.ClampToEdgeWrapping = h, e.Clock = Vc, e.Color = tn, e.ColorKeyframeTrack = jl, e.CompressedTexture = io, e.CompressedTextureLoader = class extends tc {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, i) {
                    const r = this,
                        a = [],
                        s = new io,
                        o = new ic(this.manager);
                    o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(r.withCredentials);
                    let l = 0;
                    function c(c) {
                        o.load(e[c], (function (e) {
                            const n = r.parse(e, true);
                            a[c] = {
                                width: n.width,
                                height: n.height,
                                format: n.format,
                                mipmaps: n.mipmaps
                            }, l += 1, 6 === l && (1 === n.mipmapCount && (s.minFilter = g), s.image = a, s.format = n.format, s.needsUpdate = true, t && t(s))
                        }), n, i)
                    }
                    if (Array.isArray(e))
                        for (let t = 0, n = e.length; t < n; ++t) c(t);
                    else o.load(e, (function (e) {
                        const n = r.parse(e, true);
                        if (n.isCubemap) {
                            const e = n.mipmaps.length / n.mipmapCount;
                            for (let t = 0; t < e; t++) {
                                a[t] = {
                                    mipmaps: []
                                };
                                for (let e = 0; e < n.mipmapCount; e++) a[t].mipmaps.push(n.mipmaps[t * n.mipmapCount + e]), a[t].format = n.format, a[t].width = n.width, a[t].height = n.height
                            }
                            s.image = a
                        } else s.image.width = n.width, s.image.height = n.height, s.mipmaps = n.mipmaps;
                        1 === n.mipmapCount && (s.minFilter = g), s.format = n.format, s.needsUpdate = true, t && t(s)
                    }), n, i);
                    return s
                }
            }, e.ConeBufferGeometry = oo, e.ConeGeometry = oo, e.CubeCamera = Kn, e.CubeReflectionMapping = r, e.CubeRefractionMapping = a, e.CubeTexture = $n, e.CubeTextureLoader = ac, e.CubeUVReflectionMapping = l, e.CubeUVRefractionMapping = c, e.CubicBezierCurve = Lo, e.CubicBezierCurve3 = Ro, e.CubicInterpolant = Bl, e.CullFaceBack = 1, e.CullFaceFront = 2, e.CullFaceFrontBack = 3, e.CullFaceNone = 0, e.Curve = go, e.CurvePath = Oo, e.CustomBlending = 5, e.CustomToneMapping = 5, e.CylinderBufferGeometry = so, e.CylinderGeometry = so, e.Cylindrical = class {
                constructor(e = 1, t = 0, n = 0) {
                    return this.radius = e, this.theta = t, this.y = n, this
                }
                set(e, t, n) {
                    return this.radius = e, this.theta = t, this.y = n, this
                }
                copy(e) {
                    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this
                }
                setFromVector3(e) {
                    return this.setFromCartesianCoords(e.x, e.y, e.z)
                }
                setFromCartesianCoords(e, t, n) {
                    return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }, e.DataTexture = Ls, e.DataTexture2DArray = Xi, e.DataTexture3D = Ki, e.DataTextureLoader = sc, e.DataUtils = class {
                static toHalfFloat(e) {
                    e > 65504 && (console.warn("THREE.DataUtils.toHalfFloat(): value exceeds 65504."), e = 65504), Yu[0] = e;
                    const t = qu[0];
                    let n = t >> 16 & 32768,
                        i = t >> 12 & 2047;
                    const r = t >> 23 & 255;
                    return r < 103 ? n : r > 142 ? (n |= 31744, n |= (255 == r ? 0 : 1) && 8388607 & t, n) : r < 113 ? (i |= 2048, n |= (i >> 114 - r) + (i >> 113 - r & 1), n) : (n |= r - 112 << 10 | i >> 1, n += 1 & i, n)
                }
            }, e.DecrementStencilOp = 7683, e.DecrementWrapStencilOp = 34056, e.DefaultLoadingManager = ec, e.DepthFormat = A, e.DepthStencilFormat = L, e.DepthTexture = Wa, e.DirectionalLight = wc, e.DirectionalLightHelper = class extends Nt {
                constructor(e, t, n) {
                    super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = false, this.color = n, void 0 === t && (t = 1);
                    let i = new Mn;
                    i.setAttribute("position", new mn([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
                    const r = new Us({
                        fog: false,
                        toneMapped: false
                    });
                    this.lightPlane = new js(i, r), this.add(this.lightPlane), i = new Mn, i.setAttribute("position", new mn([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new js(i, r), this.add(this.targetLine), this.update()
                }
                dispose() {
                    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
                }
                update() {
                    Nu.setFromMatrixPosition(this.light.matrixWorld), Ou.setFromMatrixPosition(this.light.target.matrixWorld), Hu.subVectors(Ou, Nu), this.lightPlane.lookAt(Ou), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Ou), this.targetLine.scale.z = Hu.length()
                }
            }, e.DiscreteInterpolant = kl, e.DodecahedronBufferGeometry = co, e.DodecahedronGeometry = co, e.DoubleSide = 2, e.DstAlphaFactor = 206, e.DstColorFactor = 208, e.DynamicBufferAttribute = function (e, t) {
                return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."), new sn(e, t).setUsage(te)
            }, e.DynamicCopyUsage = 35050, e.DynamicDrawUsage = te, e.DynamicReadUsage = 35049, e.EdgesGeometry = mo, e.EdgesHelper = function (e, t) {
                return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Ys(new mo(e.geometry), new Us({
                    color: void 0 !== t ? t : 16777215
                }))
            }, e.EllipseCurve = vo, e.EqualDepth = 4, e.EqualStencilFunc = 514, e.EquirectangularReflectionMapping = s, e.EquirectangularRefractionMapping = o, e.Euler = bt, e.EventDispatcher = ie, e.ExtrudeBufferGeometry = dl, e.ExtrudeGeometry = dl, e.FaceColors = 1, e.FileLoader = ic, e.FlatShading = 1, e.Float16BufferAttribute = fn, e.Float32Attribute = function (e, t) {
                return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new mn(e, t)
            }, e.Float32BufferAttribute = mn, e.Float64Attribute = function (e, t) {
                return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new gn(e, t)
            }, e.Float64BufferAttribute = gn, e.FloatType = w, e.Fog = Za, e.FogExp2 = Ja, e.Font = function () {
                console.error("THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js")
            }, e.FontLoader = function () {
                console.error("THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js")
            }, e.FrontSide = 0, e.Frustum = oi, e.GLBufferAttribute = vu, e.GLSL1 = "100", e.GLSL3 = ne, e.GammaEncoding = q, e.GreaterDepth = 6, e.GreaterEqualDepth = 5, e.GreaterEqualStencilFunc = 518, e.GreaterStencilFunc = 516, e.GridHelper = Du, e.Group = Ga, e.HalfFloatType = E, e.HemisphereLight = cc, e.HemisphereLightHelper = class extends Nt {
                constructor(e, t, n) {
                    super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = false, this.color = n;
                    const i = new gl(t);
                    i.rotateY(.5 * Math.PI), this.material = new nn({
                        wireframe: true,
                        fog: false,
                        toneMapped: false
                    }), void 0 === this.color && (this.material.vertexColors = true);
                    const r = i.getAttribute("position"),
                        a = new Float32Array(3 * r.count);
                    i.setAttribute("color", new sn(a, 3)), this.add(new Gn(i, this.material)), this.update()
                }
                dispose() {
                    this.children[0].geometry.dispose(), this.children[0].material.dispose()
                }
                update() {
                    const e = this.children[0];
                    if (void 0 !== this.color) this.material.color.set(this.color);
                    else {
                        const t = e.geometry.getAttribute("color");
                        Iu.copy(this.light.color), Fu.copy(this.light.groundColor);
                        for (let e = 0, n = t.count; e < n; e++) {
                            const i = e < n / 2 ? Iu : Fu;
                            t.setXYZ(e, i.r, i.g, i.b)
                        }
                        t.needsUpdate = true
                    }
                    e.lookAt(Cu.setFromMatrixPosition(this.light.matrixWorld).negate())
                }
            }, e.HemisphereLightProbe = Uc, e.IcosahedronBufferGeometry = fl, e.IcosahedronGeometry = fl, e.ImageBitmapLoader = Dc, e.ImageLoader = rc, e.ImageUtils = Me, e.ImmediateRenderObject = function () {
                console.error("THREE.ImmediateRenderObject has been removed.")
            }, e.IncrementStencilOp = 7682, e.IncrementWrapStencilOp = 34055, e.InstancedBufferAttribute = Is, e.InstancedBufferGeometry = Rc, e.InstancedInterleavedBuffer = gu, e.InstancedMesh = Hs, e.Int16Attribute = function (e, t) {
                return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new un(e, t)
            }, e.Int16BufferAttribute = un, e.Int32Attribute = function (e, t) {
                return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new dn(e, t)
            }, e.Int32BufferAttribute = dn, e.Int8Attribute = function (e, t) {
                return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new on(e, t)
            }, e.Int8BufferAttribute = on, e.IntType = 1013, e.InterleavedBuffer = $a, e.InterleavedBufferAttribute = ts, e.Interpolant = Ul, e.InterpolateDiscrete = B, e.InterpolateLinear = z, e.InterpolateSmooth = k, e.InvertStencilOp = 5386, e.JSONLoader = function () {
                console.error("THREE.JSONLoader has been removed.")
            }, e.KeepStencilOp = $, e.KeyframeTrack = Gl, e.LOD = bs, e.LatheBufferGeometry = ml, e.LatheGeometry = ml, e.Layers = _t, e.LensFlare = function () {
                console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")
            }, e.LessDepth = 2, e.LessEqualDepth = 3, e.LessEqualStencilFunc = 515, e.LessStencilFunc = 513, e.Light = lc, e.LightProbe = Sc, e.Line = js, e.Line3 = Mu, e.LineBasicMaterial = Us, e.LineCurve = Po, e.LineCurve3 = Co, e.LineDashedMaterial = Nl, e.LineLoop = qs, e.LinePieces = 1, e.LineSegments = Ys, e.LineStrip = 0, e.LinearEncoding = X, e.LinearFilter = g, e.LinearInterpolant = zl, e.LinearMipMapLinearFilter = 1008, e.LinearMipMapNearestFilter = 1007, e.LinearMipmapLinearFilter = y, e.LinearMipmapNearestFilter = v, e.LinearToneMapping = 1, e.Loader = tc, e.LoaderUtils = Lc, e.LoadingManager = $l, e.LoopOnce = 2200, e.LoopPingPong = 2202, e.LoopRepeat = 2201, e.LuminanceAlphaFormat = 1025, e.LuminanceFormat = 1024, e.MOUSE = {
                LEFT: 0,
                MIDDLE: 1,
                RIGHT: 2,
                ROTATE: 0,
                DOLLY: 1,
                PAN: 2
            }, e.Material = qt, e.MaterialLoader = Ac, e.Math = me, e.MathUtils = me, e.Matrix3 = ve, e.Matrix4 = ut, e.MaxEquation = 104, e.Mesh = Gn, e.MeshBasicMaterial = nn, e.MeshDepthMaterial = Na, e.MeshDistanceMaterial = Oa, e.MeshFaceMaterial = function (e) {
                return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), e
            }, e.MeshLambertMaterial = Fl, e.MeshMatcapMaterial = Dl, e.MeshNormalMaterial = Il, e.MeshPhongMaterial = Pl, e.MeshPhysicalMaterial = Rl, e.MeshStandardMaterial = Ll, e.MeshToonMaterial = Cl, e.MinEquation = 103, e.MirroredRepeatWrapping = d, e.MixOperation = 1, e.MultiMaterial = function (e = []) {
                return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), e.isMultiMaterial = true, e.materials = e, e.clone = function () {
                    return e.slice()
                }, e
            }, e.MultiplyBlending = 4, e.MultiplyOperation = 0, e.NearestFilter = p, e.NearestMipMapLinearFilter = 1005, e.NearestMipMapNearestFilter = 1004, e.NearestMipmapLinearFilter = m, e.NearestMipmapNearestFilter = f, e.NeverDepth = 0, e.NeverStencilFunc = 512, e.NoBlending = 0, e.NoColors = 0, e.NoToneMapping = 0, e.NormalAnimationBlendMode = 2500, e.NormalBlending = 1, e.NotEqualDepth = 7, e.NotEqualStencilFunc = 517, e.NumberKeyframeTrack = Wl, e.Object3D = Nt, e.ObjectLoader = class extends tc {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, i) {
                    const r = this,
                        a = "" === this.path ? Lc.extractUrlBase(e) : this.path;
                    this.resourcePath = this.resourcePath || a;
                    const s = new ic(this.manager);
                    s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, (function (n) {
                        let a = null;
                        try {
                            a = JSON.parse(n)
                        } catch (t) {
                            return void 0 !== i && i(t), void console.error("THREE:ObjectLoader: Can't parse " + e + ".", t.message)
                        }
                        const s = a.metadata;
                        void 0 !== s && void 0 !== s.type && "geometry" !== s.type.toLowerCase() ? r.parse(a, t) : console.error("THREE.ObjectLoader: Can't load " + e)
                    }), n, i)
                }
                async loadAsync(e, t) {
                    const n = "" === this.path ? Lc.extractUrlBase(e) : this.path;
                    this.resourcePath = this.resourcePath || n;
                    const i = new ic(this.manager);
                    i.setPath(this.path), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials);
                    const r = await i.loadAsync(e, t),
                        a = JSON.parse(r),
                        s = a.metadata;
                    if (void 0 === s || void 0 === s.type || "geometry" === s.type.toLowerCase()) throw new Error("THREE.ObjectLoader: Can't load " + e);
                    return await this.parseAsync(a)
                }
                parse(e, t) {
                    const n = this.parseAnimations(e.animations),
                        i = this.parseShapes(e.shapes),
                        r = this.parseGeometries(e.geometries, i),
                        a = this.parseImages(e.images, (function () {
                            void 0 !== t && t(l)
                        })),
                        s = this.parseTextures(e.textures, a),
                        o = this.parseMaterials(e.materials, s),
                        l = this.parseObject(e.object, r, o, s, n),
                        c = this.parseSkeletons(e.skeletons, l);
                    if (this.bindSkeletons(l, c), void 0 !== t) {
                        let e = false;
                        for (const t in a)
                            if (a[t] instanceof HTMLImageElement) {
                                e = true;
                                break
                            }! 1 === e && t(l)
                    }
                    return l
                }
                async parseAsync(e) {
                    const t = this.parseAnimations(e.animations),
                        n = this.parseShapes(e.shapes),
                        i = this.parseGeometries(e.geometries, n),
                        r = await this.parseImagesAsync(e.images),
                        a = this.parseTextures(e.textures, r),
                        s = this.parseMaterials(e.materials, a),
                        o = this.parseObject(e.object, i, s, a, t),
                        l = this.parseSkeletons(e.skeletons, o);
                    return this.bindSkeletons(o, l), o
                }
                parseShapes(e) {
                    const t = {};
                    if (void 0 !== e)
                        for (let n = 0, i = e.length; n < i; n++) {
                            const i = (new Uo).fromJSON(e[n]);
                            t[i.uuid] = i
                        }
                    return t
                }
                parseSkeletons(e, t) {
                    const n = {},
                        i = {};
                    if (t.traverse((function (e) {
                            e.isBone && (i[e.uuid] = e)
                        })), void 0 !== e)
                        for (let t = 0, r = e.length; t < r; t++) {
                            const r = (new Cs).fromJSON(e[t], i);
                            n[r.uuid] = r
                        }
                    return n
                }
                parseGeometries(e, t) {
                    const n = {};
                    if (void 0 !== e) {
                        const i = new Pc;
                        for (let r = 0, a = e.length; r < a; r++) {
                            let a;
                            const s = e[r];
                            switch (s.type) {
                            case "BufferGeometry":
                            case "InstancedBufferGeometry":
                                a = i.parse(s);
                                break;
                            case "Geometry":
                                console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");
                                break;
                            default:
                                s.type in Sl ? a = Sl[s.type].fromJSON(s, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${s.type}"`)
                            }
                            a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), !0 === a.isBufferGeometry && void 0 !== s.userData && (a.userData = s.userData), n[s.uuid] = a
                        }
                    }
                    return n
                }
                parseMaterials(e, t) {
                    const n = {},
                        i = {};
                    if (void 0 !== e) {
                        const r = new Ac;
                        r.setTextures(t);
                        for (let t = 0, a = e.length; t < a; t++) {
                            const a = e[t];
                            if ("MultiMaterial" === a.type) {
                                const e = [];
                                for (let t = 0; t < a.materials.length; t++) {
                                    const i = a.materials[t];
                                    void 0 === n[i.uuid] && (n[i.uuid] = r.parse(i)), e.push(n[i.uuid])
                                }
                                i[a.uuid] = e
                            } else void 0 === n[a.uuid] && (n[a.uuid] = r.parse(a)), i[a.uuid] = n[a.uuid]
                        }
                    }
                    return i
                }
                parseAnimations(e) {
                    const t = {};
                    if (void 0 !== e)
                        for (let n = 0; n < e.length; n++) {
                            const i = e[n],
                                r = Jl.parse(i);
                            t[r.uuid] = r
                        }
                    return t
                }
                parseImages(e, t) {
                    const n = this,
                        i = {};
                    let r;
                    function a(e) {
                        if ("string" == typeof e) {
                            const t = e;
                            return function (e) {
                                return n.manager.itemStart(e), r.load(e, (function () {
                                    n.manager.itemEnd(e)
                                }), void 0, (function () {
                                    n.manager.itemError(e), n.manager.itemEnd(e)
                                }))
                            }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(t) ? t : n.resourcePath + t)
                        }
                        return e.data ? {
                            data: be(e.type, e.data),
                            width: e.width,
                            height: e.height
                        } : null
                    }
                    if (void 0 !== e && e.length > 0) {
                        const n = new $l(t);
                        r = new rc(n), r.setCrossOrigin(this.crossOrigin);
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t],
                                r = n.url;
                            if (Array.isArray(r)) {
                                i[n.uuid] = [];
                                for (let e = 0, t = r.length; e < t; e++) {
                                    const t = a(r[e]);
                                    null !== t && (t instanceof HTMLImageElement ? i[n.uuid].push(t) : i[n.uuid].push(new Ls(t.data, t.width, t.height)))
                                }
                            } else {
                                const e = a(n.url);
                                null !== e && (i[n.uuid] = e)
                            }
                        }
                    }
                    return i
                }
                async parseImagesAsync(e) {
                    const t = this,
                        n = {};
                    let i;
                    async function r(e) {
                        if ("string" == typeof e) {
                            const n = e,
                                r = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(n) ? n : t.resourcePath + n;
                            return await i.loadAsync(r)
                        }
                        return e.data ? {
                            data: be(e.type, e.data),
                            width: e.width,
                            height: e.height
                        } : null
                    }
                    if (void 0 !== e && e.length > 0) {
                        i = new rc(this.manager), i.setCrossOrigin(this.crossOrigin);
                        for (let t = 0, i = e.length; t < i; t++) {
                            const i = e[t],
                                a = i.url;
                            if (Array.isArray(a)) {
                                n[i.uuid] = [];
                                for (let e = 0, t = a.length; e < t; e++) {
                                    const t = a[e],
                                        s = await r(t);
                                    null !== s && (s instanceof HTMLImageElement ? n[i.uuid].push(s) : n[i.uuid].push(new Ls(s.data, s.width, s.height)))
                                }
                            } else {
                                const e = await r(i.url);
                                null !== e && (n[i.uuid] = e)
                            }
                        }
                    }
                    return n
                }
                parseTextures(e, t) {
                    function n(e, t) {
                        return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e])
                    }
                    const i = {};
                    if (void 0 !== e)
                        for (let r = 0, a = e.length; r < a; r++) {
                            const a = e[r];
                            let s;
                            void 0 === a.image && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), void 0 === t[a.image] && console.warn("THREE.ObjectLoader: Undefined image", a.image);
                            const o = t[a.image];
                            Array.isArray(o) ? (s = new $n(o), 6 === o.length && (s.needsUpdate = true)) : (s = o && o.data ? new Ls(o.data, o.width, o.height) : new Se(o), o && (s.needsUpdate = true)), s.uuid = a.uuid, void 0 !== a.name && (s.name = a.name), void 0 !== a.mapping && (s.mapping = n(a.mapping, Cc)), void 0 !== a.offset && s.offset.fromArray(a.offset), void 0 !== a.repeat && s.repeat.fromArray(a.repeat), void 0 !== a.center && s.center.fromArray(a.center), void 0 !== a.rotation && (s.rotation = a.rotation), void 0 !== a.wrap && (s.wrapS = n(a.wrap[0], Ic), s.wrapT = n(a.wrap[1], Ic)), void 0 !== a.format && (s.format = a.format), void 0 !== a.type && (s.type = a.type), void 0 !== a.encoding && (s.encoding = a.encoding), void 0 !== a.minFilter && (s.minFilter = n(a.minFilter, Fc)), void 0 !== a.magFilter && (s.magFilter = n(a.magFilter, Fc)), void 0 !== a.anisotropy && (s.anisotropy = a.anisotropy), void 0 !== a.flipY && (s.flipY = a.flipY), void 0 !== a.premultiplyAlpha && (s.premultiplyAlpha = a.premultiplyAlpha), void 0 !== a.unpackAlignment && (s.unpackAlignment = a.unpackAlignment), void 0 !== a.userData && (s.userData = a.userData), i[a.uuid] = s
                        }
                    return i
                }
                parseObject(e, t, n, i, r) {
                    let a, s, o;
                    function l(e) {
                        return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), t[e]
                    }
                    function c(e) {
                        if (void 0 !== e) {
                            if (Array.isArray(e)) {
                                const t = [];
                                for (let i = 0, r = e.length; i < r; i++) {
                                    const r = e[i];
                                    void 0 === n[r] && console.warn("THREE.ObjectLoader: Undefined material", r), t.push(n[r])
                                }
                                return t
                            }
                            return void 0 === n[e] && console.warn("THREE.ObjectLoader: Undefined material", e), n[e]
                        }
                    }
                    function u(e) {
                        return void 0 === i[e] && console.warn("THREE.ObjectLoader: Undefined texture", e), i[e]
                    }
                    switch (e.type) {
                    case "Scene":
                        a = new Ka, void 0 !== e.background && (Number.isInteger(e.background) ? a.background = new tn(e.background) : a.background = u(e.background)), void 0 !== e.environment && (a.environment = u(e.environment)), void 0 !== e.fog && ("Fog" === e.fog.type ? a.fog = new Za(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (a.fog = new Ja(e.fog.color, e.fog.density)));
                        break;
                    case "PerspectiveCamera":
                        a = new Jn(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (a.focus = e.focus), void 0 !== e.zoom && (a.zoom = e.zoom), void 0 !== e.filmGauge && (a.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (a.filmOffset = e.filmOffset), void 0 !== e.view && (a.view = Object.assign({}, e.view));
                        break;
                    case "OrthographicCamera":
                        a = new bi(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (a.zoom = e.zoom), void 0 !== e.view && (a.view = Object.assign({}, e.view));
                        break;
                    case "AmbientLight":
                        a = new Ec(e.color, e.intensity);
                        break;
                    case "DirectionalLight":
                        a = new wc(e.color, e.intensity);
                        break;
                    case "PointLight":
                        a = new bc(e.color, e.intensity, e.distance, e.decay);
                        break;
                    case "RectAreaLight":
                        a = new Mc(e.color, e.intensity, e.width, e.height);
                        break;
                    case "SpotLight":
                        a = new mc(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
                        break;
                    case "HemisphereLight":
                        a = new cc(e.color, e.groundColor, e.intensity);
                        break;
                    case "LightProbe":
                        a = (new Sc).fromJSON(e);
                        break;
                    case "SkinnedMesh":
                        s = l(e.geometry), o = c(e.material), a = new Ss(s, o), void 0 !== e.bindMode && (a.bindMode = e.bindMode), void 0 !== e.bindMatrix && a.bindMatrix.fromArray(e.bindMatrix), void 0 !== e.skeleton && (a.skeleton = e.skeleton);
                        break;
                    case "Mesh":
                        s = l(e.geometry), o = c(e.material), a = new Gn(s, o);
                        break;
                    case "InstancedMesh":
                        s = l(e.geometry), o = c(e.material);
                        const t = e.count,
                            n = e.instanceMatrix,
                            i = e.instanceColor;
                        a = new Hs(s, o, t), a.instanceMatrix = new Is(new Float32Array(n.array), 16), void 0 !== i && (a.instanceColor = new Is(new Float32Array(i.array), i.itemSize));
                        break;
                    case "LOD":
                        a = new bs;
                        break;
                    case "Line":
                        a = new js(l(e.geometry), c(e.material));
                        break;
                    case "LineLoop":
                        a = new qs(l(e.geometry), c(e.material));
                        break;
                    case "LineSegments":
                        a = new Ys(l(e.geometry), c(e.material));
                        break;
                    case "PointCloud":
                    case "Points":
                        a = new eo(l(e.geometry), c(e.material));
                        break;
                    case "Sprite":
                        a = new gs(c(e.material));
                        break;
                    case "Group":
                        a = new Ga;
                        break;
                    case "Bone":
                        a = new As;
                        break;
                    default:
                        a = new Nt
                    }
                    if (a.uuid = e.uuid, void 0 !== e.name && (a.name = e.name), void 0 !== e.matrix ? (a.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (a.matrixAutoUpdate = e.matrixAutoUpdate), a.matrixAutoUpdate && a.matrix.decompose(a.position, a.quaternion, a.scale)) : (void 0 !== e.position && a.position.fromArray(e.position), void 0 !== e.rotation && a.rotation.fromArray(e.rotation), void 0 !== e.quaternion && a.quaternion.fromArray(e.quaternion), void 0 !== e.scale && a.scale.fromArray(e.scale)), void 0 !== e.castShadow && (a.castShadow = e.castShadow), void 0 !== e.receiveShadow && (a.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (a.shadow.bias = e.shadow.bias), void 0 !== e.shadow.normalBias && (a.shadow.normalBias = e.shadow.normalBias), void 0 !== e.shadow.radius && (a.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && a.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (a.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (a.visible = e.visible), void 0 !== e.frustumCulled && (a.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (a.renderOrder = e.renderOrder), void 0 !== e.userData && (a.userData = e.userData), void 0 !== e.layers && (a.layers.mask = e.layers), void 0 !== e.children) {
                        const s = e.children;
                        for (let e = 0; e < s.length; e++) a.add(this.parseObject(s[e], t, n, i, r))
                    }
                    if (void 0 !== e.animations) {
                        const t = e.animations;
                        for (let e = 0; e < t.length; e++) {
                            const n = t[e];
                            a.animations.push(r[n])
                        }
                    }
                    if ("LOD" === e.type) {
                        void 0 !== e.autoUpdate && (a.autoUpdate = e.autoUpdate);
                        const t = e.levels;
                        for (let e = 0; e < t.length; e++) {
                            const n = t[e],
                                i = a.getObjectByProperty("uuid", n.object);
                            void 0 !== i && a.addLevel(i, n.distance)
                        }
                    }
                    return a
                }
                bindSkeletons(e, t) {
                    0 !== Object.keys(t).length && e.traverse((function (e) {
                        if (!0 === e.isSkinnedMesh && void 0 !== e.skeleton) {
                            const n = t[e.skeleton];
                            void 0 === n ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", e.skeleton) : e.bind(n, e.bindMatrix)
                        }
                    }))
                }
                setTexturePath(e) {
                    return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(e)
                }
            }, e.ObjectSpaceNormalMap = 1, e.OctahedronBufferGeometry = gl, e.OctahedronGeometry = gl, e.OneFactor = 201, e.OneMinusDstAlphaFactor = 207, e.OneMinusDstColorFactor = 209, e.OneMinusSrcAlphaFactor = 205, e.OneMinusSrcColorFactor = 203, e.OrthographicCamera = bi, e.PCFShadowMap = 1, e.PCFSoftShadowMap = 2, e.PMREMGenerator = Ni, e.ParametricGeometry = function () {
                return console.error("THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js"), new Mn
            }, e.Particle = function (e) {
                return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new gs(e)
            }, e.ParticleBasicMaterial = function (e) {
                return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Qs(e)
            }, e.ParticleSystem = function (e, t) {
                return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new eo(e, t)
            }, e.ParticleSystemMaterial = function (e) {
                return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Qs(e)
            }, e.Path = Ho, e.PerspectiveCamera = Jn, e.Plane = ri, e.PlaneBufferGeometry = ui, e.PlaneGeometry = ui, e.PlaneHelper = class extends js {
                constructor(e, t = 1, n = 16776960) {
                    const i = n,
                        r = new Mn;
                    r.setAttribute("position", new mn([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), r.computeBoundingSphere(), super(r, new Us({
                        color: i,
                        toneMapped: false
                    })), this.type = "PlaneHelper", this.plane = e, this.size = t;
                    const a = new Mn;
                    a.setAttribute("position", new mn([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), a.computeBoundingSphere(), this.add(new Gn(a, new nn({
                        color: i,
                        opacity: .2,
                        transparent: true,
                        depthWrite: false,
                        toneMapped: false
                    })))
                }
                updateMatrixWorld(e) {
                    let t = -this.plane.constant;
                    Math.abs(t) < 1e-8 && (t = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, t), this.children[0].material.side = t < 0 ? 1 : 0, this.lookAt(this.plane.normal), super.updateMatrixWorld(e)
                }
            }, e.PointCloud = function (e, t) {
                return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new eo(e, t)
            }, e.PointCloudMaterial = function (e) {
                return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Qs(e)
            }, e.PointLight = bc, e.PointLightHelper = class extends Gn {
                constructor(e, t, n) {
                    super(new xl(t, 4, 2), new nn({
                        wireframe: true,
                        fog: false,
                        toneMapped: false
                    })), this.light = e, this.light.updateMatrixWorld(), this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = false, this.update()
                }
                dispose() {
                    this.geometry.dispose(), this.material.dispose()
                }
                update() {
                    void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
                }
            }, e.Points = eo, e.PointsMaterial = Qs, e.PolarGridHelper = class extends Ys {
                constructor(e = 10, t = 16, n = 8, i = 64, r = 4473924, a = 8947848) {
                    r = new tn(r), a = new tn(a);
                    const s = [],
                        o = [];
                    for (let n = 0; n <= t; n++) {
                        const i = n / t * (2 * Math.PI),
                            l = Math.sin(i) * e,
                            c = Math.cos(i) * e;
                        s.push(0, 0, 0), s.push(l, 0, c);
                        const u = 1 & n ? r : a;
                        o.push(u.r, u.g, u.b), o.push(u.r, u.g, u.b)
                    }
                    for (let t = 0; t <= n; t++) {
                        const l = 1 & t ? r : a,
                            c = e - e / n * t;
                        for (let e = 0; e < i; e++) {
                            let t = e / i * (2 * Math.PI),
                                n = Math.sin(t) * c,
                                r = Math.cos(t) * c;
                            s.push(n, 0, r), o.push(l.r, l.g, l.b), t = (e + 1) / i * (2 * Math.PI), n = Math.sin(t) * c, r = Math.cos(t) * c, s.push(n, 0, r), o.push(l.r, l.g, l.b)
                        }
                    }
                    const l = new Mn;
                    l.setAttribute("position", new mn(s, 3)), l.setAttribute("color", new mn(o, 3)), super(l, new Us({
                        vertexColors: true,
                        toneMapped: false
                    })), this.type = "PolarGridHelper"
                }
            }, e.PolyhedronBufferGeometry = lo, e.PolyhedronGeometry = lo, e.PositionalAudio = class extends Qc {
                constructor(e) {
                    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
                }
                getOutput() {
                    return this.panner
                }
                getRefDistance() {
                    return this.panner.refDistance
                }
                setRefDistance(e) {
                    return this.panner.refDistance = e, this
                }
                getRolloffFactor() {
                    return this.panner.rolloffFactor
                }
                setRolloffFactor(e) {
                    return this.panner.rolloffFactor = e, this
                }
                getDistanceModel() {
                    return this.panner.distanceModel
                }
                setDistanceModel(e) {
                    return this.panner.distanceModel = e, this
                }
                getMaxDistance() {
                    return this.panner.maxDistance
                }
                setMaxDistance(e) {
                    return this.panner.maxDistance = e, this
                }
                setDirectionalCone(e, t, n) {
                    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this
                }
                updateMatrixWorld(e) {
                    if (super.updateMatrixWorld(e), !0 === this.hasPlaybackControl && !1 === this.isPlaying) return;
                    this.matrixWorld.decompose(Jc, Zc, Kc), $c.set(0, 0, 1).applyQuaternion(Zc);
                    const t = this.panner;
                    if (t.positionX) {
                        const e = this.context.currentTime + this.listener.timeDelta;
                        t.positionX.linearRampToValueAtTime(Jc.x, e), t.positionY.linearRampToValueAtTime(Jc.y, e), t.positionZ.linearRampToValueAtTime(Jc.z, e), t.orientationX.linearRampToValueAtTime($c.x, e), t.orientationY.linearRampToValueAtTime($c.y, e), t.orientationZ.linearRampToValueAtTime($c.z, e)
                    } else t.setPosition(Jc.x, Jc.y, Jc.z), t.setOrientation($c.x, $c.y, $c.z)
                }
            }, e.PropertyBinding = hu, e.PropertyMixer = tu, e.QuadraticBezierCurve = Io, e.QuadraticBezierCurve3 = Fo, e.Quaternion = Ie, e.QuaternionKeyframeTrack = Yl, e.QuaternionLinearInterpolant = Xl, e.REVISION = t, e.RGBADepthPacking = 3201, e.RGBAFormat = S, e.RGBAIntegerFormat = 1033, e.RGBA_ASTC_10x10_Format = 37819, e.RGBA_ASTC_10x5_Format = 37816, e.RGBA_ASTC_10x6_Format = 37817, e.RGBA_ASTC_10x8_Format = 37818, e.RGBA_ASTC_12x10_Format = 37820, e.RGBA_ASTC_12x12_Format = 37821, e.RGBA_ASTC_4x4_Format = 37808, e.RGBA_ASTC_5x4_Format = 37809, e.RGBA_ASTC_5x5_Format = 37810, e.RGBA_ASTC_6x5_Format = 37811, e.RGBA_ASTC_6x6_Format = 37812, e.RGBA_ASTC_8x5_Format = 37813, e.RGBA_ASTC_8x6_Format = 37814, e.RGBA_ASTC_8x8_Format = 37815, e.RGBA_BPTC_Format = 36492, e.RGBA_ETC2_EAC_Format = U, e.RGBA_PVRTC_2BPPV1_Format = O, e.RGBA_PVRTC_4BPPV1_Format = N, e.RGBA_S3TC_DXT1_Format = P, e.RGBA_S3TC_DXT3_Format = C, e.RGBA_S3TC_DXT5_Format = I, e.RGBDEncoding = K, e.RGBEEncoding = Q, e.RGBEFormat = 1023, e.RGBFormat = T, e.RGBIntegerFormat = 1032, e.RGBM16Encoding = Z, e.RGBM7Encoding = J, e.RGB_ETC1_Format = 36196, e.RGB_ETC2_Format = H, e.RGB_PVRTC_2BPPV1_Format = D, e.RGB_PVRTC_4BPPV1_Format = F, e.RGB_S3TC_DXT1_Format = R, e.RGFormat = 1030, e.RGIntegerFormat = 1031, e.RawShaderMaterial = _i, e.Ray = ct, e.Raycaster = class {
                constructor(e, t, n = 0, i = 1 / 0) {
                    this.ray = new ct(e, t), this.near = n, this.far = i, this.camera = null, this.layers = new _t, this.params = {
                        Mesh: {},
                        Line: {
                            threshold: 1
                        },
                        LOD: {},
                        Points: {
                            threshold: 1
                        },
                        Sprite: {}
                    }
                }
                set(e, t) {
                    this.ray.set(e, t)
                }
                setFromCamera(e, t) {
                    t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
                }
                intersectObject(e, t = true, n = []) {
                    return xu(e, this, n, t), n.sort(yu), n
                }
                intersectObjects(e, t = true, n = []) {
                    for (let i = 0, r = e.length; i < r; i++) xu(e[i], this, n, t);
                    return n.sort(yu), n
                }
            }, e.RectAreaLight = Mc, e.RedFormat = 1028, e.RedIntegerFormat = 1029, e.ReinhardToneMapping = 2, e.RepeatWrapping = u, e.ReplaceStencilOp = 7681, e.ReverseSubtractEquation = 102, e.RingBufferGeometry = vl, e.RingGeometry = vl, e.SRGB8_ALPHA8_ASTC_10x10_Format = 37851, e.SRGB8_ALPHA8_ASTC_10x5_Format = 37848, e.SRGB8_ALPHA8_ASTC_10x6_Format = 37849, e.SRGB8_ALPHA8_ASTC_10x8_Format = 37850, e.SRGB8_ALPHA8_ASTC_12x10_Format = 37852, e.SRGB8_ALPHA8_ASTC_12x12_Format = 37853, e.SRGB8_ALPHA8_ASTC_4x4_Format = 37840, e.SRGB8_ALPHA8_ASTC_5x4_Format = 37841, e.SRGB8_ALPHA8_ASTC_5x5_Format = 37842, e.SRGB8_ALPHA8_ASTC_6x5_Format = 37843, e.SRGB8_ALPHA8_ASTC_6x6_Format = 37844, e.SRGB8_ALPHA8_ASTC_8x5_Format = 37845, e.SRGB8_ALPHA8_ASTC_8x6_Format = 37846, e.SRGB8_ALPHA8_ASTC_8x8_Format = 37847, e.Scene = Ka, e.SceneUtils = Qu, e.ShaderChunk = hi, e.ShaderLib = pi, e.ShaderMaterial = qn, e.ShadowMaterial = Al, e.Shape = Uo, e.ShapeBufferGeometry = yl, e.ShapeGeometry = yl, e.ShapePath = class {
                constructor() {
                    this.type = "ShapePath", this.color = new tn, this.subPaths = [], this.currentPath = null
                }
                moveTo(e, t) {
                    return this.currentPath = new Ho, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this
                }
                lineTo(e, t) {
                    return this.currentPath.lineTo(e, t), this
                }
                quadraticCurveTo(e, t, n, i) {
                    return this.currentPath.quadraticCurveTo(e, t, n, i), this
                }
                bezierCurveTo(e, t, n, i, r, a) {
                    return this.currentPath.bezierCurveTo(e, t, n, i, r, a), this
                }
                splineThru(e) {
                    return this.currentPath.splineThru(e), this
                }
                toShapes(e, t) {
                    function n(e) {
                        const t = [];
                        for (let n = 0, i = e.length; n < i; n++) {
                            const i = e[n],
                                r = new Uo;
                            r.curves = i.curves, t.push(r)
                        }
                        return t
                    }
                    function i(e, t) {
                        const n = t.length;
                        let i = false;
                        for (let r = n - 1, a = 0; a < n; r = a++) {
                            let n = t[r],
                                s = t[a],
                                o = s.x - n.x,
                                l = s.y - n.y;
                            if (Math.abs(l) > Number.EPSILON) {
                                if (l < 0 && (n = t[a], o = -o, s = t[r], l = -l), e.y < n.y || e.y > s.y) continue;
                                if (e.y === n.y) {
                                    if (e.x === n.x) return true
                                } else {
                                    const t = l * (e.x - n.x) - o * (e.y - n.y);
                                    if (0 === t) return true;
                                    if (t < 0) continue;
                                    i = !i
                                }
                            } else {
                                if (e.y !== n.y) continue;
                                if (s.x <= e.x && e.x <= n.x || n.x <= e.x && e.x <= s.x) return true
                            }
                        }
                        return i
                    }
                    const r = cl.isClockWise,
                        a = this.subPaths;
                    if (0 === a.length) return [];
                    if (!0 === t) return n(a);
                    let s, o, l;
                    const c = [];
                    if (1 === a.length) return o = a[0], l = new Uo, l.curves = o.curves, c.push(l), c;
                    let u = !r(a[0].getPoints());
                    u = e ? !u : u;
                    const h = [],
                        d = [];
                    let p, f, m = [],
                        g = 0;
                    d[g] = void 0, m[g] = [];
                    for (let t = 0, n = a.length; t < n; t++) o = a[t], p = o.getPoints(), s = r(p), s = e ? !s : s, s ? (!u && d[g] && g++, d[g] = {
                        s: new Uo,
                        p: p
                    }, d[g].s.curves = o.curves, u && g++, m[g] = []) : m[g].push({
                        h: o,
                        p: p[0]
                    });
                    if (!d[0]) return n(a);
                    if (d.length > 1) {
                        let e = false;
                        const t = [];
                        for (let e = 0, t = d.length; e < t; e++) h[e] = [];
                        for (let n = 0, r = d.length; n < r; n++) {
                            const r = m[n];
                            for (let a = 0; a < r.length; a++) {
                                const s = r[a];
                                let o = true;
                                for (let r = 0; r < d.length; r++) i(s.p, d[r].p) && (n !== r && t.push({
                                    froms: n,
                                    tos: r,
                                    hole: a
                                }), o ? (o = false, h[r].push(s)) : e = true);
                                o && h[n].push(s)
                            }
                        }
                        t.length > 0 && (e || (m = h))
                    }
                    for (let e = 0, t = d.length; e < t; e++) {
                        l = d[e].s, c.push(l), f = m[e];
                        for (let e = 0, t = f.length; e < t; e++) l.holes.push(f[e].h)
                    }
                    return c
                }
            }, e.ShapeUtils = cl, e.ShortType = 1011, e.Skeleton = Cs, e.SkeletonHelper = Ru, e.SkinnedMesh = Ss, e.SmoothShading = 2, e.Sphere = tt, e.SphereBufferGeometry = xl, e.SphereGeometry = xl, e.Spherical = class {
                constructor(e = 1, t = 0, n = 0) {
                    return this.radius = e, this.phi = t, this.theta = n, this
                }
                set(e, t, n) {
                    return this.radius = e, this.phi = t, this.theta = n, this
                }
                copy(e) {
                    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
                }
                makeSafe() {
                    const e = 1e-6;
                    return this.phi = Math.max(e, Math.min(Math.PI - e, this.phi)), this
                }
                setFromVector3(e) {
                    return this.setFromCartesianCoords(e.x, e.y, e.z)
                }
                setFromCartesianCoords(e, t, n) {
                    return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(ce(t / this.radius, -1, 1))), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }, e.SphericalHarmonics3 = Tc, e.SplineCurve = Do, e.SpotLight = mc, e.SpotLightHelper = class extends Nt {
                constructor(e, t) {
                    super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = false, this.color = t;
                    const n = new Mn,
                        i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
                    for (let e = 0, t = 1, n = 32; e < n; e++, t++) {
                        const r = e / n * Math.PI * 2,
                            a = t / n * Math.PI * 2;
                        i.push(Math.cos(r), Math.sin(r), 1, Math.cos(a), Math.sin(a), 1)
                    }
                    n.setAttribute("position", new mn(i, 3));
                    const r = new Us({
                        fog: false,
                        toneMapped: false
                    });
                    this.cone = new Ys(n, r), this.add(this.cone), this.update()
                }
                dispose() {
                    this.cone.geometry.dispose(), this.cone.material.dispose()
                }
                update() {
                    this.light.updateMatrixWorld();
                    const e = this.light.distance ? this.light.distance : 1e3,
                        t = e * Math.tan(this.light.angle);
                    this.cone.scale.set(t, t, e), Tu.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(Tu), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
                }
            }, e.Sprite = gs, e.SpriteMaterial = ns, e.SrcAlphaFactor = 204, e.SrcAlphaSaturateFactor = 210, e.SrcColorFactor = 202, e.StaticCopyUsage = 35046, e.StaticDrawUsage = ee, e.StaticReadUsage = 35045, e.StereoCamera = class {
                constructor() {
                    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Jn, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = false, this.cameraR = new Jn, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = false, this._cache = {
                        focus: null,
                        fov: null,
                        aspect: null,
                        near: null,
                        far: null,
                        zoom: null,
                        eyeSep: null
                    }
                }
                update(e) {
                    const t = this._cache;
                    if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
                        t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, Gc.copy(e.projectionMatrix);
                        const n = t.eyeSep / 2,
                            i = n * t.near / t.focus,
                            r = t.near * Math.tan(se * t.fov * .5) / t.zoom;
                        let a, s;
                        kc.elements[12] = -n, zc.elements[12] = n, a = -r * t.aspect + i, s = r * t.aspect + i, Gc.elements[0] = 2 * t.near / (s - a), Gc.elements[8] = (s + a) / (s - a), this.cameraL.projectionMatrix.copy(Gc), a = -r * t.aspect - i, s = r * t.aspect - i, Gc.elements[0] = 2 * t.near / (s - a), Gc.elements[8] = (s + a) / (s - a), this.cameraR.projectionMatrix.copy(Gc)
                    }
                    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(kc), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(zc)
                }
            }, e.StreamCopyUsage = 35042, e.StreamDrawUsage = 35040, e.StreamReadUsage = 35041, e.StringKeyframeTrack = ql, e.SubtractEquation = 101, e.SubtractiveBlending = 3, e.TOUCH = {
                ROTATE: 0,
                PAN: 1,
                DOLLY_PAN: 2,
                DOLLY_ROTATE: 3
            }, e.TangentSpaceNormalMap = 0, e.TetrahedronBufferGeometry = bl, e.TetrahedronGeometry = bl, e.TextGeometry = function () {
                return console.error("THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js"), new Mn
            }, e.Texture = Se, e.TextureLoader = oc, e.TorusBufferGeometry = _l, e.TorusGeometry = _l, e.TorusKnotBufferGeometry = wl, e.TorusKnotGeometry = wl, e.Triangle = Xt, e.TriangleFanDrawMode = 2, e.TriangleStripDrawMode = 1, e.TrianglesDrawMode = 0, e.TubeBufferGeometry = El, e.TubeGeometry = El, e.UVMapping = i, e.Uint16Attribute = function (e, t) {
                return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new hn(e, t)
            }, e.Uint16BufferAttribute = hn, e.Uint32Attribute = function (e, t) {
                return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new pn(e, t)
            }, e.Uint32BufferAttribute = pn, e.Uint8Attribute = function (e, t) {
                return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new ln(e, t)
            }, e.Uint8BufferAttribute = ln, e.Uint8ClampedAttribute = function (e, t) {
                return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new cn(e, t)
            }, e.Uint8ClampedBufferAttribute = cn, e.Uniform = mu, e.UniformsLib = di, e.UniformsUtils = Yn, e.UnsignedByteType = x, e.UnsignedInt248Type = M, e.UnsignedIntType = _, e.UnsignedShort4444Type = 1017, e.UnsignedShort5551Type = 1018, e.UnsignedShort565Type = 1019, e.UnsignedShortType = b, e.VSMShadowMap = 3, e.Vector2 = ge, e.Vector3 = Fe, e.Vector4 = Le, e.VectorKeyframeTrack = Ql, e.Vertex = function (e, t, n) {
                return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new Fe(e, t, n)
            }, e.VertexColors = 2, e.VideoTexture = no, e.WebGL1Renderer = Qa, e.WebGLCubeRenderTarget = ei, e.WebGLMultipleRenderTargets = Pe, e.WebGLMultisampleRenderTarget = Ce, e.WebGLRenderTarget = Re, e.WebGLRenderTargetCube = function (e, t, n) {
                return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."), new ei(e, n)
            }, e.WebGLRenderer = qa, e.WebGLUtils = za, e.WireframeGeometry = Ml, e.WireframeHelper = function (e, t) {
                return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Ys(new Ml(e.geometry), new Us({
                    color: void 0 !== t ? t : 16777215
                }))
            }, e.WrapAroundEnding = j, e.XHRLoader = function (e) {
                return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new ic(e)
            }, e.ZeroCurvatureEnding = G, e.ZeroFactor = 200, e.ZeroSlopeEnding = V, e.ZeroStencilOp = 0, e.sRGBEncoding = Y, Object.defineProperty(e, "__esModule", {
                value: true
            })
        }, "object" == typeof n && void 0 !== t ? r(n) : "function" == typeof define && define.amd ? define(["exports"], r) : r((i = "undefined" != typeof globalThis ? globalThis : i || self).THREE = {})
    }, {}]
}, {}, [58]);